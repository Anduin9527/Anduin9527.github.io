<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#66d6ff"><meta name="author" content="Anduin9527"><meta name="copyright" content="Anduin9527"><meta name="generator" content="Hexo 6.2.0"><meta name="theme" content="hexo-theme-yun"><title>计算机组成原理笔记（六） | Anduin9527的乖离器</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js"></script><script type="module">import { renderKatex } from '/js/utils.js'
document.addEventListener("DOMContentLoaded", () => {
  renderKatex({
    ...{},
    ...true?.options,
  });
});</script><link rel="icon" type="image/svg+xml" href="/images/favicon.svg"><link rel="mask-icon" href="/images/favicon.svg" color="#66d6ff"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"lapras.xyz","root":"/","title":["拉普","拉斯~","的","乖离器"],"version":"1.10.6","mode":"time","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","fireworks":{"colors":["#00D1CE","#66D6FF","#919191"]},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="Anduin9527的乖离器" type="application/atom+xml"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap"><script src="/h" async></script><script src="/t" async></script><script src="/t" async></script><script src="/p" async></script><script src="/s" async></script><script src="/:" async></script><script src="/" async></script><script src="/" async></script><script src="/c" async></script><script src="/d" async></script><script src="/n" async></script><script src="/." async></script><script src="/j" async></script><script src="/s" async></script><script src="/d" async></script><script src="/e" async></script><script src="/l" async></script><script src="/i" async></script><script src="/v" async></script><script src="/r" async></script><script src="/." async></script><script src="/n" async></script><script src="/e" async></script><script src="/t" async></script><script src="/" async></script><script src="/n" async></script><script src="/p" async></script><script src="/m" async></script><script src="/" async></script><script src="/i" async></script><script src="/o" async></script><script src="/n" async></script><script src="/i" async></script><script src="/c" async></script><script src="/o" async></script><script src="/n" async></script><script src="/s" async></script><script src="/" async></script><script src="/d" async></script><script src="/i" async></script><script src="/s" async></script><script src="/t" async></script><script src="/" async></script><script src="/i" async></script><script src="/o" async></script><script src="/n" async></script><script src="/i" async></script><script src="/c" async></script><script src="/o" async></script><script src="/n" async></script><script src="/s" async></script><script src="/." async></script><script src="/j" async></script><script src="/s" async></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-NSLVQ2H5JH"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-NSLVQ2H5JH');
}</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><meta name="description" content="前言 绝区零好潮。。。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理笔记（六）">
<meta property="og:url" content="http://lapras.xyz/2022/08/08/9b046e01.html">
<meta property="og:site_name" content="Anduin9527的乖离器">
<meta property="og:description" content="前言 绝区零好潮。。。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220808231206.jpeg">
<meta property="og:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8E%9F%E5%8F%8D%E8%A1%A5%E5%B0%8F%E7%BB%93.png">
<meta property="og:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A7%BB%E7%A0%81%E6%AF%94%E8%BE%83.png">
<meta property="og:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA.png">
<meta property="og:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BD%A2%E5%BC%8F.png">
<meta property="og:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E8%8C%83%E5%9B%B41.png">
<meta property="og:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E4%BE%8B%E5%AD%90.png">
<meta property="og:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/IEEE.png">
<meta property="og:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B9%98%E6%B3%95%E6%94%B9%E8%BF%9B.png">
<meta property="og:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9B%9E%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95.png">
<meta property="og:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95.png">
<meta property="article:published_time" content="2022-08-08T15:53:07.000Z">
<meta property="article:modified_time" content="2022-08-09T13:43:48.309Z">
<meta property="article:author" content="Anduin9527">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="硬件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220808231206.jpeg"><script type="module">import { getScript } from '/js/utils.js'
getScript("https://fastly.jsdelivr.net/npm/mermaid/dist/mermaid.min.js", () => {
  const mermaidOptions = {"startOnload":true}
  mermaid.initialize(mermaidOptions);
}, window.mermaid);
</script><style>.mermaid{background: transparent;}</style><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Anduin9527"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Anduin9527"><span class="site-author-status" title="建模建模呜呜呜！">😭</span></a><div class="site-author-name"><a href="/about/">Anduin9527</a></div><span class="site-name">Anduin9527的乖离器</span><sub class="site-subtitle">正在进修摸鱼学导论</sub><div class="site-description">南邮摸鱼ing</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">35</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">7</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">28</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="tencent://message/?uin=2676057183&amp;Site=&amp;Menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Anduin9527" title="GitHub" target="_blank" style="color:#181717"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:2676057183@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=579015212" title="网易云音乐" target="_blank" style="color:#C10D0C"><span class="icon iconify" data-icon="ri:netease-cloud-music-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/chu-liu-16-64" title="知乎" target="_blank" style="color:#0084FF"><span class="icon iconify" data-icon="ri:zhihu-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/21994551" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><span class="icon iconify" data-icon="ri:rss-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a><a class="links-item hty-icon-button" href="/girls/" title="我永远喜欢oo" style="color:hotpink"><span class="icon iconify" data-icon="ri:women-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0"><span class="toc-text">无符号数和有符号数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0"><span class="toc-text">无符号数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0"><span class="toc-text">有符号数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E6%95%B0%E4%B8%8E%E7%9C%9F%E5%80%BC"><span class="toc-text">机器数与真值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">原码表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">补码表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">反码表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">移码表示法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA"><span class="toc-text">数的定点表示和浮点表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA"><span class="toc-text">定点表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA"><span class="toc-text">浮点表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="toc-text">浮点数的表现形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4"><span class="toc-text">浮点数的表示范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A7%84%E6%A0%BC%E5%8C%96"><span class="toc-text">浮点数的规格化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">定点数和浮点数的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ieee-754%E6%A0%87%E5%87%86"><span class="toc-text">IEEE 754标准</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97"><span class="toc-text">定点运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">移位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D"><span class="toc-text">算术移位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D"><span class="toc-text">逻辑移位</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-text">加减运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-text">补码加减法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E5%88%A4%E6%96%AD"><span class="toc-text">溢出判断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-text">乘法运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95"><span class="toc-text">原码一位乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95"><span class="toc-text">补码一位乘法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-text">除法运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95"><span class="toc-text">原码恢复余数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95"><span class="toc-text">原码加减交替法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E9%99%A4%E6%B3%95"><span class="toc-text">补码除法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97"><span class="toc-text">浮点四则运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-text">浮点加减运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E9%98%B6"><span class="toc-text">对阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E6%95%B0%E6%B1%82%E5%92%8C"><span class="toc-text">尾数求和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E6%A0%BC%E5%8C%96"><span class="toc-text">规格化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%88%8D%E5%85%A5"><span class="toc-text">舍入</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#66d6ff;"><link itemprop="mainEntityOfPage" href="http://lapras.xyz/2022/08/08/9b046e01.html"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Anduin9527"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Anduin9527的乖离器"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">计算机组成原理笔记（六）</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="Created: 2022-08-08 23:53:07" itemprop="dateCreated datePublished" datetime="2022-08-08T23:53:07+08:00">2022-08-08</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="Modified: 2022-08-09 21:43:48" itemprop="dateModified" datetime="2022-08-09T21:43:48+08:00">2022-08-09</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><span class="icon iconify" data-icon="ri:file-word-line"></span></span> <span title="Word count in article">6.2k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><span class="icon iconify" data-icon="ri:timer-line"></span></span> <span title="Reading time">23m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="--text-color:#736e30" itemprop="url" rel="index"><span itemprop="text">计算机组成原理</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E7%AC%94%E8%AE%B0/" style="--text-color:dimgray"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">笔记</span></a><a class="tag-item" href="/tags/%E7%A1%AC%E4%BB%B6/" style="--text-color:#ecf0f1"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">硬件</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="前言">前言</h2>
<p>绝区零好潮。。。</p>
<p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220808231206.jpeg" alt="img" style="zoom:80%;" / loading="lazy"></p>
<span id="more"></span>
<h2 id="无符号数和有符号数">无符号数和有符号数</h2>
<h3 id="无符号数">无符号数</h3>
<p>计算机中的数均放在<strong>寄存器</strong>中，通常称寄存器的位数为<strong>机器字长</strong>。<strong>所谓无符号数，即没有符号的数</strong>，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的。比如用一个八位的寄存器保存无符号数，则可以表示0~255。</p>
<h3 id="有符号数">有符号数</h3>
<h4 id="机器数与真值">机器数与真值</h4>
<p>因为计算机没有办法直接识别正负号，所以需要将正负号转化为数字来存储。保存在计算机中将正负号“数字化”之后的数称为<strong>机器数</strong>，而<strong>真值</strong>是我们日常生活中包含了正负号的数值。注意：以下内容默认都为2进制数</p>
<h4 id="原码表示法">原码表示法</h4>
<p>原码是机器数中最简单的一种表示形式，符号位为0表示正数，符号位为1表示负数，<strong>数值位即真值的绝对值</strong>，故原码表示又称为带符号的绝对值表示。为了书写方便以及区别整数和小数，约定整数的符号位与数值位之间用逗号隔开；小数的符号位与数值位之间用小数点隔开。由此可得原码的定义： <span class="math display">\[
[x]_{\text {原}}=\left\{\begin{array}{cc}
0, \ x &amp; 2^{n}&gt;x \geqslant 0 \\
2^{n}-x &amp; 0 \geqslant x&gt; -2^{n}
\end{array}\right.
\]</span> 例如，当<span class="math inline">\(x= -1110\)</span>时，<span class="math inline">\([x]_{\text {原}} = 2^4 - (-1110) = 1,1110\)</span></p>
<p>对于小数部分： <span class="math display">\[
[x]_{\text {原 }}=\left\{\begin{array}{cc}
x &amp; 1&gt;x \geqslant 0 \\
1-x &amp; 0 \geqslant x&gt;-1
\end{array}\right.
\]</span> 例如，当<span class="math inline">\(x= +0.1101\)</span>时，<span class="math inline">\([x]_{\text {原}} = 0.1101\)</span>，注意这里两个<span class="math inline">\(0.\)</span>的含义不同，后者表示正数+区分符</p>
<ul>
<li><p>不难发现，对于<span class="math inline">\(0\)</span>而言，<span class="math inline">\([+0000]_{\text {原}} = 0,0000 ;\ [-0000]_{\text {原}} = 1,0000\)</span>，两者并不相同</p></li>
<li><p>原码特点：简单且直观，但运算复杂。当两个操作数符号不同且要作加法运算时，先要判断两数绝对值大小，然后将绝对值大的数减去绝对值小的数，结果的符号以绝对值大的数为准。而且用到的是减法器实现。</p></li>
</ul>
<h4 id="补码表示法">补码表示法</h4>
<p>为了解决原码在计算中的问题，即用一个与负数等价的正数表示负数，使得运算中只需要加法器。</p>
<p>所谓补数，就是其本身加上<strong>模</strong>。正数的补数是其自身，负数的补数是其本身加上模，当一个正数和一个负数互为补数的时候，其绝对值之和为模数。那么对于2进制数而言，模就是<span class="math inline">\(2^n\)</span>，但是为了能表示正负，即负数的首位为1，选择将模设置为<span class="math inline">\(2^{n+1}\)</span>。 <span class="math display">\[
[x]_{\text {补 }}= \begin{cases}0,\ x &amp; 2^{n}&gt;x \geqslant 0 \\ 2^{n+1}+x &amp; 0&gt;x \geqslant-2^{n} \quad\left(\bmod 2^{n+1}\right)\end{cases}
\]</span> 例如，<span class="math inline">\(x = -1011000\)</span>，则<span class="math inline">\([x]_{\text{补}} = 2^{7+1} + (-1011000) = 1,0101000\)</span></p>
<p>小数： <span class="math display">\[
[x]_{\text {补 }}= \begin{cases}x &amp; 1&gt;x \geqslant 0 \\ 2+x &amp; 0&gt;x \geqslant-1 \quad(\bmod 2)\end{cases}
\]</span></p>
<p>例如，<span class="math inline">\(x = -0.1100000\)</span>，则<span class="math inline">\([x]_{\text{补}} = 2+(-0.1100000) = 1.0100000\)</span></p>
<ul>
<li>我们也可以通过口诀“<strong>原码取反（变为反码）再加1</strong>”快速计算一个数的补码</li>
<li>不难发现，对于<span class="math inline">\(0\)</span>而言，<span class="math inline">\([+0000]_{\text {补}} = 0,0000 ;\ [-0000]_{\text {补}} = 2^{4+1} - 0000=100000 -0000 = 0,0000\)</span>，最高位溢出舍去，所以补码的0表现形式是一致的</li>
</ul>
<h4 id="反码表示法">反码表示法</h4>
<p>反码通常用来作为由原码求补码或者由补码求原码的中间过渡。反码的定义如下： <span class="math display">\[
[x]_{\text {反 }}=\left\{\begin{array}{ll}
0,\  x &amp; 2^{n}&gt;x \geqslant 0 \\
\left(2^{n+1}-1\right)+x &amp; 0 \geqslant x&gt;-2^{n}\left(\bmod 2^{n+1}-1\right)
\end{array}\right.
\]</span> 小数： <span class="math display">\[
[x]_{\text {反 }}= \begin{cases}x &amp; 1&gt;x \geqslant 0 \\ \left(2-2^{-n}\right)+x &amp; 0 \geqslant x&gt;-1 \quad\left(\bmod \left(2-2^{-n}\right)\right)\end{cases}
\]</span> 例如，<span class="math inline">\(x = -0.1010\)</span>，则 <span class="math display">\[
\begin{align*}
[x]_{\text{反}} &amp;= (2 - 2 ^{-4}) + (-0.1010)) \\
&amp;= (10 - 0.0001) -0.1010 \\
&amp;= 1.1111 - 0.1010 \\
&amp;= 1.0101 
\end{align*}
\]</span></p>
<ul>
<li>简而言之为，符号位不变，正数不变，负数取反</li>
<li>不难发现，对于<span class="math inline">\(0\)</span>而言，<span class="math inline">\([+0000]_{\text {反}} = 0,0000 ;\ [-0000]_{\text {反}} = 2^{4+1}-1 - 0000=11111 - 0000 = 1,1111\)</span>，两者并不一致。</li>
</ul>
<h4 id="小结">小结</h4>
<ol type="1">
<li>最高位为符号位，书写上用“,”或“.”将数值部分与符号位分隔开</li>
<li>对于正数，原码 = 反码 = 补码</li>
<li>对于负数，符号位为1。其数值部分原码取反得反码，反码加1得补码</li>
</ol>
<p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8E%9F%E5%8F%8D%E8%A1%A5%E5%B0%8F%E7%BB%93.png" alt="image-20220726222748948" style="zoom:80%;" / loading="lazy"></p>
<h4 id="移码表示法">移码表示法</h4>
<p>补码虽然计算机计算方便，但是人类和机器并不能直观地判断大小。所以选择加上<span class="math inline">\(2^n\)</span>，（这里的<span class="math inline">\(n\)</span>同样是不包含符号位的）。因此得到移码的定义 <span class="math display">\[
[x]_{\text {移 }}=2^{n}+x\left(2^{n}&gt;x \geqslant-2^{n}\right)
\]</span> 例如， <span class="math display">\[
\begin{aligned}
&amp;{[+0]_{\text {移 }}=2^{5}+0=1,00000} \\
&amp;{[-0]_{\text {移 }}=2^{5}-0=1,00000}
\end{aligned}
\]</span></p>
<ul>
<li>可见在移码中0的表示唯一。</li>
<li>移码只有整数形式的定义，而无小数定义。因为移码在数据表示中负责浮点数的<strong>阶码</strong>部分，其只有整数。</li>
<li>最小值为全0，最大值为全1，非常直观</li>
<li><strong>同一真值的移码和补码只有符号位不同</strong></li>
</ul>
<p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A7%BB%E7%A0%81%E6%AF%94%E8%BE%83.png" alt="image-20220726224410850" style="zoom:80%;" / loading="lazy"></p>
<h2 id="数的定点表示和浮点表示">数的定点表示和浮点表示</h2>
<p>在计算机中，小数点<strong>不用专门的器件表示，而是按约定的方式标出</strong>，共有两种方法表示小数点的存在，即<strong>定点表示</strong>和<strong>浮点表示</strong>。定点表示的数称为定点数，浮点表示的数称为浮点数。</p>
<h3 id="定点表示">定点表示</h3>
<p>所谓定点表示，即小数点固定在某一位置。其有两种形式，分别是小数点在数符（正负号）后，和小数点在数值后。</p>
<p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA.png" alt="image-20220727145024898" style="zoom:80%;" / loading="lazy"></p>
<ul>
<li>根据机器选择的小数点位置的不同，分为<strong>小数定点机</strong>和<strong>整数定点机</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th>定点机</th>
<th>小数定点机</th>
<th>整数定点机</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>原码</td>
<td><span class="math inline">\([-(1-2^{-n}),+(1-2^{-n})]\)</span></td>
<td><span class="math inline">\([-(2^n-1),+(2^n-1)]\)</span></td>
</tr>
<tr class="even">
<td>补码</td>
<td><span class="math inline">\([-1,+(1-2^{-n})]\)</span></td>
<td><span class="math inline">\([-2^n,+(2^n-1)]\)</span></td>
</tr>
<tr class="odd">
<td>反码</td>
<td><span class="math inline">\([-(1-2^{-n}),+(1-2^{-n})]\)</span></td>
<td><span class="math inline">\([-(2^n-1),+(2^n-1)]\)</span></td>
</tr>
</tbody>
</table>
<ul>
<li>不难发现，原码的范围与反码表示的范围一致，这也与上一篇的结论相符合。而补码的最小值会发生改变，也与上篇相符。</li>
</ul>
<h3 id="浮点表示">浮点表示</h3>
<p>实际上计算机中处理的数不一定是纯小数或纯整数（如圆周率），而且有些数据的数值范围相差很大，它们都不能直接用定点小数或定点整数表示，除非疯狂加长机器字长，这显然是不现实的。但其均可用浮点数表示。<strong>浮点数即小数点的位置可以浮动的数</strong>，比如： <span class="math display">\[
\begin{aligned}
352.47 &amp;=3.5247 \times 10^{2} \\
&amp;=3524.7 \times 10^{-1} \\
&amp;=0.35247 \times 10^{3}
\end{aligned}
\]</span> 其实就类似我们学过的科学计数法，其一般形式为<span class="math inline">\(N = S*r^j\)</span>，其中<span class="math inline">\(S\)</span>称为<strong>尾数</strong>，<span class="math inline">\(j\)</span>称为<strong>阶码</strong>，<span class="math inline">\(r\)</span>称为<strong>基值</strong>。</p>
<ul>
<li>尾数<span class="math inline">\(S\)</span>的绝对值小于等于1，为小数</li>
<li>阶码<span class="math inline">\(j\)</span>为整数</li>
<li>基值<span class="math inline">\(r\)</span>在计算机中一般取2的次幂</li>
</ul>
<p>当<span class="math inline">\(r=2\)</span>时，举个例子： <span class="math display">\[
\begin{aligned}
N &amp;=11.0101 \\
&amp;=0.110101 \times 2^{10} \\
&amp;=1.10101 \times 2^{1} \\
&amp;=1101.01 \times 2^{-10} \\
&amp;=0.00110101 \times 2^{100}
\end{aligned}
\]</span></p>
<ul>
<li>注意，这里的阶码同样为2进制。</li>
<li>注意，尾数的绝对值限制</li>
<li>将尾数最高位为1的数称为<strong>规格化数</strong>，此时精度最高</li>
</ul>
<h4 id="浮点数的表现形式">浮点数的表现形式</h4>
<p>在设计计算机的过程中，如果事先约定好了基值<span class="math inline">\(r\)</span>，那么存储浮点数只需要记录另外两个数值即可：</p>
<p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BD%A2%E5%BC%8F.png" alt="image-20220727152107973" style="zoom:80%;" / loading="lazy"></p>
<ul>
<li><span class="math inline">\(j_f\)</span>和<span class="math inline">\(S_f\)</span>表示正负</li>
<li><span class="math inline">\(n\)</span>，尾数位数，即反映浮点数精度</li>
<li><span class="math inline">\(m\)</span>，阶码位数，即反映浮点数范围</li>
</ul>
<h4 id="浮点数的表示范围">浮点数的表示范围</h4>
<p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E8%8C%83%E5%9B%B41.png" alt="image-20220727153145219" style="zoom:80%;" / loading="lazy"></p>
<ul>
<li>上溢：阶码大于最大阶码，则报错进行中断溢出处理</li>
<li>下溢：阶码小于最小阶码，则按照机器0处理</li>
</ul>
<h4 id="浮点数的规格化">浮点数的规格化</h4>
<p>规格化形式与<span class="math inline">\(r\)</span>的取值有直接联系，当<span class="math inline">\(r=2\)</span>时，要求首位为1，当<span class="math inline">\(r=4\)</span>时，要求首两位不全为0。</p>
<p><strong>事实上，可以总结出当<span class="math inline">\(r = 2^i\)</span>时，要求首<span class="math inline">\(i\)</span>位不全为0</strong>，推广到其他码制：</p>
<table>
<thead>
<tr class="header">
<th>码制</th>
<th>S&gt;0规格化形式</th>
<th>S&lt;0规格化形式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>真值</td>
<td>0.1XXX</td>
<td>-0.1XXX</td>
</tr>
<tr class="even">
<td>原码</td>
<td>0.1XXX</td>
<td>1.1XXX</td>
</tr>
<tr class="odd">
<td>补码</td>
<td>1.0XXX</td>
<td>1.0XXX</td>
</tr>
<tr class="even">
<td>反码</td>
<td>0.1XXX</td>
<td>1.0XXX</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>原码：无论正负首位都为1</strong></li>
<li><strong>补码：符号位与首位不同</strong>，有特例<span class="math inline">\([-\frac{1}{2}]_\text{补}=1.100\)</span>不是规格化数，<span class="math inline">\([-1]_\text{补} = 1.000\)</span>是规格化数</li>
</ul>
<p>很容易想到，通过左移右移就可以使得浮点数规格化。这被称为<strong>左规右规</strong>，但是要注意基值<span class="math inline">\(r\)</span>对于阶码的影响。</p>
<p>比如 <span class="math inline">\(r = 4\)</span>，左规2位，尾数左移2位，阶码减1。此时就不能左规3位，因为要保证阶码为整数。</p>
<p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E4%BE%8B%E5%AD%90.png" alt="image-20220727160349750" style="zoom:80%;" / loading="lazy"></p>
<ul>
<li>值得注意的是，当一个浮点数尾数为0时，不论其阶码为何值；或阶码等于或小于它所能表 示的最小数时，不管其尾数为何值，机器都把该浮点数作为零看待，并称之为“机器零”。</li>
</ul>
<h3 id="定点数和浮点数的比较">定点数和浮点数的比较</h3>
<ol type="1">
<li><p>当浮点机和定点机中，数的位数相同时，浮点数的表示范围比定点数的大得多。</p></li>
<li><p>当浮点数为规格化数时，其相对精度远比定点数高。</p></li>
<li><p>浮点数运算要分阶码部分和尾数部分，而且运算结果都要求规格化，故浮点运算步骤比定点运算步骤多，运算速度比定点运算的低，运算线路比定点运算的复杂。</p></li>
<li><p>在溢出的判断方法上，浮点数是对规格化数的阶码进行判断，而定点数是对数值本身进行判断。</p></li>
<li><p>总之，浮点数在数的表示范围、数的精度、溢出处理和程序编程方面（不取比例因子）均优于定点数。但在运算规则、运算速度及硬件成本方面又不如定点数。因此，究竟选用定点数还是浮点数，应根据具体应用综合考虑。一般来说，通用的大型计算机大多采用浮点数，或同时采用定、浮点数；小型、微型及某些专用机、控制机则大多采用定点数。当需要作浮点运算时，可通过软件实现，也可外加浮点扩展硬件（如协处理器）来实现。</p></li>
</ol>
<h3 id="ieee-754标准">IEEE 754标准</h3>
<p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/IEEE.png" alt="image-20220727161122768" style="zoom:80%;" / loading="lazy"></p>
<ul>
<li>尾数必须规格化，非0的有效位最高位为1（隐含）。所以尾数有一个最高位为隐藏位，其值恒为1</li>
<li>在实际应用中分为短实数（float）和长实数（double）以及临时实数（不采用隐藏位）</li>
</ul>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>符号位S</th>
<th>阶码</th>
<th>尾数</th>
<th>总位数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>短实数</td>
<td>1</td>
<td>8</td>
<td>23</td>
<td>32</td>
</tr>
<tr class="even">
<td>长实数</td>
<td>1</td>
<td>11</td>
<td>52</td>
<td>64</td>
</tr>
<tr class="odd">
<td>临时实数</td>
<td>1</td>
<td>15</td>
<td>64</td>
<td>80</td>
</tr>
</tbody>
</table>
<h2 id="定点运算">定点运算</h2>
<h3 id="移位运算">移位运算</h3>
<p>移位运算指<strong>小数点不动，数据左移或者右移</strong>，其中左移绝对值变大，右移绝对值减小。对计算机来说，左移一位意味着数据变为原先的两倍，右移则为二分之一。移位运算有很大的实用价值。例如，当某计算机没有乘（除） 法运算线路时，可以采用移位和加法相结合，实现乘（除）运算。</p>
<h4 id="算术移位">算术移位</h4>
<blockquote>
<p>计算机中机器数的字长往往是固定的，当机器数左移n位或右移n位时，必然会使其n位低位或n位高位出现空位。那么，对空出的空位应该添补0还是1呢？这<strong>与机器数采用有符号数还是无符号数有关</strong>。对有符号数的移位称为算术移位。</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>真值</th>
<th>码制</th>
<th>填补代码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>正数</td>
<td>原码、反码、补码</td>
<td>0</td>
</tr>
<tr class="even">
<td>负数</td>
<td>原码</td>
<td>0</td>
</tr>
<tr class="odd">
<td>负数</td>
<td>反码</td>
<td>1</td>
</tr>
<tr class="even">
<td>负数</td>
<td>补码</td>
<td>左移为0，右移为1</td>
</tr>
</tbody>
</table>
<ul>
<li>算术移位保证<strong>符号位不变</strong>，约定数值部分移位后能够存储的下</li>
<li>机器数为正时，不论是左移还是右移，添补代码均为0。</li>
<li>由于负数的<strong>原码数值部分与真值相同</strong>，故在移位时只要使符号位不变，其空位均添0即可。</li>
<li>由于负数的<strong>反码各位除符号位外与负数的原码正好相反</strong>，故移位后所添的代码应与原码相反，即全部添1。</li>
<li>分析任意负数的补码可发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。故负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添0；右移时因空位出现在高位，则添补的代码应与反码相同，即添1。</li>
<li>对于负数，三种机器数算术移位后符号位均不变。负数的原码左移时，高位丢1，结果出错；右移时，低位丢1，影响精度。负数的补码左移时，高位丢0，结果出错；右移时，低位丢1,，影响精度。负数的反码左移时，高位丢0，结果出错；右移时，低位丢0，影响精度。</li>
</ul>
<h4 id="逻辑移位">逻辑移位</h4>
<p>有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。换言之，算术移位不会移动符号位，而逻辑移位会。逻辑移位的规则是：逻辑左移时，高位移丢，低位添0；逻辑右移时，低位移丢，高位添0。</p>
<h3 id="加减运算">加减运算</h3>
<p>之所以引进补码，就是因为其可以将减法运算转换为加法运算。而现代计算机也确实采用补码做加减法运算</p>
<h4 id="补码加减法">补码加减法</h4>
<p>整数加法： <span class="math inline">\([A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}\left(\bmod 2^{n+1}\right)\)</span></p>
<p>小数加法： <span class="math inline">\([A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}(\bmod 2)\)</span></p>
<p>整数减法： <span class="math inline">\([A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}\left(\bmod 2^{n+1}\right)\)</span></p>
<p>小数减法： <span class="math inline">\([A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}(\bmod 2)\)</span></p>
<ul>
<li>注意<strong>符号位需要参与计算</strong>，丢弃符号位的进位</li>
</ul>
<h4 id="溢出判断">溢出判断</h4>
<ol type="1">
<li><p>一位符号位判断：参加操作的两个数（减法时即为被减数和“求补” 以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出。换言之，数值部分最高位的进位<span class="math inline">\(\oplus\)</span>符号位的进位 = 1 即为溢出。</p></li>
<li><p>两位符号位判溢出：首先使用变形补码，其公式如下。简而言之，对于正数其变形补码（符号位）为<span class="math inline">\(00\)</span>，对于负数其变形补码（符号位）为<span class="math inline">\(11\)</span>。数值部分可以用原本的取反加一计算。 <span class="math display">\[
[x]_\text{补}= \begin{cases}x &amp; 1&gt;x \geq 0 \\ 4+x &amp; 0&gt;x \geq-1(\bmod 4)\end{cases}
\]</span></p></li>
</ol>
<p><span class="math display">\[
[x]_{\text {补 }}= \begin{cases}0,\ x &amp; 2^{n}&gt;x \geqslant 0 \\ 2^{n+2}+x &amp; 0&gt;x \geqslant-2^{n} \quad\left(\bmod 2^{n+2}\right)\end{cases}
\]</span></p>
<ul>
<li>在用变形补码作加法时，2位符号位要连同数值部分一起参加运算，而且<strong>高位符号位产生的进位自动丢失</strong>，便可得正 确结果。变形补码判断溢出的原则是：<strong>当2位符号位不同时，表示溢出</strong>，否则，无溢出。不论是否发生溢出，高位符号位永远代表其结果真正的符号。</li>
</ul>
<h3 id="乘法运算">乘法运算</h3>
<p>先来看一个乘法的改进算法，其计算<span class="math inline">\(0.1101 * 0.1011\)</span>的值，具体过程<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1t4411e7LH?p=85">哈工大计组p85</a>。</p>
<p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B9%98%E6%B3%95%E6%94%B9%E8%BF%9B.png" alt="image-20220730234454703" style="zoom:80%;" / loading="lazy"></p>
<p>再通过异或电路判断正负，结果为<span class="math inline">\(0.10001111\)</span></p>
<p>通过乘法运算的改进算法可归纳如下：</p>
<ol type="1">
<li><strong>符号位单独判断。</strong></li>
<li><strong>乘法运算可用逻辑移位和加法来实现</strong>，比如两个4位数相乘，总共需要进行4次加法运算和4次<strong>逻辑移位</strong>。</li>
<li>由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积；同时，乘数也右移一位，<strong>空出高位存放部分积的低位。</strong></li>
<li>每次做加法时，被乘数仅仅与原部分积的高位（被乘数的位数）相加，<strong>其低位被移至乘数所空出的高位位置</strong>。</li>
</ol>
<p>计算机很容易实现这种运算规则。用一个<strong>X寄存器</strong>存放被乘数，一个<strong>ACC寄存器</strong>存放乘积的高位，另一个<strong>MQ寄存器</strong>存放乘数及乘积的低位，再配上加法器及其他相应电路，就可组成乘法器。又因加法只在部分积的高位进行，故不但节省了器材，而且还缩短了运算时间。</p>
<blockquote>
<ul>
<li><p>ACC：累加器，用于存放操作数，或运算结果。</p></li>
<li><p>MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。</p></li>
<li><p>X：通用的操作数寄存器，用于存放操作数</p></li>
<li><p>ALU：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</p></li>
</ul>
</blockquote>
<h4 id="原码一位乘法">原码一位乘法</h4>
<ol type="1">
<li><p>符号位用异或单独判断</p></li>
<li><p>数值部分按照绝对值相乘（先加再<strong>逻辑右移</strong>）</p></li>
<li><p>每次加法根据<strong>MQ寄存器</strong>（存放乘数及乘积低位）的末位确定：</p>
<ul>
<li><p>1：<span class="math inline">\(ACC+[\abs {x}]_\text{原}\)</span></p></li>
<li><p>0：$ACC + 0 $</p></li>
</ul></li>
<li><p>用右移的次数（等于乘数的位数，或者机器字长）判断是否结束</p></li>
</ol>
<h4 id="补码一位乘法">补码一位乘法</h4>
<ol type="1">
<li>符号位参与运算</li>
<li>先加再<strong>补码的算术右移</strong>，最后再加</li>
<li>辅助位：指<strong>MQ寄存器</strong>扩展的一位末位，其初始值为0。每次右移时其值被更新为末位的值</li>
<li><strong>ACC寄存器</strong>和<strong>X寄存器</strong>存放的乘积高位和被乘数，都是用<strong>双符号位记录</strong></li>
<li>每次加法根据<strong>MQ寄存器</strong>的末位和<strong>辅助位</strong>确定，使用辅助位 - MQ最低位的值判断：
<ul>
<li>1：<span class="math inline">\(ACC+[x]_\text{补}\rightarrow ACC\)</span></li>
<li>0：<span class="math inline">\(ACC+0\rightarrow ACC\)</span></li>
<li>-1：<span class="math inline">\(ACC+[-x]_\text{补}\rightarrow ACC\)</span></li>
</ul></li>
</ol>
<h3 id="除法运算">除法运算</h3>
<p>回忆一下手算除法，不难总结出二进制手算除法的规律：使用数值部分进行计算，根据除数和余数的大小确定一位商，进行一次减法操作并得到余数。再余数后补零，重复计算直到满足精度或者整除。那么如何在计算机中实现上述过程呢？</p>
<p>为了方便说明，定义被除数<span class="math inline">\(x\)</span>，除数<span class="math inline">\(y\)</span>，当前的余数<span class="math inline">\(R\)</span></p>
<h4 id="原码恢复余数法">原码恢复余数法</h4>
<ol type="1">
<li>符号位用异或单独判断</li>
<li>数值部分按照<strong>绝对值</strong>进行计算，还需要计算除数的绝对值补码和除数相反数的绝对值补码。即<span class="math inline">\([\abs{y}]_\text{补}\)</span>和<span class="math inline">\([\abs{-y}]_\text{补}\)</span></li>
<li>使用<strong>ACC</strong>存储被除数（当前的余数<span class="math inline">\(R\)</span>），使用<strong>X</strong>存储除数<span class="math inline">\(y\)</span>，使用<strong>MQ</strong>存储商</li>
<li>这个方法的精髓就在于：计算机不会直接比较<span class="math inline">\(R\)</span>和<span class="math inline">\(y\)</span>的大小，而是直接<strong>商1</strong>（在MQ的末位写入）。然后计算$ R - y = R + []_ ACC<span class="math inline">\(，将结果写入**ACC**后，通过电路判断符号位是否为0（正数）。如果为1，则进行\)</span> R + y ACC$恢复余数，再改成<strong>商0</strong>。</li>
<li>对<strong>ACC</strong>和<strong>MQ</strong>进行<strong>逻辑左移</strong>，<strong>MQ</strong>的最高位填充到<span class="math inline">\(ACC\)</span>的末位，末位补零。<strong>最后一次上商后无需左移</strong></li>
<li>重复4-5步，直到商的位数达到机器字长长度。假设得到余数为00111，则真值为<span class="math inline">\(0.0111 * 2^{-n} = 0.0111 * 2^{-4}\)</span>。商为<span class="math inline">\(01101\)</span>，则商为<span class="math inline">\(0.1101\)</span>。再用符号位异或确定商的符号位（余数一定是正数）。</li>
</ol>
<p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9B%9E%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95.png" alt="image-20220803184738585" style="zoom:80%;" / loading="lazy"></p>
<h4 id="原码加减交替法">原码加减交替法</h4>
<p>对恢复余数法进行总结可以发现：</p>
<ul>
<li>上商1后：<span class="math inline">\(2* R -y\)</span></li>
<li>上商0后：<span class="math inline">\(2*(R+y) -y = 2*R +y\)</span></li>
</ul>
<p>通过这样的化简，我们可以精简恢复余数法上商0的操作，即<strong>省略恢复余数的步骤</strong>。故又称不恢复余数法。同样也是移位n次，上商n+1次。</p>
<p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95.png" alt="image-20220803191510289" style="zoom:80%;" / loading="lazy"></p>
<h4 id="补码除法">补码除法</h4>
<ol type="1">
<li>使用双符号位表示正负，符号位参与运算</li>
<li>被除数<span class="math inline">\(x\)</span>和除数<span class="math inline">\(y\)</span>同号，则<span class="math inline">\(R= x -y = x+[-y]_\text{补}\)</span>，否则<span class="math inline">\(R= x+y =x+ [y]_\text{补}\)</span></li>
<li>若余数<span class="math inline">\(R\)</span>与除数<span class="math inline">\(y\)</span>同好，则商1，余数左移一位减去除数<span class="math inline">\(2*R - y = 2*R +[-y]_\text{补}\)</span>，否则商0，余数左移一位加上除数<span class="math inline">\(2*R + y = 2*R +[y]_\text{补}\)</span>。重复n次</li>
<li>如果对商的精度没有特殊要求，一般可采用“末位恒置1”法，这种方法操作简单，易于实现，而且最大误差仅为<span class="math inline">\(2^{-n}\)</span></li>
</ol>
<h2 id="浮点四则运算">浮点四则运算</h2>
<h3 id="浮点加减运算">浮点加减运算</h3>
<blockquote>
<p>由于浮点数尾数的小数点均固定在第一数值位前，所以尾数的加减运算规则与定点数的完全相同。但由于其阶码的大小又直接反映尾数有效值小数点的实际位置，因此当两浮点数阶码不等时，因两尾数小数点的实际位置不一样，尾数部分无法直接进行加减运算。为此，浮点数加减运算必须按以下几步进行。</p>
</blockquote>
<ol type="1">
<li>对阶：使两数的小数点对齐</li>
<li>尾数求和：将对阶后的两尾数按定点加减运算规则求和（差）。</li>
<li>规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。</li>
<li>舍入，为提高精度，要考虑尾数右移时丢失的数值位。</li>
<li>溢出判断，即判断结果是否溢出。</li>
</ol>
<p>例子：<span class="math inline">\(x= 0.1101*2^{01} \quad y=(-0.1010)*2^{11}\)</span>，计算 <span class="math inline">\(x+y\)</span></p>
<h4 id="对阶">对阶</h4>
<p>对阶的目的是使两操作数的小数点位置对齐，即使两数的阶码相等。为此，首先要求出<strong>阶差</strong>，再按<strong>小阶向大阶看齐</strong>的原则，使阶小的尾数向右移位，每右移一位，阶码加1，直到两数的阶码相等为止。<strong>右移的次数正好等于阶差</strong>。尾数右移时可能会发生数码丢失，影响精度。（如果选择大阶向小阶看齐，则需要让尾数变大左移，这可能导致最高位丢失造成数据错误）</p>
<p>首先将数据用浮点数补码表示： <span class="math display">\[
[x]_\text{补} = 00,01;\ 00.1101\\
[y]_\text{补} = 00,11;\ 11.0110
\]</span></p>
<ul>
<li>四位阶码（两位阶符），六位尾数（两位尾符）</li>
</ul>
<p>求阶差： <span class="math display">\[
[\Delta j]_\text{补} =[j_x]_\text{补} - [j_y]_\text{补} = 00,01 + 11,01 = 11,10&lt;0
\]</span></p>
<ul>
<li>阶差为<span class="math inline">\(11,10 = -2\)</span>，所以<span class="math inline">\(j_x+2\quad S_x \rightarrow 2\)</span></li>
</ul>
<p>对阶：<span class="math inline">\([x]_\text{补&#39;} = 00,11;00.0011 \quad [y]_\text{补} = 00,11;\ 11.0110\)</span></p>
<h4 id="尾数求和">尾数求和</h4>
<p>将对阶后的两个尾数按定点加（减）运算规则进行运算 <span class="math display">\[
[S_x +S_y]_\text{补} =[S_x]_\text{补&#39;}+[S_y]_\text{补} = 00.0011 + 11.0110 =11.1001
\]</span></p>
<ul>
<li><span class="math inline">\([x+y]_\text{补} = 00,11;11.1001\)</span></li>
</ul>
<h4 id="规格化">规格化</h4>
<p>当前基值 <span class="math inline">\(r\)</span> 为2，那么要求前1位即首位不为0。通过<strong>左规和右规</strong>进行规格化，直到尾符和首位不同为止（机器数为补码，且考虑特例<span class="math inline">\(-1 \ and\  -\frac{1}{2}\)</span>）</p>
<p>左规：尾数左移，阶码减一 <span class="math display">\[
[x+y]_\text{补} = 00,10;11.0011
\]</span> 右规：尾数右移，阶码加一。只有当尾数的符号位溢出，俩符号位数值不等，即形如<span class="math inline">\(10.XXX \quad 01.XXX\)</span>时才进行右规</p>
<h4 id="舍入">舍入</h4>
<p>在<strong>对阶和右规</strong>的过程中，可能会将尾数的低位丢失，引起误差，影响精度。为此可用舍入法来提高尾数的精度。常用的舍入方法有以下两种。</p>
<ol type="1">
<li>“0舍1人”法：类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1。这样做可能使尾数又溢出，此时需再做一次右规。</li>
<li>“恒置1”法：尾数右移时，不论丢掉的最高数值位是“1”或“0”，都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。</li>
</ol>
</div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Anduin9527</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://lapras.xyz/2022/08/08/9b046e01.html" title="计算机组成原理笔记（六）">http://lapras.xyz/2022/08/08/9b046e01.html</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/08/20/4904199e.html" rel="prev" title="计算机组成原理笔记（七）"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">计算机组成原理笔记（七）</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/07/26/fe0a25d8.html" rel="next" title="计算机组成原理笔记（五）"><span class="post-nav-text">计算机组成原理笔记（五）</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>如果您有任何关于博客内容的相关讨论，欢迎与我交流。</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">闽ICP备2021012704号</a></div><div class="copyright"><span>&copy; 2020 – 2022 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Anduin9527</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.2.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.6</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#66d6ff" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" target="_blank" rel="noopener" href="https://www.google.com/search?q=site:lapras.xyz" title="Search"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18","5-12","12-13"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script></body></html>