<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#66d6ff"><meta name="author" content="Anduin9527"><meta name="copyright" content="Anduin9527"><meta name="generator" content="Hexo 6.2.0"><meta name="theme" content="hexo-theme-yun"><title>汇编语言程序设计（三） | Anduin9527的乖离器</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js"></script><script type="module">import { renderKatex } from '/js/utils.js'
document.addEventListener("DOMContentLoaded", () => {
  renderKatex({
    ...{},
    ...true?.options,
  });
});</script><link rel="icon" type="image/svg+xml" href="/images/favicon.svg"><link rel="mask-icon" href="/images/favicon.svg" color="#66d6ff"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"lapras.xyz","root":"/","title":["拉普","拉斯~","的","乖离器"],"version":"1.10.6","mode":"time","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","fireworks":{"colors":["#00D1CE","#66D6FF","#919191"]},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="Anduin9527的乖离器" type="application/atom+xml"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap"><script src="/h" async></script><script src="/t" async></script><script src="/t" async></script><script src="/p" async></script><script src="/s" async></script><script src="/:" async></script><script src="/" async></script><script src="/" async></script><script src="/c" async></script><script src="/d" async></script><script src="/n" async></script><script src="/." async></script><script src="/j" async></script><script src="/s" async></script><script src="/d" async></script><script src="/e" async></script><script src="/l" async></script><script src="/i" async></script><script src="/v" async></script><script src="/r" async></script><script src="/." async></script><script src="/n" async></script><script src="/e" async></script><script src="/t" async></script><script src="/" async></script><script src="/n" async></script><script src="/p" async></script><script src="/m" async></script><script src="/" async></script><script src="/i" async></script><script src="/o" async></script><script src="/n" async></script><script src="/i" async></script><script src="/c" async></script><script src="/o" async></script><script src="/n" async></script><script src="/s" async></script><script src="/" async></script><script src="/d" async></script><script src="/i" async></script><script src="/s" async></script><script src="/t" async></script><script src="/" async></script><script src="/i" async></script><script src="/o" async></script><script src="/n" async></script><script src="/i" async></script><script src="/c" async></script><script src="/o" async></script><script src="/n" async></script><script src="/s" async></script><script src="/." async></script><script src="/j" async></script><script src="/s" async></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-NSLVQ2H5JH"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-NSLVQ2H5JH');
}</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><meta name="description" content="前言  完结，准备爽放两个实践周">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言程序设计（三）">
<meta property="og:url" content="http://lapras.xyz/2022/10/23/80b4c1fd.html">
<meta property="og:site_name" content="Anduin9527的乖离器">
<meta property="og:description" content="前言  完结，准备爽放两个实践周">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220927102559.png">
<meta property="article:published_time" content="2022-10-23T12:08:32.390Z">
<meta property="article:modified_time" content="2022-10-23T12:09:41.746Z">
<meta property="article:author" content="Anduin9527">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="汇编">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220927102559.png"><script type="module">import { getScript } from '/js/utils.js'
getScript("https://fastly.jsdelivr.net/npm/mermaid/dist/mermaid.min.js", () => {
  const mermaidOptions = {"startOnload":true}
  mermaid.initialize(mermaidOptions);
}, window.mermaid);
</script><style>.mermaid{background: transparent;}</style><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Anduin9527"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Anduin9527"><span class="site-author-status" title="建模建模呜呜呜！">😭</span></a><div class="site-author-name"><a href="/about/">Anduin9527</a></div><span class="site-name">Anduin9527的乖离器</span><sub class="site-subtitle">正在进修摸鱼学导论</sub><div class="site-description">南邮摸鱼ing</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">44</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">30</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="tencent://message/?uin=2676057183&amp;Site=&amp;Menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Anduin9527" title="GitHub" target="_blank" style="color:#181717"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:2676057183@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=579015212" title="网易云音乐" target="_blank" style="color:#C10D0C"><span class="icon iconify" data-icon="ri:netease-cloud-music-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/chu-liu-16-64" title="知乎" target="_blank" style="color:#0084FF"><span class="icon iconify" data-icon="ri:zhihu-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/21994551" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><span class="icon iconify" data-icon="ri:rss-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a><a class="links-item hty-icon-button" href="/girls/" title="我永远喜欢oo" style="color:hotpink"><span class="icon iconify" data-icon="ri:women-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5"><span class="toc-text">宏汇编语言基本语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">源程序的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-text">伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A0%BC%E5%BC%8F"><span class="toc-text">汇编源程序的编程格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8"><span class="toc-text">系统功能调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dos-%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8"><span class="toc-text">DOS 功能调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bios-%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8"><span class="toc-text">BIOS 功能调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%AE%8F%E7%A8%8B%E5%BA%8F"><span class="toc-text">子程序与宏程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%B0%83%E7%94%A8"><span class="toc-text">子程序及其调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%85%B6%E8%B0%83%E7%94%A8"><span class="toc-text">宏指令及其调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%BE%E4%BE%8B"><span class="toc-text">程序设计举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">顺序程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6"><span class="toc-text">读取字符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">分支程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0"><span class="toc-text">分段函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97"><span class="toc-text">打印二进制数字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">循环程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E7%B4%AF%E5%8A%A0%E5%92%8C"><span class="toc-text">求累加和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E5%BF%8C%E7%9A%84%E5%8F%8C%E9%87%8D%E5%BE%AA%E7%8E%AF"><span class="toc-text">禁忌的双重循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E6%9C%80%E5%A4%A7%E5%AD%97%E7%AC%A6"><span class="toc-text">寻找最大字符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">数制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%98%BE%E7%A4%BA"><span class="toc-text">二进制数显示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E6%98%BE%E7%A4%BA"><span class="toc-text">二进制数转十六进制数显示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E6%98%BE%E7%A4%BA"><span class="toc-text">二进制数转十进制数显示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="toc-text">实验内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">统计字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%A8%8B%E5%BA%8F"><span class="toc-text">编写登录验证程序</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#66d6ff;"><link itemprop="mainEntityOfPage" href="http://lapras.xyz/2022/10/23/80b4c1fd.html"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Anduin9527"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Anduin9527的乖离器"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">汇编语言程序设计（三）</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="Created: 2022-10-23 20:08:32" itemprop="dateCreated datePublished" datetime="2022-10-23T20:08:32+08:00">2022-10-23</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><span class="icon iconify" data-icon="ri:file-word-line"></span></span> <span title="Word count in article">6.6k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><span class="icon iconify" data-icon="ri:timer-line"></span></span> <span title="Reading time">27m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" style="--text-color:##beedff" itemprop="url" rel="index"><span itemprop="text">汇编语言程序设计</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E7%AC%94%E8%AE%B0/" style="--text-color:dimgray"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">笔记</span></a><a class="tag-item" href="/tags/%E6%B1%87%E7%BC%96/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">汇编</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="前言">前言</h2>
<p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220927102559.png" alt="image-20220927102552370" style="zoom:67%;" / loading="lazy"></p>
<p>完结，准备爽放两个实践周</p>
<span id="more"></span>
<h2 id="宏汇编语言基本语句">宏汇编语言基本语句</h2>
<h3 id="源程序的结构">源程序的结构</h3>
<p>一个完整的源程序在结构上必须做到:</p>
<ol type="1">
<li>用 <strong>方式选择伪指令</strong> 说明执行该程序的 <strong>微处理器类型</strong></li>
<li>用 <strong>段定义语句</strong> 定义每一个 <strong>逻辑段</strong></li>
<li>用 <strong>ASSUME 语句</strong> 说明 <strong>段约定</strong></li>
<li>用 <strong>过程定义语句</strong> 定义每一个 <strong>子程序</strong></li>
<li>程序在完成预定功能之后，应能安全 <strong>返回 DOS</strong></li>
<li>用 <strong>汇编结束语句</strong> 说明源程序结束</li>
</ol>
<h3 id="伪指令">伪指令</h3>
<ol type="1">
<li><p>处理器选择伪指令</p>
<p>格式：<code>.586</code></p>
<p>功能：通知汇编程序，汇编源程序汇编链接后生成对应哪一种 CPU 类型的机器指令</p>
<p>注意：方式选择伪指令放在程序的头部，做为源程序的第一条语句。不设置方式选择伪指令与设置 <code>.8086</code> 是等价的</p></li>
<li><p>段定义伪指令</p>
<p>格式：</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">段名 SEGMENT 定位参数 链接参数 &#39;分类名&#39; 段长度
	...段体...
段名 ENDS</code></pre>
<p>功能：是 <strong>逻辑段</strong> 的定界语句，源程序中每一个逻辑段都必须用段定义语句定界</p>
<ol type="1">
<li><strong>定位参数</strong>：通知链接程序，告诉它逻辑段的目标代码在存储器中如何存储
<ol type="1">
<li><code>BYTE</code> 字节地址：表明该逻辑段的目标代码可以从任意地址开始依次存放</li>
<li><code>WORD</code> 字地址：表示该逻辑段的目标代码，从偶地址开始依次存放</li>
<li><code>PARA</code>（缺省值）节地址：表示该逻辑段的目标代码，从能被 16 整除（末位为 0）的地址开始存放</li>
<li><code>PAGE</code> 页地址：表示该逻辑段的目标代码，从一个能被 256 整除的地址开始依次存放</li>
</ol></li>
<li><strong>链接参数</strong>：通知链接程序对逻辑段的处理方法</li>
<li><strong>'分类名'</strong>：通知链接程序，把 <strong>分类名</strong> 相同的同名逻辑段组合起来，放在邻近的内存区</li>
<li><strong>段长度</strong>：说明逻辑段的 <strong>寻址方式</strong> 的位数。若是 <code>USE16</code> ，则表示该段体积最大 64K ，单元偏移地址为 16 位，采用 16 位寻址。若为 <code>USE32</code>，则表示该段体积最大 4G ，单元偏移地址为 32 位，采用 32 位寻址</li>
</ol>
<p>注意：</p>
<ol type="1">
<li>一个逻辑段从 <code>SEGMENT</code> 语句开始，到 <code>ENDS</code> 语句结束</li>
<li>通常用 <code>DATA</code> 做为数据段的段名，用 <code>STACK</code> 做为堆栈段的段名，<code>CODE</code> 为代码段的段名</li>
<li>在 <strong>实模式环境</strong> 下，各逻辑段应采用 16 位寻址，所以段长度选用 <code>USE16</code></li>
<li>只有在模块化程序中，才有必要考虑链接参数的选择</li>
<li>注意分类名记得加 <strong>单引号</strong></li>
<li>在单一模块程序中，<strong>定位参数</strong>，<strong>链接参数</strong>，<strong>分类名</strong> 均选用 “缺省” 表示即可</li>
<li>在单一模块程序中，如果有 <strong>堆栈段</strong>，则堆栈段选用 <strong>STACK</strong> 为链接参数（因为只有 STACK 属性才表示该段是堆栈段），<strong>'STACK'</strong> 为分类名，由于选用 STACK 为链接参数，汇编后 DOS 将自动给 <code>SS:SP</code> 赋值</li>
</ol></li>
<li><p>段约定伪指令 <code>ASSUME</code></p>
<p>格式：<code>ASSUME 段寄存器:段名,...,段寄存器:段名</code></p>
<p>功能：<code>ASSUME</code> 语句通知汇编程序，寻址逻辑段使用哪一个段寄存器</p>
<p>注意：</p>
<ol type="1">
<li><code>ASSUME</code> 语句通常是放在 <strong>代码段</strong> 的第一条语句</li>
<li><code>ASSUME</code> 语句，仅仅是约定了对某个逻辑段进行寻址操作时使用哪一个段寄存器，而段寄存器的初值还必须在程序中用 <code>MOV</code> 指令设置</li>
<li><code>CS:IP</code> 由 DOS 自动赋初值</li>
<li><code>SS:SP</code> 初值由 DOS 自动赋给，或由程序员赋给</li>
</ol></li>
<li><p>过程（子程序）定义伪指令 <code>PROC</code></p>
<p>格式：</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">过程名	PROC	属性
	...过程实体...
		RET
过程名 	ENDP</code></pre>
<p>功能：定义过程（子程序）</p>
<ol type="1">
<li>属性：两种描述：<code>NEAR</code> 代表段内操作，<code>FAR</code> 代表段间操作</li>
</ol>
<p>注意：</p>
<ol type="1">
<li>一个子程序从 <code>PROC</code> 语句开始，到 <code>ENDP</code> 语句结束</li>
<li>汇编后过程名就是子程序第一条指令的入口地址</li>
</ol></li>
<li><p>返回 <code>DOS</code> 指令</p>
<p>格式：</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">MOV AH, 4CH
INT 21H</code></pre>
<p>功能：程序在完成预定任务之后，返回 DOS</p>
<p>注意：事实上是用了下文要介绍的 <strong>系统功能调用</strong></p></li>
<li><p>汇编结束伪指令 <code>END</code></p>
<p>格式：<code>END BEGIN</code></p>
<p>功能：通知汇编程序源程序到此结束</p>
<p>注意：DOS 装载程序的可执行文件时，自动把标号 <code>BEGIN</code> 所在段的段基址赋给 <code>CS</code>，把 <code>BEGIN</code> 所在单元的偏移量赋给 <code>IP</code>。从而 CPU 自动从 <code>BEGIN</code> 开始的那条指令依次执行程序</p></li>
</ol>
<h3 id="汇编源程序的编程格式">汇编源程序的编程格式</h3>
<p>在汇编语言中，针对于 Microsoft DOS / Windows 操作系统，为了生成 EXE 和 COM 两种不同的文件，在编写源程序时必须依据规定的格式进行，也称为编程格式。分别对应 EXE 文件的编程格式和 COM 文件的编程格式。</p>
<p>  1. EXE 文件的编程格式：只能生成扩展为 EXE 的可执行文件。允许源程序使用多个逻辑段 (包括数据段、堆栈段、代码段及其它逻辑段) ; 在实模式下，每个逻辑段的目标块不超过 64K ；适合编写大型程序。最终能生成 .EXE 文件   1. COM 文件的编程格式：可以生成扩展为 COM 的可执行文件。源程序只能有一个逻辑段(即代码段)，不允许设置堆栈段。且代码段目标块小于 64K，适合于编写中小型程序</p>
<h2 id="系统功能调用">系统功能调用</h2>
<p>DOS 的 4 个组成部分中 <code>IBMBIO.COM</code> 和 <code>IBMDOS.COM</code> 是 DOS 系统的核心模块，前者为基本 I/O 设备处理程序，与 BIOS 一起完成数据输入和数据输出的基本操作；后者是磁盘文件管理程序。这两个模块均有若干子功能可以被用户程序调用，在汇编里面要使用一些已经写好的子程序的话，我们就可以使用功能调用。有两种方式：</p>
<ol type="1">
<li>通过操作系统内核里面提供的一些子程序。(也叫做 DOS 功能调用)</li>
<li>绕开操作系统，直接调用主板芯片上固化的子程序。(叫做 BIOS 功能调用)</li>
</ol>
<h3 id="dos-功能调用">DOS 功能调用</h3>
<p>要条用系统功能的基本格式</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">MOV  AH,功能号
设置入口参数
INT  21H
分析出口参数</code></pre>
<ol type="1">
<li><p><code>01H</code> 键入字符</p>
<p>格式：</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">MOV AH, 1H
INT 21H</code></pre>
<p>功能：等待键入一个字符，有回显，并用 <code>Ctrl + C</code> 结束输入</p>
<p>注意：</p>
<ol type="1">
<li>入口参数：无</li>
<li>出口参数：<code>AL = 按键的 ASCII 码</code></li>
<li>若 AL = 0，表明按键是功能键、光标键，需再次调用此功能，才能返回按键的扩展码</li>
</ol></li>
<li><p><code>02H</code> 显示字符</p>
<p>格式：</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">;在文本屏幕上显示字符 A
MOV DL, &#39;A&#39;
MOV AH, 2H
INT 21H</code></pre>
<p>功能：显示一个字符。本功能在屏幕的当前位置显示一个字符，光标右移一格，如果是在一行末尾显示字符，则光标返回下一行的开始格。如果是在屏幕的右下角显示字符，则光标在返回时屏幕要上滚一行</p>
<p>注意：</p>
<ol type="1">
<li>入口参数：<code>DL = 待显示字符的ASCII码</code></li>
<li>出口参数：无</li>
<li>该功能要破坏 AL 寄存器的内容</li>
<li>注意：将内存中的四位二进制数打印出来时，要先将其转换为对应的<code>ASCII</code>码
<ol type="1">
<li>数字：<code>+30H</code></li>
<li>字母（A~F）：<code>+37H</code>，因为A是<code>41H</code></li>
</ol></li>
</ol></li>
<li><p><code>09H</code> 显示字符串</p>
<p>格式：</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">;在屏幕上显示‘HELLO WORLD!&#39;
.486
DATA SEGMENT USE16 			; 定义数据段
MESG DB &#39;HELLO WORLD!&#39;, &#39;$&#39;
DATA ENDS

CODE SEGMENT USE16 			; 定义代码段
ASSUME CS:CODE, DS:DATA
	BEG: MOV AX, DATA
		MOV DS, AX
		LAST: MOV AH, 9
		MOV DX, OFFSET MESG	; 把 MESG 的首地址给 DX 寄存器
		INT 21H
		
		MOV AH, 4CH
		INT 21H 			; 返回DOS
		
	CODE ENDS
END BEG
</code></pre>
<p>功能：从屏幕当前位置开始，显示字符串，遇到结束标志 <code>$</code> 时停止</p>
<p>注意：</p>
<ol type="1">
<li>入口参数：<code>DS:DX</code> 指向字符串首地址，字符串必须以 <code>$</code>(即 ASCII 码 24H ) 为结束标志</li>
<li>会破坏 <code>AL</code> 寄存器的内容</li>
<li>一般搭配末位为<code>0DH,0AH,'$'</code>的字符串使用，达到回车换行的目的</li>
</ol></li>
<li><p><code>0AH</code> 键入字符串</p>
<p>格式：</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">.486

DATA SEGMENT USE16 				; 定义数据段
	 	 BUF DB 100
		 DB ?
		 DB 10 DUP(?)
DATA ENDS

CODE SEGMENT USE16 				; 定义代码段
ASSUME CS:CODE, DS:DATA
	BEG: MOV AX, DATA
		MOV DS, AX
		
		MOV DX, OFFSET BUF	
		MOV AH, 0AH				; 功能号 0AH 
		INT 21H
		MOV DX, OFFSET BUF+2	; 从&quot;BUF+2&quot;的位置开始键入
		
		MOV BX, DX				; 键入字符的个数
		ADD BL, BUF+1
		
		MOV BYTE PTR [BX], &#39;$&#39;	; 间接寻址
		MOV AH, 09H				; 功能号09H[显示字符串]
		INT 21H
		
		MOV AH, 4CH
		INT 21H 				; 返回DOS
		
	CODE ENDS
END BEG</code></pre>
<p>功能：等待键入一串字符，送用户程序数据缓冲区</p>
<p>注意：</p>
<ol type="1">
<li>入口参数：<code>DS:DX</code> 指向放键入字符的缓冲区</li>
<li>出口参数：存放于缓冲区的字符串，以回车键结尾</li>
<li>缓冲区定义的第二个字节（从1开始数）由系统设置为输入的字符串的长度</li>
<li>如果输入的字节数少于定义的字节数，缓冲区其余字节将自动补零</li>
<li>输入的字节数大于定义的字节数，后来输入的字符被自动被丢弃且响铃警告</li>
</ol></li>
</ol>
<h3 id="bios-功能调用">BIOS 功能调用</h3>
<pre class="language-asm" data-language="asm"><code class="language-asm">MOV AH, 功能号
设置入口参数
INT XXH (XXH为 BIOS 功能调用类型号，本课只涉及键盘输入功能调用，所以间断号 &#x3D; 16H,屏幕显示间断号为10H) 
分析出口参数</code></pre>
<ol type="1">
<li><p><code>00H</code> 读取键入字符</p>
<p>格式：</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">MOV AH, 00H
INT 16H
MOV CL, AL 		; 获得键盘输入字符的 ASCII 码, 并放入 CL 寄存器</code></pre>
<p>功能：读取键入的一个字符，无回显，响应 <code>Ctrl+C</code>，无键入则等待</p>
<p>注意：</p>
<ol type="1">
<li>入口参数：无</li>
<li>出口参数：<code>AL</code> = 键入字符的 ASCII 码。若 <code>AL</code> = 0，则 <code>AH</code> = 输入键的扩展码</li>
</ol></li>
<li><p><code>01H</code> 查询键盘缓冲区</p>
<p>格式：</p>
<pre class="language-none"><code class="language-none">MOV AH, 01H
INT 16H
MOV CL, AL 		; 获得键盘输入字符的 ASCII 码, 并放入 CL 寄存器</code></pre>
<p>注意：</p>
<ol type="1">
<li>入口参数：无</li>
<li>出口参数：
<ul>
<li><code>Z=0</code>，表示有输入，键代码仍留在键盘缓冲区中，此时 <code>AL</code> = 输入字符的 ASCII 码，<code>AH</code> = 输入字符的扩展码。</li>
<li><code>Z=1</code>，表示无输入</li>
</ul></li>
</ol></li>
</ol>
<h2 id="子程序与宏程序">子程序与宏程序</h2>
<h3 id="子程序及其调用">子程序及其调用</h3>
<p>子程序是相对独立的程序，当程序中要多次完成某一操作时，为了简化整体程序，增强程序可读性，常常把“完成某一操作”设计成一个子程序以供调用</p>
<ol type="1">
<li>子程序用<code>PROC/ENDP</code>分界</li>
<li>子程序分为：段内子程序、段间子程序、无参数子程序、有参数子程序</li>
<li>要明确地定义出这个子程序的入口参数和出口参数，使调用者能方便地使用子程序</li>
<li>在子程序中合理地保存主程序和子程序都用到的寄存器和存储单元，以使主程序能正确地运行</li>
<li>对子程序传参使用<code>M/R/Stack</code></li>
</ol>
<h3 id="宏指令及其调用">宏指令及其调用</h3>
<p>与C语言的宏命令差不多，都是在编译的时候对代码进行替换。格式如下</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">MacroName		MACRO		哑元表
						LOCAL Grade1,Grade2
						MacroBody
						ENDM</code></pre>
<ol type="1">
<li>含有哑元表表示该宏指令带参，用一串逗号间隔形式的参数表（无值符号，调用时用<code>R/M/N</code>替换，M无需PTR运算符）</li>
<li><code>MACRO/ENDM</code>是宏体的定界语句</li>
<li>在代码段中放置一条宏指令就是宏调用</li>
<li>使用<code>LOCAL</code>伪指令解决宏指令中标号重复定义的错误，<code>LOCAL 标号名表</code></li>
</ol>
<p>以下是一个输入输出字符加了换行宏指令的小程序</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">.486
DATA SEGMENT USE16
  BUF  DB ?
DATA ENDS

CRLF MACRO
       MOV AH,2
       MOV DL,0DH
       INT 21H
       MOV DL,0AH
       INT 21H
ENDM

CODE SEGMENT USE16
       ASSUME CS:CODE, DS:DATA
  BEG: 
       MOV    AX,DATA
       MOV    DS,AX             ;赋予段基址
  
       MOV    AH,1
       INT    21H               ;调用DOS键入功能

       MOV    BUF,AL            ;传递给BUF
       MOV    DL,BUF            ;传递给DL

       MOV    AH,2
       INT    21H               ;调用DOS输出功能
       CRLF

       MOV    AH,4CH
       INT    21H               ;结束
CODE ENDS
END BEG</code></pre>
<h3 id="小结">小结</h3>
<p>共同点：</p>
<ol type="1">
<li>宏指令与子程序都可以简化程序设计,增强程序的可读性</li>
</ol>
<p>不同点：</p>
<ol type="1">
<li>子程序调用是由CPU完成的,宏指令调用是在汇编过程中由汇编程序完成的</li>
<li>子程序调用可以减小目标程序的体积,宏指令则不能</li>
</ol>
<h2 id="程序设计举例">程序设计举例</h2>
<h3 id="顺序程序设计">顺序程序设计</h3>
<h4 id="读取字符">读取字符</h4>
<blockquote>
<p>从键盘输入一个字符并存储到字节变量BUF单元中并输出</p>
</blockquote>
<p>分析：用DOS功能调用完成键入，输入的字符保存在<code>AL</code>寄存器中；将<code>AL</code>中的内容存到定义在数据段的变量<code>BUF</code>所指单元中，然后再用DOS 02H功能，（注意其入口参数为DL）输出到屏幕上</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">.486
DATA SEGMENT USE16
  BUF  DB ?
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE, DS:DATA
  BEG: 
       MOV    AX,DATA
       MOV    DS,AX             ;赋予段基址
  
       MOV    AH,1
       INT    21H               ;调用DOS键入功能

       MOV    BUF,AL            ;传递给BUF
       MOV    DL,BUF            ;传递给DL

       MOV    AH,2
       INT    21H               ;调用DOS输出功能

       MOV    AH,4CH
       INT    21H               ;结束
CODE ENDS
END BEG</code></pre>
<h3 id="分支程序设计">分支程序设计</h3>
<h4 id="分段函数">分段函数</h4>
<blockquote>
<p>根据给定分段函数实现输入输出： <span class="math display">\[
y=f(x)=\left\{\begin{array}{cc}
1 &amp; x&gt;0 \\
0 &amp; x=0 \\
-1 &amp; x&lt;0
\end{array}\right.
\]</span></p>
</blockquote>
<p>分析：判定符号位<span class="math inline">\(S\)</span>和全零位<span class="math inline">\(Z\)</span>即可，可以用<span class="math inline">\(ADD\ 0\)</span>或者<span class="math inline">\(OR\)</span>自己刷新符号位</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">.486
DATA SEGMENT USE16
  X      DW ?
  MSG_0  DB &#39;0$&#39;
  MSG_1  DB &#39;1$&#39;
  MSG__1 DB &#39;-1$&#39;
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE,DS:DATA
  BEG: MOV    AX,DATA
       MOV    DS,AX              ;段基址
      
       MOV    X,12               ;设定X的初始值
       MOV    AX,X
       OR     AX,AX              ;利用位运算进行符号位判定  也可使用 ADD AX,0

       JZ     ZERO               ;全0进入
       JNS    PLUS               ;正数进入
  ;负数情况
       MOV    BL,0FFH            ;补码全F为-1
       MOV    DX, OFFSET MSG__1
       JMP    EXIT               ;结束
  ZERO:
       MOV    BL,0
       MOV    DX, OFFSET MSG_0
       JMP    EXIT
  PLUS:
       MOV    BL,1
       MOV    DX, OFFSET MSG_1
  EXIT:
       MOV    AH,09H
       INT    21H                ;字符串输出
      
       MOV    AH,4CH
       INT    21H

CODE ENDS
END BEG</code></pre>
<h4 id="打印二进制数字">打印二进制数字</h4>
<blockquote>
<p>将BX寄存器的内容以二进制数格式显在屏幕上</p>
</blockquote>
<p>思路：通过逻辑左移，每次取最高位，用标识符判定最高位，然后打印。循环数字二进制长度次即可</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">.486 
CODE SEGMENT USE16
       ASSUME CS:CODE

  BEG: 
       MOV    BX,5678H  ;初始化要打印的数字
       MOV    CX,16     ;16位
  LAST:
       MOV    DL,&#39;0&#39;    ;默认此位为0
       ROL    BX,1      ;逻辑左移一位
       JNC    NEXT      ;若C标（移出的位）为0进入
       MOV    DL,&#39;1&#39;    ;否则声明此位为1
  NEXT:
       MOV    AH,2H     ;打印
       INT    21H
       LOOP   LAST
       
       MOV    AH,4CH
       INT    21H

CODE ENDS
END BEG</code></pre>
<h3 id="循环程序设计">循环程序设计</h3>
<h4 id="求累加和">求累加和</h4>
<blockquote>
<p>求1-10的累加和</p>
</blockquote>
<p>思路：利用<code>LOOP</code>和<code>CX</code>这个天然的整数列，变为从10加到1</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">.486
DATA SEGMENT USE16
  SUM  DW ?
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE,DS:DATA
  BEG: ;初始化
       MOV    AX,DATA
       MOV    DS,AX
       MOV    CX,10
       MOV    AX,0
  AGA: 
       ADD    AX,CX
       LOOP   AGA
       MOV    SUM,AX
      
       MOV    AH,4CH
       INT    21H
CODE ENDS</code></pre>
<h4 id="禁忌的双重循环">禁忌的双重循环</h4>
<blockquote>
<p>双重循环：外层循环次数为<span class="math inline">\(N\)</span>，内层循环次数为<span class="math inline">\(M\)</span></p>
<p>要求：将<code>DATA</code>段中的每个单词改为大写字母</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">&gt;data segment
db &#39;ibm             &#39;
db &#39;dec             &#39;
db &#39;dos             &#39;
db &#39;vax             &#39;
&gt;data ends</code></pre>
</blockquote>
<p>思路：</p>
<ol type="1">
<li><strong>小写字母改大写字母</strong>可以用<code>AND 11011111B</code>即将<span class="math inline">\(D_5\)</span>置0；反之，<strong>大写字母变小写字母</strong>只用<code>OR 00100000B</code>将<span class="math inline">\(D_5\)</span>置1即可</li>
<li>使用4*3的二重循环，先定位行，再定位列。例如，先定位第一行，再循环修改前三列，再定位下一行，循环修改前三列…所以这里应该要使用<code>[BX+SI]</code>这种基址变址寻址的方式，用<code>BX</code>定位字符串，用<code>SI</code>定位字符</li>
<li>:star:值得注意的是，每次开始内层循环时，必须将外层循环的<code>CX</code>保存在栈中。在执行外层<code>LOOP</code>指令前恢复<code>CX</code></li>
</ol>
<pre class="language-asm" data-language="asm"><code class="language-asm">DATA SEGMENT
       DB &#39;IBM             &#39;  ;长度为3+13
       DB &#39;DEC             &#39;
       DB &#39;DOS             &#39;
       DB &#39;VAX             &#39;
DATA ENDS
STACK SEGMENT         ;定义堆栈段，容量为16BYTE
        DB 16 DUP(?)
STACK ENDS

CODE SEGMENT
        ASSUME CS:CODE,DS:DATA,SS:STACK
  START:
        MOV    AX,STACK
        MOV    SS,AX
        MOV    SP,16                     ;初始化堆栈
	
        MOV    AX,DATA
        MOV    DS,AX
        MOV    BX,0                      ;BX指向字符串首地址
	
        MOV    CX,4                      ;外层循环次数为4

  S0:   PUSH   CX                        ;外层循环的CX值压栈
        MOV    SI,0                      ;变址寄存器SI指向第一个字符
        MOV    CX,3                      ;内层循环次数为3

  S:    MOV    AL,[BX+SI]                ;变址寻址
        AND    AL,11011111B              ;将小写字母转换为大写字母
        MOV    [BX+SI],AL
        INC    SI                        ;变址寄存器SI指向下一个字符
        LOOP   S                         ;内层继续循环

        ADD    BX,16                     ;BX指向下一个字符串
        POP    CX                        ;从栈顶弹出原CX的值，恢复CX
        LOOP   S0                        ;外层循环的LOOP指令将CX中的计数值减1

        MOV    AX,4C00H
        INT    21H
	
CODE ENDS
END START</code></pre>
<h4 id="寻找最大字符">寻找最大字符</h4>
<blockquote>
<p>假设从BUF单元开始为一个字符串ASCII码，找出其中的最大数送屏幕显示</p>
</blockquote>
<p>思路：</p>
<ol type="1">
<li>由于只有一个字符串，所以寻址直接使用基址寻址<code>[BX]</code>即可</li>
<li>统计字符串长度以确定循环次数<code>CX</code></li>
</ol>
<pre class="language-asm" data-language="asm"><code class="language-asm">.486
DATA SEGMENT USE16
  BUF     DB &#39;QWERTYUOIOPASDFGHJKLZXCVBNM1234567890&#39;
  BUF_LEN &#x3D;  $-BUF                                    ;字符串长度
  MSG     DB &#39;The max number is : $&#39;
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE,DS:DATA
  BEG: 
       MOV    AX,DATA
       MOV    DS,AX
       MOV    AL,0             ; AL存放最大字符，初始化为最小值0
       MOV    CX,BUF_LEN       ; CX存放字符串长度
       LEA    BX,BUF           ; BX指向字符串首地址

  LAST:
       CMP    AL,[BX]          ; 比较AL和字符串中的字符
       JAE    NEXT             ; 如果AL大于等于字符串中的字符，跳转到NEXT
       MOV    AL,[BX]          ; 否则将字符串中的字符赋值给AL
  NEXT:
       INC    BX               ; BX指向下一个字符
       LOOP   LAST             ; 循环

       MOV    DX,OFFSET MSG    ; 设定出口参数DX
       MOV    MSG+19,AL        ; 将最大字符存放到MSG中
       MOV    AH,09H           ;显示结果
       INT    21H
       MOV    AH,4CH
       INT    21H
CODE ENDS
END BEG</code></pre>
<h3 id="数制转换">数制转换</h3>
<h4 id="二进制数显示">二进制数显示</h4>
<p>要求键盘输入一位数（0~9），转换为等值的二进制数显示</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">.486
DATA SEGMENT USE16
  MESG1 DB &#39;Please Enter ! &#39;,0DH,0AH,&#39;$&#39;
  MESG2 DB &#39;Error ! $&#39;
DATA ENDS
CODE SEGMENT USFE16
        ASSUME CS:CODE,DS:DATA
  BEG:  MOV    AX,DATA
        MOV    DS,AX            ;段寄存器
        MOV    AH,9
        MOV    DX,OFFSET MESG1
        INT    21H              ;显示操作提示

        MOV    AH,1
        INT    21H              ;键入一个字符，存入AL

        CMP    AL,3AH
        JNC    ERROR            ;＞&#39;9&#39;转
        CMP    AL,30H
        JC     ERROR            ;＜&#39;0&#39;转

        SUB    AL,30H
        MOV    BL,AL            ;BL&#x3D;0~9 的二进制数

        MOV    AH,2
        MOV    DL,&#39;&#x3D;&#39;
        INT    21H
        CALL   DISP
        MOV    AH,2
        MOV    DL,&#39;B&#39;
        INT    21H
        JMP    EXIT
  ERROR:MOV    AH,9
        LEA    DX, MESG2
        INT    21H
  ;显示错误信息
  EXIT: MOV    AH,4CH
        INT    21H

DISP PROC                       ;显示BL中的二进制数
        MOV    CX,8
  LAST: MOV    DL,&#39;0&#39;
        RCL    BL,1
        JNC    NEXT
        MOV    DL,&#39;1&#39;
  NEXT: MOV    AH,2
        INT    21H
        LOOP   LAST
        RET
DISP ENDP

CODE ENDS
END     BEG   </code></pre>
<h4 id="二进制数转十六进制数显示">二进制数转十六进制数显示</h4>
<p>从内存<code>BNUM</code>单元开始，有4个16位的二进制数，要求把它们转换成16进制数，并送屏幕显示。</p>
<p>思路：因为每组16进制数的长度是4*4 = 16位，所以这里在大循环的时候，使用<code>EDX</code>存放每一组数字，并先令其左移16位方便后续循环操作。后续的小循环操作简而言之就是：</p>
<ol type="1">
<li>每次循环左移4位，这样要解析的字符就到DL的低四位中，并通过一个<code>AND</code>取数值</li>
<li>取出数制后，根据其大小进行<code>+30H</code>和<code>+37H</code></li>
<li>保存其值到输出缓冲区<code>[SI]</code>，如此往复，直到计数器为0</li>
</ol>
<pre class="language-asm" data-language="asm"><code class="language-asm">;对内存中的二进制数转换为16进制数
.486
DATA SEGMENT  USE16
  BNUM  DW 0001001000110100B  ;1234H
        DW 0101011001111000B  ;5678H
        DW 0001101000101011B  ;1A2BH
        DW 0011110001001101B  ;3C4DH
  BUF   DB 4 DUP(?), &#39;H$&#39;     ;输出缓冲区
  COUNT DB 4
DATA ENDS

CODE SEGMENT  USE16
           ASSUME CS:CODE, DS:DATA
  BEG:     MOV    AX,DATA
           MOV    DS,AX             ;初始化
           MOV    CX,4              ;外层大循环为4个数
           MOV    BX,OFFSET BNUM    ;BX作为基址寄存器，指向各个二进制数的首地址
  AGA:     MOV    DX,[BX]
           SAL    EDX,16            ;算术左移(事实上随意左移即可，因为目的是将其数字位于最高位)16位，将低16位移到高16位
           CALL   N2_16ASC          ;调用函数后，缓冲区中有一组十六进制数
           MOV    AH,9
           MOV    DX,OFFSET BUF
           INT    21H               ;输出一组十六进制数

           ADD    BX,2              ;地址加 2，指向下一个二进制数
           LOOP   AGA               ;循环4（CX）次
           MOV    AH,4CH
           INT    21H
  ;二进数→十六进数ACSII码
N2_16ASC PROC
           MOV    SI,OFFSET BUF
  ;输出缓冲区地址→SI
           MOV    COUNT,4           ;重置COUNT为4，因为每组16进制数有4个字符
  LAST:    ROL    EDX,4             ;循环左移4位
           AND    DL,0FH            ;00001111B  ;取低4位置入DL
           CMP    DL,10             ;令DL与10比较
           JC     NEXT              ;如果DL&lt;10，则跳转到NEXT
           ADD    DL,7              ;如果DL&gt;&#x3D;10，则准备+37H变为字母的ASCII
  NEXT:    ADD    DL,30H            ;DL+30H
           MOV    [SI],DL           ;将数字保存到输出缓冲区
           INC    SI                ;输出缓冲区地址加1
           DEC    COUNT             ;计数-1
           JNZ    LAST              ;如果计数不为0，则跳转到LAST
           RET
N2_16ASC ENDP
CODE ENDS
END           BEG</code></pre>
<h4 id="二进制数转十进制数显示">二进制数转十进制数显示</h4>
<p>思路：<strong>比较法！</strong>比如8位二进制数最大为<span class="math inline">\(11111111B\)</span>即<span class="math inline">\(255\)</span>，那么可以通过判断二进制数含有几个100，几个10，几个1来对其进行输出</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">.486
CMPDISP MACRO    NN         ;宏定义
          LOCAL LAST, NEXT  ;定义局部标号
          MOV   DL,0        ;DL清0
  LAST:   CMP   BEN, NN     ;比较
          JC    NEXT        ;BEN＜NN，跳转到NEXT
          INC   DL          ;DL加1
          SUB   BEN, NN     ;BEN减去NN
          JMP   LAST        ;循环
  NEXT:   ADD   DL, 30H
          MOV   AH,2
          INT   21H         ;显示
ENDM
CODE SEGMENT  USE16
       ASSUME  CS:CODE
  BEN  DB      10101110B  ;&#x3D;174
  BEG: CMPDISP 100        ;调用宏判断并输出100的个数
       CMPDISP 10         ;调用宏判断并输出10的个数
       CMPDISP 1          ;调用宏判断并输出1的个数
       MOV     AH,4CH
       INT     21H
CODE ENDS
END BEG</code></pre>
<h3 id="实验内容">实验内容</h3>
<h4 id="统计字符串">统计字符串</h4>
<p>从<code>BUF</code>单元开始存有一字符串（长度&lt;255），编程实现统计该字符串中的<code>ASCII</code>在<span class="math inline">\(42H～45H\)</span>之间的字符个数，并将统计结果以二进制形式显示在屏幕</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">.486 
DATA SEGMENT USE16
  HINT    DB &#39;the BUF is QWERTYUOIOPASDFGHJKLZXCVBNM1234567890&#39;,0DH,0AH,&#39;$&#39;
  BUF     DB &#39;QWERTYUOIOPASDFGHJKLZXCVBNM1234567890&#39;
  BUF_LEN &#x3D;  $-BUF                                                               ;字符串长度
  MSG     DB &#39;The number of char that between 42H(B) to 45H(E) &#x3D;  &#39;,0DH,0AH,&#39;$&#39;
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE,DS:DATA
  BEG: 
       MOV    AX,DATA
       MOV    DS,AX
       MOV    DX, OFFSET HINT
       MOV    AH,09H
       INT    21H
       

       MOV    CX,BUF_LEN         ; CX存放字符串长度
       LEA    BX,BUF             ; BX指向字符串首地址
       MOV    AL,0               ; ans


  LAST:
       CMP    BYTE PTR [BX],42H  ;注意指定大小，否则BX默认为WORD
       JC     NEXT               ;低于42H则转移
       CMP    BYTE PTR [BX],45H  ;注意指定大小，否则BX默认为WORD
       JA     NEXT               ;高于45H则转移
       INC    AL                 ;答案+1
  NEXT:
       INC    BX                 ; BX指向下一个字符
       LOOP   LAST               ; 循环

       ADD    AL,30H             ;将数字转换为字符
       MOV    DX,OFFSET MSG      ; 设定出口参数DX
       MOV    MSG+51,AL          ; 将最大字符存放到MSG中

       MOV    AH,09H             ;显示结果
       INT    21H
       MOV    AH,4CH
       INT    21H
CODE ENDS
END BEG</code></pre>
<h4 id="编写登录验证程序">编写登录验证程序</h4>
<p>程序执行后，给出提示操作，请用户键入用户名和密码；用户在键入密码时，程序不回显键入字符而是显示<code>*</code>；只有当用户键入的用户名，密码字符串和程序内定的字符串相同时，显示欢迎界面并返回DOS；否则给出提示信息，用户名或密码错误，再次输入</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">;编写登录验证程序
.486
DATA SEGMENT USE16
  USERNAME1    DB  30,?,30 DUP(?)                     ;定义字符串，规定第二个字节为字符串长度
  USERNAME2    DB  &#39;B20030620&#39;
  LEN_USERNAME EQU $-USERNAME2                        ;计算字符串长度
  PASSWORD1    DB  30 DUP(?)                          ;定义字符串
  PASSWORD2    DB  &#39;PASSWORD&#39;
  LEN_PASSWORD EQU $-PASSWORD2                        ;计算字符串长度
  PROMOTE1     DB  &#39;Please input username:$&#39;
  PROMOTE2     DB  &#39;Please input password:$&#39;
  PROMOTE3     DB  &#39;Login success!$&#39;
  PROMOTE4     DB  &#39;Login failed!please try again!$&#39;
  FLAG         DB  &#39;Y&#39;
DATA ENDS

;宏指令显示回车
CRLF MACRO
       MOV AH,2
       MOV DL,0DH
       INT 21H
       MOV DL,0AH
       INT 21H
ENDM
;宏指令显示字符串
PRINTSTR MACRO STR
           MOV AH,9
           LEA DX,STR
           INT 21H
ENDM
;宏指令显示字符
PRINTCHAR MACRO CHAR
            MOV AH,2
            MOV DL,CHAR
            INT 21H
ENDM
CODE SEGMENT USE16
         ASSUME    CS:CODE,DS:DATA,ES:DATA

  BEG:   
         MOV       AX,DATA
         MOV       DS,AX
         MOV       ES,AX                    ;INIT
         MOV       FLAG,&#39;Y&#39;                 ;初始化标志位
         MOV       CX,LEN_USERNAME
         PRINTSTR  PROMOTE1                 ;提示输入用户名

         MOV       AH,0AH
         MOV       DX,OFFSET USERNAME1      ;入口函数DX将字符串存入USERNAME1
         INT       21H                      ;键入字符串
         CRLF                               ;显示回车

         MOV       CL,USERNAME1+1           ;CL&#x3D;字符串长度，第2个字节为输入的字符串的长度
         MOV       CH,0                     ;CH&#x3D;0
         CMP       CX,LEN_USERNAME          ;比较输入的字符串长度与LEN_USERNAME

         JE        NEXT1                    ;如果相等，就不设置
         MOV       FLAG,&#39;1&#39;                 ;如果不相等，就设置FLAG为N
  ;  JMP       FAIL                     ;DEBUG
  NEXT1: 
         MOV       DI,OFFSET USERNAME2      ;DI指向USERNAME2
         MOV       SI,OFFSET USERNAME1+2    ;SI指向USERNAME1+2
         REPE      CMPSB                    ; 比较字符串
         JE        NEXT2                    ;如果不相等，设置FLAG为N
         MOV       FLAG,&#39;2&#39;                 ;如果相等，继续
  ;  JMP       FAIL                     ;DEBUG
  NEXT2: 

         PRINTSTR  PROMOTE2                 ;提示输入密码
         MOV       BX,0                     ;使用BX统计密码长度
         MOV       SI,OFFSET PASSWORD1      ;SI指向PASSWORD1
  ;使用07H功能键入密码
  GETPW: 
         MOV       AH,00H                   ; 逐个字符输入密码，遇到回车结束输入
         INT       16H
         CMP       AL,0DH                   ;回车输入完毕
         JE        NEXT
         CMP       AL,08H                   ;退格键
         JE        BACK
         MOV       [SI],AL                  ;将输入的字符存入PASSWORD1

         PRINTCHAR &#39;*&#39;                      ;显示*

         INC       SI
         INC       BX                       ; 统计输入密码的长度
         JMP       GETPW
  BACK:  
         CMP       BX,0                     ;如果密码长度为0，就不退格
         JE        GETPW

         MOV       AH,2
         MOV       DL,08H
         INT       21H                      ;显示退格
         MOV       AH,2
         MOV       DL,20H
         INT       21H                      ;显示空格,覆盖*
         MOV       AH,2
         MOV       DL,08H
         INT       21H                      ;显示退格,回到*之前的位置
         DEC       SI
         DEC       BX
         JMP       GETPW
  NEXT:  
         CRLF
         MOV       SI,OFFSET PASSWORD1
  ; ;DEBUG 输出密码
  ;        MOV       CX,BX
  ; DE:
  ;        PRINTCHAR [SI]
  ;        INC       SI
  ;        LOOP      DE
  ;        CRLF
  ; ;输出用户名
  ;        MOV       CL,USERNAME1+1
  ;        MOV       SI,OFFSET USERNAME1+2
  ; DE1:
  ;        PRINTCHAR [SI]
  ;        INC       SI
  ;        LOOP      DE1
  ;        CRLF
  ; ;DEBUG
         CMP       BX,LEN_PASSWORD          ;比较输入的字符串长度与LEN_PASSWORD
         JE        NEXT3
         MOV       FLAG,&#39;3&#39;
  ;  JMP       FAIL                     ;DEBUG
  NEXT3: 
         MOV       CX,BX
         MOV       DI,OFFSET PASSWORD2
         MOV       SI,OFFSET PASSWORD1
  CHECK: 
         MOV       BL,[SI]
         CMP       BL,[DI]
         JNE       CHECKF
         INC       SI
         INC       DI
         LOOP      CHECK

         JMP       NEXT4
  CHECKF:MOV       FLAG,&#39;4&#39;
  ;  JMP       FAIL                     ;DEBUG
  NEXT4: 
         CMP       FLAG,&#39;Y&#39;                 ;如果FLAG为Y，就显示登录成功，否则显示登录失败
         JNE       FAIL
         PRINTSTR  PROMOTE3
         CRLF
         JMP       EXIT
  FAIL:  
  ;输出flag
  ;  PRINTCHAR FLAG
         CRLF
         PRINTSTR  PROMOTE4
         CRLF
         JMP       BEG
  EXIT:  
         MOV       AH,4CH
         INT       21H
CODE ENDS
END BEG</code></pre>
</div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Anduin9527</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://lapras.xyz/2022/10/23/80b4c1fd.html" title="汇编语言程序设计（三）">http://lapras.xyz/2022/10/23/80b4c1fd.html</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/10/02/ecdaa9d1.html" rel="next" title="Games101-Shading"><span class="post-nav-text">Games101-Shading</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>如果您有任何关于博客内容的相关讨论，欢迎与我交流。</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">闽ICP备2021012704号</a></div><div class="copyright"><span>&copy; 2020 – 2022 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Anduin9527</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.2.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.6</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#66d6ff" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" target="_blank" rel="noopener" href="https://www.google.com/search?q=site:lapras.xyz" title="Search"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18","5-12","12-13"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script></body></html>