<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anduin9527的乖离器</title>
  
  <subtitle>正在进修摸鱼学导论</subtitle>
  <link href="http://lapras.xyz/atom.xml" rel="self"/>
  
  <link href="http://lapras.xyz/"/>
  <updated>2022-06-26T13:34:32.232Z</updated>
  <id>http://lapras.xyz/</id>
  
  <author>
    <name>Anduin9527</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成原理笔记（一）</title>
    <link href="http://lapras.xyz/2022/06/25/5bb1b670.html"/>
    <id>http://lapras.xyz/2022/06/25/5bb1b670.html</id>
    <published>2022-06-25T09:36:13.000Z</published>
    <updated>2022-06-26T13:34:32.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>暑假正式开始，开（huan）坑（zhai）计组。笔记会同步更新于<a href="https://github.com/Anduin9527/CS-Professional-Notes-of-NJUPT">我的Github笔记仓库</a></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625173242.webp" alt="img" style="zoom:67%;" / loading="lazy"></p><span id="more"></span><h2 id="计算机系统简介">计算机系统简介</h2><h3 id="计算机软硬件概念">计算机软硬件概念</h3><p>计算机系统</p><ol type="1"><li>硬件：计算机的实体：如主机、外设</li><li>软件：具有各类特殊功能的信息（程序）组成<ol type="1"><li>系统软件：用来管理整个计算机系统<ol type="1"><li>语言处理程序（编译、链接）</li><li>操作系统</li><li>服务性程序</li><li>数据库管理系统</li><li>网络软件</li></ol></li><li>应用软件：按任务需要编写的程序</li></ol></li></ol><h3 id="计算机系统的层次结构">计算机系统的层次结构</h3><ol type="1"><li><p>物理结构抽象</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625092903.png" alt="image-20220625092855877" / loading="lazy"><figcaption aria-hidden="true">image-20220625092855877</figcaption></figure><p>自底向上地来看：</p><ol type="1"><li>Physics 物理抽象，电子设备依靠电子的移动进行工作。可以使用 量子 机制，和麦克斯韦方程进行描述。</li><li>Devices 电子元件，利用电子在不同物质中的移动特征来构建不同的电子元件，其具有不同的电压电流特征用以描述。</li><li>Analog Circuits 模拟电路，利用基本的电子元件构建放大器，滤波器等部件。</li><li>Digital Circuits 数字电路，利用模拟电路层进一步构建与非门等。</li><li>Logic 逻辑层，利用数字电路进行加法器和存储器的实现。</li><li>Microarchitecture 微体系(架构)结构层，具有执行单元和控制单元</li></ol></li><li><p>程序员角度</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625094958.png" alt="image-20220625094958199" / loading="lazy"><figcaption aria-hidden="true">image-20220625094958199</figcaption></figure></li></ol><h2 id="计算机的基本组成">计算机的基本组成</h2><h3 id="冯诺依曼计算机的特点">冯·诺依曼计算机的特点</h3><ol type="1"><li>计算机由五大部件（运算器、控制器、存储器、输入设备和输出设备）组成</li><li>指令和数据以同等地位<strong>存于存储器</strong>，可按地址寻访</li><li>指令和数据用二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序（核心特征）</li><li>以运算器为中心</li></ol><h3 id="冯诺依曼计算机的硬件图">冯·诺依曼计算机的硬件图</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625101051.png" alt="image-20220625101051177" style="zoom:80%;" / loading="lazy"></p><ul><li>实线表示数据通路</li><li>虚线表示控制和状态反馈</li><li>运算器：核心，算术运算与逻辑运算</li><li>存储器：存放数据和程序</li><li>控制器：指挥控制程序的运行</li><li>输入设备：将信息转化为机器能识别的形式</li><li>输出设备：将结果转化为人能识别的形式</li></ul><h3 id="冯诺依曼计算机的结构改进">冯·诺依曼计算机的结构改进</h3><p>以存储器为中心的计算机硬件框图</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625101628.png" alt="image-20220625101628906" / loading="lazy"><figcaption aria-hidden="true">image-20220625101628906</figcaption></figure><p>其中，运算器（ALU）和控制器（CU）可以组成 CPU 。存储器可以进一步分为主存和辅存。主存和CPU可以进一步构成主机。输入设备和输出设备统称为I/O设备，主机和I/O设备统称为硬件。则给出</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625103446.png" alt="image-20220625103446906" style="zoom:80%;" / loading="lazy"></p><h3 id="系统复杂性管理的方法">系统复杂性管理的方法</h3><ol type="1"><li>层次化（Hierachy）：将被设计的系统划分为多个模块或子模块</li><li>模块化（Modularity）：有明确定义（well-defined）的功能和接口</li><li>规则性（regularity）：模块符合某些通用标准，使其更容易被重用</li></ol><h3 id="计算机的工作步骤">计算机的工作步骤</h3><ol type="1"><li>建立数学模型</li><li>确定计算方法</li><li>编写解题程序</li></ol><p>给例子：计算<span class="math inline">\(a x^{2}+b x+c=(a x+b) x+c\)</span></p><ol type="1"><li><p>从问题来看需要<strong>加法指令</strong>和<strong>乘法指令</strong></p></li><li><p>还需要取出数字并放置到累加器中的<strong>取数指令</strong>，和读取结果并放置到存储器中的<strong>读取指令</strong></p></li><li><p>最后是显示或者打印的<strong>打印指令</strong>，以及停机指令</p></li><li><p>计算</p><p>取 x 至运算器中 乘以 a 在运算器中 加 b 在运算器中 乘以 x 在运算器中 加 c 在运算器中</p></li></ol><h3 id="指令格式">指令格式</h3><p>都使用16位长度的指令由6位操作码和8位地址码构成，[] 表示在寄存器中保存的内容</p><ol type="1"><li><p>取数指令</p><p>取数 a，[a] –&gt; ACC</p><p>000001 0000001000，前六位表示取数指令，后十位表示地址8</p></li><li><p>存数指令</p><p>存数 b，[ACC] –&gt; b</p></li><li><p>加法指令</p><p>加数 c，[ACC] + [c] –&gt; [ACC]</p></li><li><p>乘法指令</p><p>乘数 d，[ACC] * [d] –&gt; [ACC]</p></li><li><p>打印指令</p><p><span class="math inline">\(\sigma\)</span> ，[<span class="math inline">\(\sigma\)</span>] –&gt; 打印机</p></li><li><p>停机指令</p></li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625110202.png" alt="image-20220625110202631" style="zoom:67%;" / loading="lazy"></p><h3 id="存储器的基本组成">存储器的基本组成</h3><p>上面我们知道，<strong>指令</strong>和<strong>数据</strong>都保存在存储器当中。<strong>存储器</strong>的主要部分是<strong>存储体，MAR，MDR</strong></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625161002.png" alt="image-20220625161002215" style="zoom:67%;" / loading="lazy"></p><ul><li><p><strong>存储体</strong>又有若干<strong>存储单元</strong>构成，<strong>存储单元</strong>又由若干<strong>存储元件</strong>（0/1）构成。</p></li><li><p>存储单元：存放一串二进制代码，即<strong>存储字</strong></p></li><li><p>存储字长：存储字的长度（位数）</p></li><li><p>存储单元<strong>按照地址寻址</strong></p></li><li><p>MAR：存储器<strong>地址寄存器</strong>，<strong>保存了存储单元的地址</strong>，MAR的位数反映了存储单元的个数。<strong>即存储单元个数是<span class="math inline">\(2^{n_{MAR}}\)</span></strong>。</p></li><li><p>MDR：存储器<strong>数据寄存器</strong>，MDR的位数表示该存储器的<strong>存储字长</strong>，即<strong>存储字长是</strong><span class="math inline">\(n_{MDR}\)</span></p></li><li><p>MAR 就像存储器的入口，其接受某个地址作为寻找请求。存储器找到后将其地址中的<strong>内容</strong>交给存储器出口MDR</p></li></ul><h3 id="运算器的基本组成">运算器的基本组成</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625162012.png" alt="image-20220625162012087" style="zoom:80%;" / loading="lazy"></p><p>ALU：Arithmetic Logic Unit，<strong>算术逻辑运算单元</strong>，运算器中完成算术逻辑运算的逻辑部件</p><p>ACC：Accumulator，<strong>累加器</strong>，运算器中运算前存放操作数、运算后存放运算结果的寄存器</p><p>MQ：Multiplier-Quotient Register，<strong>乘商寄存器</strong>，乘法运算时存放乘数、除法时存放商的寄存器</p><p>X：此字母没有专指的缩写含义，可以用作任一部件名，在此表示操作数寄存器，即运算器中工作寄存器之一，用来<strong>存放操作数</strong></p><p>例：加法操作过程，设加法指令操作码为000001，加数的地址为M</p><ol type="1"><li>初态：ACC中已经存放好了被加数</li><li>[M] –&gt; X</li><li>[ACC] + [X] –&gt; ACC</li></ol><p>例2：减法操作过程，设减法指令操作码为000010，减数的地址为M</p><ol type="1"><li>初态：ACC中已经存放好了被减数</li><li>[M] –&gt; X</li><li>[ACC] - [X] –&gt; ACC</li></ol><p>例3：乘法操作过程，设乘法指令操作码为000011，乘数的地址为M</p><ol type="1"><li>初态：ACC中已经存放好了被乘数</li><li>[M] –&gt; MQ</li><li>[ACC] –&gt; X</li><li>0 –&gt; ACC</li><li>[ACC] * [X] –&gt; ACC//MQ</li></ol><p>例4：除法操作过程，设触发指令操作码为000111，除数的地址为M</p><ol type="1"><li>初态：ACC中已经存放好了被除数</li><li>[M] –&gt; X</li><li>[ACC] / [X] –&gt; MQ，余数在ACC中</li></ol><h3 id="控制器的基本组成">控制器的基本组成</h3><p>控制器由PC、IR与CU组成</p><p>控制器用以解释指令并保证指令按照正确的次序执行，下面来看完成一条指令需要三个大步骤：</p><ol type="1"><li>取指令，<strong>PC（程序计数器）</strong>存放当前欲执行指令的地址， 具有计数功能：（PC）+ 1 –&gt; PC</li><li>分析指令，<strong>IR（指令寄存器）</strong>存放当前欲执行的指令</li><li>执行指令，<strong>CU</strong></li></ol><p>例：完成一条<strong>取数指令</strong>的过程</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625165601.png" alt="image-20220625165601107" style="zoom:80%;" / loading="lazy"></p><ol type="1"><li>取指令<ol type="1"><li>PC 把指令的地址给MAR</li><li>MAR 在控制器的控制之下，根据地址寻找指定的存储单元</li><li>存储体把指定的存储单元中的指令取出送入 MDR</li><li>MDR 取出的指令送入 IR</li></ol></li><li>分析指令<ol type="1"><li>IR 中的操作码部分送给 CU，由 CU 根据指令开始执行操作</li></ol></li><li>执行指令<ol type="1"><li>IR 中的地址码部分送给 MAR</li><li>MAR 在控制器的控制之下，根据地址寻找指定的存储单元</li><li>存储体把指定的存储单元中的数据取出送入 MDR</li><li>MDR 取出的数据送入ACC，取数完毕</li></ol></li></ol><h3 id="总结">总结</h3><ol type="1"><li>将程序通过输入设备送至计算机</li><li>程序首地址 –&gt; PC</li><li>启动程序运行</li><li>取指令PC→MAR→M→MDR→IR，(PC)+1→PC</li><li>分析指令OP(IR)→CU</li><li>执行指令AD(IR)→MAR→M→MDR→ACC</li><li>……</li><li>打印结果</li><li>停机</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;暑假正式开始，开（huan）坑（zhai）计组。笔记会同步更新于&lt;a href=&quot;https://github.com/Anduin9527/CS-Professional-Notes-of-NJUPT&quot;&gt;我的Github笔记仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625173242.webp&quot; alt=&quot;img&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SPSS基础应用与聚类分析</title>
    <link href="http://lapras.xyz/2022/06/23/aef9302d.html"/>
    <id>http://lapras.xyz/2022/06/23/aef9302d.html</id>
    <published>2022-06-22T16:49:42.000Z</published>
    <updated>2022-06-22T17:06:42.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>6月23日、『Honkai Impact 3』の新メインライン発売まで10時間、『Rise of SunBreak』の発売まで7日です。 もう我慢できない！ テレビゲームがしたい！</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220623010515.png" alt="image-20220623010515152" / loading="lazy"><figcaption aria-hidden="true">image-20220623010515152</figcaption></figure><span id="more"></span><h2 id="标准化数据">标准化数据</h2><blockquote><p>​ 大型数据分析项目中，数据来源不同，量纲及量纲单位不同，为了让它们具备可比性，需要采用标准化方法消除由此带来的偏差。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。这就是数据标准化。</p><p><strong>基本原理</strong>：z-score标准化。数值减去平均值，再除以其标准差，得到<strong>均值为0，标准差为1</strong>的服从<strong>标准正态分布</strong>的数据。</p></blockquote><ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>描述</li><li>将标准化值另存为变量（Z）</li></ol><h2 id="归一化数据">归一化数据</h2><blockquote><p>主要是为了数据处理方便提出来的，把数据映射到0～1范围之内处理，把有量纲表达式变为无量纲表达式。</p></blockquote><ol type="1"><li><p>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>描述</p></li><li><p>选项<span class="math inline">\(\rightarrow\)</span>最小值、最大值</p></li><li><p>转换<span class="math inline">\(\rightarrow\)</span>计算变量 <span class="math display">\[x^* = \frac{x-min}{max-min}\]</span></p></li></ol><h2 id="聚类分析">聚类分析</h2><blockquote><p>聚类分析是一种探索性分析方法，与判别分析不同，<strong>聚类分析事先并不知道分类的标准，甚至不知道应该分成几类，</strong>而是会根据样本数据的特征，自动进行分类。严格说来聚类分析并不是纯粹的统计技术，它不像其它多元分析法那样，需要从样本去推断总体。一般都涉及不到有关统计量的分布，也不需要进行显著性检验。假定研究对象均用所谓的“点”来表示。 在聚类分析中，一般的规则是将“距离”较 小的点归为同一类，将“距离”较大的点归为不同的类。 常见的是对个案分类，也可以对变量分类， 但对于变量分类此时一般使用相似系数作为 “距离”测量指标。</p><p>目的：使属于同一类别的数据间的 相似性尽可能大，不同类别中的数据间的相似性尽可能小</p><p><strong>注意：</strong>聚类分析更像是一种建立假设的方法，而对于相关假设的检验还需要借助其他统计的方法，比如判别分析、T-检验、方差分析等，看聚类出来的几个类别是否存在差异</p></blockquote><ul><li><p>从统计学的观点看，聚类分析是通过数据建模简化数据的一种方法。</p></li><li><p>从机器学习的角度看，簇相当于隐藏模式。聚类是搜索簇的无监督学习过程。</p></li><li><p>从实际应用的角度看，聚类分析是数据预处理（降维）和信息挖掘的主要任务之一。</p></li></ul><p>常规步骤：</p><ol type="1"><li>选择聚类指标（经验、主成分分析、因子分析）</li><li>数据标准化处理（K-means需要预处理，其余SPSS集成）</li><li>选择聚类方法：样本容量，变量类型</li><li>确定分类个数</li><li>进行结果解读</li></ol><h2 id="k均值聚类k-means-cluster">K均值聚类（K-means Cluster）</h2><ul><li><p>聚类对象：个案（Q型聚类分析）</p></li><li><p>变量类型：连续变量</p></li><li><p>分类数：固定</p></li><li><p>样本容量：大样本</p></li></ul><h3 id="流程">流程</h3><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TB选择若干聚类中心 <span class="token arrow operator">----></span> 依据与聚类中心的距离划分出初始分类依据与聚类中心的距离划分出初始分类 <span class="token arrow operator">----></span> 计算出各个分类的中心位置计算出各个分类的中心位置 <span class="token arrow operator">----></span> A<span class="token text string">&#123;用计算出的中心位置重新进行聚类&#125;</span>A <span class="token arrow operator">----></span> 计算出各个分类的中心位置A <span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">聚类中心收敛</span><span class="token arrow operator">--></span></span> END</code></pre><p>整个K-means是一个自平衡的过程，其不断划分类别，然后用某些规则（比如重心）计算聚类中心，再重新根据聚类中心划分类别，如此不断迭代，直到某次循环结果与上次一致或者达到迭代上限。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622224606.gif" alt="img" / loading="lazy"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="优缺点">优缺点</h3><p>优点：</p><ol type="1"><li>原理比较简单，实现也很容易，<strong>收敛速度快</strong>。</li><li>在对大规模数据集进行聚类分析时，算法聚类较高效且聚类效果较好。</li><li>簇与簇之间区别明显时，它的聚类效果很好。</li></ol><p>缺点：</p><ol type="1"><li>分类数从<strong>初始分类开始就确定不变</strong>了，所以要求事先要对样本有足够的了解。</li><li>仅限于<strong>个案间的聚类</strong>（Q型聚类）,不能对变量进行聚类。</li><li>个案间的距离的测量方法使用的是<strong>欧式距离的平方</strong>，因此只能对连续变量进行聚类。</li></ol><h3 id="spss过程">SPSS过程</h3><ol type="1"><li>对变量进行标准化处理</li><li>分析<span class="math inline">\(\rightarrow\)</span>分类<span class="math inline">\(\rightarrow\)</span>k均值聚类</li><li>选择个案变量（比如ID），其余变量放置于变量，设置聚类数。</li><li>迭代<span class="math inline">\(\rightarrow\)</span>默认迭代十次</li><li>保存<span class="math inline">\(\rightarrow\)</span>聚类成员</li><li>统计<span class="math inline">\(\rightarrow\)</span>初始聚类中心，ANOVA，每个个案的聚类信息</li><li>结果分析<ol type="1"><li>初始聚类中心、最终聚类中心和迭代历史记录（若不收敛调整迭代次数）</li><li>ANOVA：<strong>聚类均方</strong>对应组间均方差，<strong>误差均方</strong>对应组内均方差，显著性p&lt;0.05且<strong>组间均方差大于组内均方差</strong>时说明此变量组别之间差异明显，分类可信度较高。</li><li>聚类成员明细</li></ol></li><li>由于可能经过标准化处理，最后的结果是标准化的数值。如果要查看聚类中心原本的数值<ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>比较均值<span class="math inline">\(\rightarrow\)</span>均值</li><li>选择标准化前的变量作为因变量，案例的类别号作为自变量</li><li>选项<span class="math inline">\(\rightarrow\)</span>单元格统计量只要均值</li></ol></li></ol><h2 id="系统聚类分层聚类">系统聚类（分层聚类）</h2><ul><li><p>聚类对象：个案或变量</p></li><li><p>变量类型：连续变量或分类变量</p></li><li><p>分类数：固定或指定范围</p></li><li><p>样本容量：中小样本</p></li></ul><h3 id="流程-1">流程</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622233231.png" alt="image-20220622233231246" style="zoom:67%;" / loading="lazy"></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622233846.gif" alt="6-what-is-clustering" / loading="lazy"><figcaption aria-hidden="true">6-what-is-clustering</figcaption></figure><h3 id="优缺点-1">优缺点</h3><p>优点：</p><ol type="1"><li>距离和规则的相似度容易定义，限制少。</li><li>既可对分类变量聚类，也可对连续变量聚类。</li><li>事先不需要确定要分多少类，系统会自动确定最佳分类数。</li></ol><p>缺点：</p><ol type="1"><li>运行较慢，适合样本容量较少</li><li>系统聚类分析时，每个个案一旦归为某一类就不允许再改变，但最初的分类可能不是最优的选择。</li></ol><h3 id="spss过程-1">SPSS过程</h3><ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>分类<span class="math inline">\(\rightarrow\)</span>系统聚类</li><li>聚类可以选择个案（标注个案变量）或者变量</li><li>统计<span class="math inline">\(\rightarrow\)</span>集中计划，近似值矩阵</li><li>图<span class="math inline">\(\rightarrow\)</span>谱系图，取消冰柱图</li><li>方法<span class="math inline">\(\rightarrow\)</span>标准化：Z得分（按变量）；聚类方法：一般而言组间联接是最好的，ward法聚类出来会比较平均；度量标准：个案一般用平方欧式距离，变量一般用皮尔逊相关系数</li><li>结果分析</li></ol><h2 id="二阶聚类twostep-cluster">二阶聚类（TwoStep Cluster）</h2><ul><li><p>聚类对象：个案或变量</p></li><li><p>变量类型：连续变量和分类变量</p></li><li><p>分类数：自动确定</p></li><li><p>样本容量：大样本</p></li></ul><h3 id="优缺点-2">优缺点</h3><p>优点：</p><ol type="1"><li>能够<strong>同时处理分类变量和连续变量</strong></li><li>可自动选择最优的分类个数</li><li>适用于大样本数据</li></ol><p>缺点：</p><ol type="1"><li>聚类结果主要受所选择的变量影响。如果去掉一些变量，或者增加一些变量，结果会很不同</li><li>分类变量应服从<strong>多项分布</strong>，连续变量应服从<strong>正态分布</strong>（但其实会自动剔除异常值）</li></ol><h3 id="spss过程-2">SPSS过程</h3><ol type="1"><li><p>检验正态分布（分类变量多项分布一般都是满足的）</p></li><li><p>检验共线性，去除无关变量</p></li><li><p>分析<span class="math inline">\(\rightarrow\)</span>分类<span class="math inline">\(\rightarrow\)</span>两步聚类</p></li><li><p>按照变量类型分开为分类变量和连续变量，剩余一个为个案变量</p></li><li><p>选项<span class="math inline">\(\rightarrow\)</span>连续变量标准化</p></li><li><p>输出<span class="math inline">\(\rightarrow\)</span>选择透视表；将个案变量作为判断字段；创建聚类成员变量</p></li><li><p>结果分析：</p><ol type="1"><li><p>自动聚类表：</p><blockquote><p>根据施瓦茨贝叶斯准则（BIC)帮助<strong>判断最佳分类数量</strong>，从统计上分析，该数值越小聚类效果越好。但是实际中还要考虑BIC变化量、BIC变化比率和距离测试比率，可以通过他们进一步确定最佳分类数。 判断标准：</p><ol type="1"><li>BIC准则数值越小，聚类效果越好；</li><li>BIC变化量数值越小，聚类效果越好；</li><li>距离测量比率数值越大，聚类效果越好。</li></ol></blockquote></li><li><p>聚类分布，质心：不同类的总体情况</p></li><li><p>模型概要：聚类质量图反映聚类效果的好坏，双击可进入详细模式，然后左下角查看<span class="math inline">\(\rightarrow\)</span>聚类，接着可以点击某些属性来<strong>查看变量重要性</strong>，或者多选某些属性来查看<strong>各类别对比</strong>。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220623003719.png" alt="image-20220623003719854" style="zoom: 80%;" / loading="lazy"></p></li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;6月23日、『Honkai Impact 3』の新メインライン発売まで10時間、『Rise of SunBreak』の発売まで7日です。 もう我慢できない！ テレビゲームがしたい！&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220623010515.png&quot; alt=&quot;image-20220623010515152&quot; /&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20220623010515152&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    <category term="数学建模" scheme="http://lapras.xyz/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="数学" scheme="http://lapras.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="聚类分析" scheme="http://lapras.xyz/tags/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
    
    <category term="统计" scheme="http://lapras.xyz/tags/%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>SPSS基础应用与回归分析</title>
    <link href="http://lapras.xyz/2022/06/22/56984c70.html"/>
    <id>http://lapras.xyz/2022/06/22/56984c70.html</id>
    <published>2022-06-22T06:41:26.000Z</published>
    <updated>2022-06-26T13:27:08.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>福州好热，暑假又要开模了呜呜呜我的CS呜呜呜。趁着训练前终于把打了一年的MHW煌黑龙和黑龙通了，芜湖~~</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622143315.png" alt="image-20220622143314890" / loading="lazy"><figcaption aria-hidden="true">image-20220622143314890</figcaption></figure><span id="more"></span><h2 id="描述性分析">描述性分析</h2><blockquote><p>描述性分析主要是对所收集的数据进行分析，得出反映客观现象和数量特征的一种分析方法，它主要包括数据的集中趋势分析、数据离散程度分析、数据的频数分布分析等，描述性分析是对数据进一步分析的基础。</p><ul><li>分类变量：说明事物的类别，其数据是不连续（指数值上）、互不相容的（指不会同时满足复数个类别）。比如：性别</li><li>连续变量：其数据是连续的。比如：年龄</li></ul></blockquote><h3 id="对分类变量进行频率分析">对分类变量进行频率分析</h3><blockquote><h1 id="注意spss中不支持中文数据所以使用数值型添加标签值的方式">注意SPSS中不支持中文数据，所以使用数值型+添加标签值的方式</h1></blockquote><ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>频率</li><li>选择对应的分类变量</li><li>图表<span class="math inline">\(\rightarrow\)</span>条形图生成</li></ol><h3 id="对连续变量进行频率分析">对连续变量进行频率分析</h3><ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>频率</li><li>选择对应的连续变量</li><li>统计<span class="math inline">\(\rightarrow\)</span>选择一些条目<ul><li>四分位数：输出这组数据的四等分点</li><li>分割点：输出这组数据的n等分点</li><li>百分位数：输出这组数据的指定百分比点</li><li>中位数、平均值、标准差、最小值、最大值</li></ul></li><li>图表<span class="math inline">\(\rightarrow\)</span>直方图<span class="math inline">\(\rightarrow\)</span>显示正态曲线</li></ol><h3 id="交叉表分析统计频率">交叉表分析统计频率</h3><blockquote><p>交叉表分析是用于分析两个或两个以上变量之间的关联关系，以交叉表格的形式进行分组变量间关系的对比分析。</p></blockquote><ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>频率</li><li>选择行（自变量）列数据（因变量）</li><li>格式<span class="math inline">\(\rightarrow\)</span>百分比选择列</li><li>可以选择簇状条形图</li></ol><h2 id="数据异常值检验">数据异常值检验</h2><ol type="1"><li>图形<span class="math inline">\(\rightarrow\)</span>箱图<span class="math inline">\(\rightarrow\)</span>简单，单独变量的摘要</li><li>箱表示：移入需要检测的变量</li><li>观察箱线图，除去异常值或将其设置为均值</li></ol><h2 id="数据正态分布检验">数据正态分布检验</h2><ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>探索</li><li>全部选入因变量列表，图<span class="math inline">\(\rightarrow\)</span>因子级别并置，茎叶图，含检验的正态图</li><li>观察变量的显著性p值</li></ol><h2 id="相关分析和独立性检验">相关分析和独立性检验</h2><blockquote><p>相关关系是指现象之间存在着非严格的、不确定的依存关系。这种依存关长系的特点是：某一现象在数量上发生变化会影响另一现象数量上的变化，而且这种变化在数量上具有一定的随机性。即当给定某一现象一数值时，另一现象会有若干个数值与之对应，并且总是遵循一定的规律， 围绕这些数值的平均数上下波动，其原因是影响现象发生变化的因素不止一个。</p><p>相关关系可分为线性相关和非线性相关，线性相关也称为直线相关，线性相关是最常用的一种，即当一 个连续变量发生变动时，另一个连续变量相应地呈线性 关系变动，用<strong>皮尔逊（Pearson)相关系数</strong>上来度量。</p><p><strong>皮尔逊相关系数</strong>就是反映连续变量之间线性相关强度的一个度量指标，它的取值范围限于[-1, 1]。 r的正、负号可以反映相关的方向，当 r &gt; 0 时表示表示 线性正相关，当 r &lt; 0 时，线性负相关。 r的大小可以反映相关的程度，r = 0 表示两个变量之间不存在线性关系。一般认为0.3~0.8为中度相关。</p><p>非线性相关某种意义来讲也就是曲线相关，一般不用相关系数度量其相关性。</p></blockquote><h3 id="相关分析">相关分析</h3><p>前提：两变量为<strong>连续变量</strong>，两变量之间为<strong>线性相关</strong>。数据服从正态分布且无异常值。</p><ol type="1"><li><p>绘制散点图大致判断是否为线性关系（图形<span class="math inline">\(\rightarrow\)</span>简单散点图）</p></li><li><p>计算相关系数（分析<span class="math inline">\(\rightarrow\)</span>相关<span class="math inline">\(\rightarrow\)</span>双变量）</p></li><li><p>显著性检验，即上一步中得到的<span class="math inline">\(Sig.\)</span>也就是所谓的P值</p><blockquote><p>P值小于一般显著性水平（<strong>一般为0.05</strong>）则认为变量间存在显著性相关关系，小于0.01则具有极其显著的相关关系。P值大于一般显著性水平（一般为0.05）则认为变量间不存在显著性相关关系。</p></blockquote></li></ol><h3 id="卡方独立性检验">卡方独立性检验</h3><p>前提：</p><ol type="1"><li><p>观测变量（因变量）是二分类变量（布尔变量）。</p></li><li><p>分组变量（自变量）的类别大等于2。</p></li><li><p>抽样是独立的。</p></li><li><p>样本量足够大，最小的样本量要求分析中的任一单元<strong>格期望频数大于5</strong></p></li></ol><p>步骤：</p><ol type="1"><li>判断期望频数<ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>频率<span class="math inline">\(\rightarrow\)</span>交叉表</li><li>分组变量（自变量）放入行，观测变量（因变量）放入列</li><li>单元格<span class="math inline">\(\rightarrow\)</span>取消实测<span class="math inline">\(\rightarrow\)</span>选中期望</li><li>统计<span class="math inline">\(\rightarrow\)</span>选中卡方</li><li>观察输出的交叉表，发现每个单元格的数值都大于5即可、</li></ol></li><li>计算卡方值<ol type="1"><li>重复第1部分</li><li>单元格<span class="math inline">\(\rightarrow\)</span>取消期望<span class="math inline">\(\rightarrow\)</span>选中实测<span class="math inline">\(\rightarrow\)</span>列</li><li>组间比较（当分组变量类别大于2时可选）：单元格<span class="math inline">\(\rightarrow\)</span>z检验<span class="math inline">\(\rightarrow\)</span>调整p值</li><li>观察输出的卡方检验表，其中渐进显著性为p值</li><li>组间比较：观察输入的交叉表，其中计数会出现字母，字母不同表示该类别的差异具有统计学意义，反之则无。</li></ol></li></ol><h2 id="回归分析">回归分析</h2><div><p>graph LR 回归分析----&gt;线性回归 线性回归----&gt;一元线性回归 线性回归----&gt;多元线性回归 回归分析----&gt;非线性回归</p></div><p>联系：两者均为研究及测度两个或两个以上变量之间关系的方法。在实际工作中，一般先进行相关分析，计算相关系数，然后建立回归模型，最后用回归模型进行推算或预测。</p><p>区别：相关分析研究的都是随机变量，并且不分自变量与因变量，回归分析研究的变量要定义出自变量与因变量，并且自变量是确定的普通变量，因变量是随机变量。相关分析主要是描述两个变量之间相关关系的密切程度；回归分析不仅可以揭示变量x对变量y的影响程度，还可以根据回归模型进行预测。</p><h3 id="一元线性回归">一元线性回归</h3><blockquote><p>一元线性回归，就是回归模型中只含一个自变量，它主要用来处理一个自变量与一个因变量之间的线性关系。简单线性回归模型为：<span class="math inline">\(Y=a+bX+\varepsilon\)</span>，使用的时<strong>最小二乘法</strong> 式中： Y--因变量； X--自变量； a--常数项，是回归直线在纵坐标轴上的截距； b--回归系数，是回归直线的斜率； <span class="math inline">\(\varepsilon\)</span>--随机误差，即随机因素对因变量所产生的影响。</p></blockquote><p>前提：两变量为<strong>连续变量</strong>，两变量之间存在线性关系</p><ol type="1"><li><p>根据预测目标确定因变量</p></li><li><p>绘制散点图确定回归模型</p></li><li><p>估计模型参数，建立线性回归模型</p><ol type="1"><li>回归<span class="math inline">\(\rightarrow\)</span>线性<span class="math inline">\(\rightarrow\)</span>选择变量</li><li>图<span class="math inline">\(\rightarrow\)</span>Y：DEP，X：ZRE（标准化残差）<span class="math inline">\(\rightarrow\)</span>直方图，正态概率图</li><li>保存<span class="math inline">\(\rightarrow\)</span>预测值：未标准化，残差：标准化，距离：库克，杠杆（显示异常点），预测区间：平均值，单值</li><li>选项：使用F的概率默认，在方程中包含常量</li></ol></li><li><p>对模型进行检验</p><ol type="1"><li><p>除去变量表（除去没有相关性的变量）</p></li><li><p>线性回归模型汇总表：观察调整后R方</p><blockquote><p>R方：判定系数。 值为0~1之间，越接近1,预测值与观测值越接近。一般认为，<strong>R方大于0.75, 表示拟合程度很好</strong>，小于0.5,表示拟合有问题，不适合回归分析，R方介两者之间说明拟合程度一般。</p></blockquote></li><li><p>方差分析表ANOVA：观察显著性p值（通过F检验算出）</p></li><li><p>回归系数表：得到回归模型系数和常量，以及显著性p值（通过t检验算出）</p></li><li><p>观察残差直方图：因变量的残差值基本符合正态分布为好</p></li><li><p>观察残差正态p-p图：如果样本数据来自正态分布的话， 所有散点都应分布在对角线附近。说明样本数据比较正确。</p></li></ol></li></ol><h3 id="多元线性回归">多元线性回归</h3><p>前提：</p><ol type="1"><li>需要至少2个自变量，且自变量之间互相独立</li><li>因变量为为连续变量</li><li>数据具有<strong>方差齐性、无异常值和正态分布</strong>的特点</li><li>自变量间不存在多重共线性</li></ol><p>步骤：</p><ol type="1"><li><p>检验并去除异常值</p></li><li><p>检验是否为正态分布</p></li><li><p>检验方差齐性（莱文或者ANOVA）</p><ol type="1"><li><p>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>探索</p></li><li><p>设置因变量为预测变量，因子列表为自变量</p></li><li><p>图<span class="math inline">\(\rightarrow\)</span>因子级别并置，茎叶图，莱文未转换</p></li><li><p>观察莱文方差齐性检验的显著性p值是否大于0.05</p><blockquote><p>莱文检验原假设<span class="math inline">\(H_0\)</span>：各组方差相等，符合方差齐性</p></blockquote></li><li><p>分析<span class="math inline">\(\rightarrow\)</span>比较均值<span class="math inline">\(\rightarrow\)</span>单因素ANOVA检验</p></li><li><p>将预测变量设置为因变量，但需要注意的是，ANOVA检验无法将名义变量设为因子</p></li><li><p>选项<span class="math inline">\(\rightarrow\)</span>方差齐性检验</p></li><li><p>观察方差齐性检验的显著性p值是否大于0.05</p><blockquote><p>检验原假设<span class="math inline">\(H_0\)</span>：各组方差相等，符合方差齐性</p></blockquote></li></ol></li><li><p>检验多重共线性</p><ol type="1"><li><p>分析<span class="math inline">\(\rightarrow\)</span>回归<span class="math inline">\(\rightarrow\)</span>线性</p></li><li><p>输入自变量和因变量</p></li><li><p>统计<span class="math inline">\(\rightarrow\)</span>共线性诊断</p></li><li><p>关注系数表，当<span class="math inline">\(VIF\)</span>值大于等于10时，我们认为变量间存在严重的共线性。</p><p>当<span class="math inline">\(VIF\)</span>值小于10时，我们认为数据基本符合多元线性分析的假设，即不存在多重共线性问题。</p></li></ol></li><li><p>分析<span class="math inline">\(\rightarrow\)</span>回归<span class="math inline">\(\rightarrow\)</span>线性</p></li><li><p>填入自变量和因变量</p></li><li><p>统计</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622140830.jpeg" alt="img" / loading="lazy"><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>保存<span class="math inline">\(\rightarrow\)</span>预测值：未标准化，残差：学生化，学生化后删除，距离：库克，杠杆（显示异常点），包含协方差矩阵</p></li><li><p>对模型进行检验</p><ol type="1"><li>除去变量表（除去没有相关性的变量）</li><li>线性回归模型汇总表：观察调整后R方</li><li>方差分析表ANOVA：观察显著性p值（通过F检验算出）</li><li>回归系数表：得到回归模型系数和常量，以及显著性p值（通过t检验算出），以及VIF</li></ol></li><li><p>结果表述</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622143012.png" alt="image-20220622143012110" / loading="lazy"><figcaption aria-hidden="true">image-20220622143012110</figcaption></figure></li></ol><h3 id="多元线性逐步回归">多元线性逐步回归</h3><blockquote><p>逐步法结合向前法和向后法的优点，在向前引入每一个新自变量之后都要重新对已代入的自变量进行计算，以检验其有无继续保留在方程中的价值，并以此为依据进行自变量的引入和剔除交替进行，直到没有新的变量可以引入或剔除为止，此法较为准确。</p></blockquote><p>前提：同多元线性回归</p><ol type="1"><li><p>检验并去除异常值</p></li><li><p>检验是否为正态分布</p></li><li><p>检验方差齐性（莱文或者ANOVA）</p></li><li><p>检验多重共线性</p></li><li><p>分析<span class="math inline">\(\rightarrow\)</span>回归<span class="math inline">\(\rightarrow\)</span>线性</p></li><li><p>填入自变量和因变量，方法选择步进</p></li><li><p>统计：估算值，模型拟合，共线性诊断，德斌沃森残差分析</p></li><li><p>保存：学生化，杠杆值，协方差矩阵</p></li><li><p>对模型进行检验</p><ol type="1"><li>残差统计表：在满足假设后，我们还需要依据残差统计表中的库克距离（cook值）来判断数据有无强影响点，若库克距离的最大值大于1，则应检查数据是否存在的异常值；若库克距离的最大值小于1，则数据中不存在强影响点，可以进行下一步的分析。</li><li>模型纳入变量表：去除不重要的变量</li><li>模型摘要表：表下的注释可以看出逐步回归分析中每一步引入回归方程的自变量。观测调整后R方</li><li>ANOVA表：此检验的零假设是多重相关系数R=0。如果P&lt;0.05，就说明多重线性回归模型中至少有一个自变量的系数不为零。同时，回归模型有统计学意义也说明相较于空模型，纳入自变量有助于预测因变量；或说明该模型优于空模型。</li><li>回归模型系数表：显著性检验结果，当P&gt;0.05时，该自变量在本模型中没有统计学意义，应当在回归模型中删除相应变量；反之保留。</li></ol></li><li><p>表述</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622142941.png" alt="image-20220622142941884" / loading="lazy"><figcaption aria-hidden="true">image-20220622142941884</figcaption></figure></li></ol><h3 id="非线性回归">非线性回归</h3><ol type="1"><li>绘制散点图，大致确定关系</li><li>曲线估算<ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>回归<span class="math inline">\(\rightarrow\)</span>曲线估算</li><li>填入因变量和独立（自变量）</li><li>选择可能的模型</li><li>观察模型和参数估计表，有R方和显著性p值，选择R方优越的模型</li><li>根据参数估计值得到曲线表达式</li></ol></li></ol><h2 id="参考">参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNzAxMDY5NQ==&amp;mid=2247483917&amp;idx=1&amp;sn=8c2358dbf63fa5785bc7a0d0e8937932&amp;chksm=f99fe665cee86f73a702f1552a3589d6934e5263031624964b640521c8de71bae94838eff632&amp;scene=178&amp;cur_album_id=1354525438097539072#rd">SPSS多元线性回归分析</a></p><p><a href="https://www.bilibili.com/video/BV133411K7yd">2022校赛赛前培训SPSS基础</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;福州好热，暑假又要开模了呜呜呜我的CS呜呜呜。趁着训练前终于把打了一年的MHW煌黑龙和黑龙通了，芜湖~~&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622143315.png&quot; alt=&quot;image-20220622143314890&quot; /&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20220622143314890&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    <category term="数学建模" scheme="http://lapras.xyz/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="回归" scheme="http://lapras.xyz/tags/%E5%9B%9E%E5%BD%92/"/>
    
    <category term="数学" scheme="http://lapras.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="SPSS" scheme="http://lapras.xyz/tags/SPSS/"/>
    
  </entry>
  
  <entry>
    <title>SSH的二三事</title>
    <link href="http://lapras.xyz/2022/03/20/844ad6f8.html"/>
    <id>http://lapras.xyz/2022/03/20/844ad6f8.html</id>
    <published>2022-03-19T16:18:05.000Z</published>
    <updated>2022-03-21T04:56:29.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>来学校上了两周网课，两周线下，现在又要上网课了G！上网课就算了，我还要给学弟上网课哈哈。整一波虚拟教师V出道</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220320002327.jpg" alt="63476067_p0_master1200" style="zoom: 67%;" / loading="lazy"></p><span id="more"></span><h2 id="什么是ssh">什么是SSH</h2><blockquote><p>SSH（Secure Shell 的缩写）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。</p><p>实际使用中，它主要用于保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。</p></blockquote><p>比如我们都知道的 Github 下载源代码有两种方式，HTTPS 和 一种形如<code>git@github.com:username/repositoryname.git</code>的连接，这其实就是一种 SSH 协议。</p><p>再比如我们要操作机房里的服务器，不可能给每一台服务器都配上键盘鼠标显示器，一般都是通过网络的方式远程访问一台服务器。就类似于 TeamViewer 的远程桌面。</p><h3 id="安装ssh服务">安装SSH服务</h3><p>现在几乎所有的 Linux 发行版、Windows 以及 MacOS 基本都自带了<code>ssh</code>服务，其中绝大部分都是 OpenSSH ，这是一个关于实现 SSH-2 协议的开源项目，其中还包含了一些常用的辅助工具比如：<code>ssh-keygen</code>、<code>ssh-agent</code>、<code>scp</code>以及<code>sftp</code>。</p><p>所以绝大部分的电脑都是有<code>ssh</code>的，可以用<code>ssh -V</code>简单地查看一下。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#安装</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openssh-client<span class="token function">sudo</span> dnf <span class="token function">install</span> openssh-clients</code></pre><p>然后你就可以用<code>service</code>或者<code>systemctl</code>之类的开启<code>sshd</code>服务。</p><h2 id="ssh基础用法">SSH基础用法</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span> -p <span class="token punctuation">&#123;</span><span class="token number">22</span><span class="token punctuation">&#125;</span> <span class="token builtin class-name">command</span></code></pre><ul><li><code>remote_host</code>可以是一个 IP 地址，也可以是一个可被 DNS 解析的域名（Domain）。</li><li><code>ssh</code>除了可以登录之外，还可以在后面直接添加一条命令<code>command</code>，会返回命令的<code>STDOUT</code>。利用这个可以写一些脚本儿。</li><li><code>-p</code>制定了<code>ssh</code>服务的端口，默认都是22。</li><li>看看<code>config</code>以及<code>known_hosts</code></li></ul><h3 id="常用配置文件">常用配置文件</h3><p>SSH 客户端的全局配置文件是<code>/etc/ssh/ssh_config</code>，用户配置文件在<code>~/.ssh/config</code>，用户配置文件优先级更高</p><p>SSH 服务端的配置文件是<code>/etc/ssh/sshd_config</code></p><h4 id="config">config</h4><pre class="language-none"><code class="language-none">Host &#123;remoteserver&#125;     HostName &#123;remote_host&#125;     User &#123;username&#125;     Port 2222     IdentityFile ~&#x2F;.ssh&#x2F;id_rsa     ProxyCommand &#123;...&#125;Host *     Port 233     User root</code></pre><ul><li><code>Host *</code>匹配了所有的<code>remote_host</code>，也就是当所有匹配不成功的最后选项。后面的<code>Port</code>表示所有主机的默认连接端口都是233，<code>User</code>表示默认登录用户为 root 。</li><li><code>remoteserver</code>是<code>remote_host</code>的别名</li><li><code>IdentityFile</code>是指定用来登录验证的私钥文件，与<code>ssh -i &#123;path/to/id_rsa&#125;</code>的作用相同</li><li>还有一个<code>ProxyCommand</code>它大概有两个使用场景（原理都一样），一个是用代理进行<code>ssh</code>，另一个是使用跳板机（中转机）。这个我们后面的端口转发篇再说。 与<code>ssh -o "&#123;ProxyCommand&#125;"</code>作用相同，这里假设我要用本地的<code>Clash</code>7890端口做一个<code>socks5</code>协议的代理。</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#Windows 使用 git 自带的 connect 工具</span>ProxyCommand connect -S <span class="token number">127.0</span>.0.1:7890 %h %p<span class="token comment">#Linux 使用 netcat 也就是 nc 工具</span>ProxyCommand <span class="token function">nc</span> -X <span class="token number">5</span> -x <span class="token number">127.0</span>.0.1:7890 %h %p</code></pre><ul><li><code>%p</code>和<code>%h</code>分别是<code>ssh</code>的端口号以及<code>remote_host</code></li><li><code>connect</code><ul><li><code>-S</code>和<code>-H</code>分别是<code>socks</code>和<code>HTTPS</code>代理</li></ul></li><li><code>nc</code><ul><li><code>-X 5</code>指定代理协议为<code>socks 5</code>，如果是<code>HTTPS</code>代理则为<code>-X connect</code></li><li><code>-x</code>指定代理的主机地址和端口</li></ul></li></ul><p>登录之后可以用<code>who -a</code>查看一下登录的 IP 是否是你的代理服务器 IP。</p><p>当你用<code>ssh</code>成功登录一次后，会自动在<code>config</code>文件中生成对应的配置文件，<code>IdentityFile</code>默认缺省。这样，以后我们<code>ssh</code>一个已经在<code>config</code>中的主机的时候，可以直接<code>ssh remoteserver</code>登录，而不需要写一串命令。</p><h4 id="sshd_config">sshd_config</h4><ul><li><strong>Port</strong>：建议改为非22的LuckyNumber，防止被扫端口弱口令爆破。</li><li><strong>PermitRootLogin</strong>：是否允许 root 账号直接登录。设置为 no 可以有效防止自己<code>rm -rf /</code>的欲望</li><li><strong>PermitEmptyPasswords</strong>：是否允许空密码登录。如果设置为 yes 并且登录的用户密码为空，则可以使用这个用户免密码登录。</li><li><strong>PasswordAuthentication</strong>：是否允许密码登录。如果设置为 no 可以增加安全性。</li><li><strong>PrintMotd</strong>： 打印登录提示信息，提示信息存储在/etc/moed文件中</li><li>更改配置项后，记得重启<code>sshd</code>服务</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl restart sshd.service</code></pre><h3 id="公私钥的概念">公私钥的概念</h3><p>上面我们使用<code>ssh</code>的时候每一次登录都需要输入密码，这并不安全，其次非常麻烦。<code>ssh</code>鼓励用户使用非对称加密的<strong>公私钥验证</strong>来进行登录，而不是使用密码。所谓的<strong>公私钥验证</strong>，本质上是一套加密算法生成出的一对RSA<strong>公钥</strong>和<strong>私钥</strong>。其中<strong>私钥</strong>自行保存，而<strong>公钥</strong>可以用来放在远程的服务器上。这样当远程的服务器接收到来自由你私钥发出的命令后，会使用之前存放的公钥进行认证。免去了在网络明文使用密码传输的风险。在<code>ssh</code>中，我们可以使用<code>ssh-keygen</code>来生成一对公私钥。</p><ul><li>小试一下（使用<code>ssh-keygen</code>生成并查看）</li><li><code>ssh-keygen</code>除了用来生成密钥，还可以用来删除失效变更的公钥指纹（known_hosts），这通常发生在远程服务器出于某些原因被重置了。</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-keygen -R <span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span></code></pre><h3 id="上传ssh公钥的三种姿势">上传SSH公钥的三种姿势</h3><p>上传公钥的最终目的是在你要登录用户的<code>~/.ssh/authorized_keys</code>文件中追加你的<strong>公钥文本</strong>。如果目标用户没有这个文件，需要先自行创建，并修改对应的<strong>权限</strong>，否则<code>ssh</code>不会信任你的公钥。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token number">600</span> ~/.ssh/authorized_keys<span class="token function">chmod</span> <span class="token number">700</span> ~/.ssh</code></pre><h4 id="manualsimulation">ManualSimulation</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/.ssh<span class="token function">touch</span> ~/.ssh/authorized_keys<span class="token function">vim</span> ~/.ssh/authorized_keys<span class="token comment">#把公钥复制粘贴进去</span></code></pre><p>当然，如果你熟悉管道运算符，你还可以一句话搞定</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub <span class="token operator">|</span> <span class="token function">ssh</span> <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span> <span class="token string">"mkdir -p ~/.ssh &amp;&amp; cat >> ~/.ssh/authorized_keys"</span></code></pre><h4 id="scp">scp</h4><p><code>scp</code>是 SSH 提供的一个客户端程序，用来在两台主机之间加密传送文件（即复制文件）。其用法和<code>cp</code>类似。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> ~/.ssh/id_rsa.pub <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span>:~/<span class="token function">ssh</span> <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span> <span class="token string">"cat ~/id_rsa.pub >> ~/.ssh/authorized_keys"</span><span class="token function">rm</span> ~/id_rsa.pub<span class="token comment"># 或者</span><span class="token function">scp</span> ~/.ssh/id_rsa.pub <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span>:~/.ssh/authorized_keys</code></pre><h4 id="ssh-copy-id">ssh-copy-id</h4><p>OpenSSH 自带一个<code>ssh-copy-id</code>命令，可以自动将公钥拷贝到远程服务器的<code>~/.ssh/authorized_keys</code>文件。如果<code>~/.ssh/authorized_keys</code>文件不存在，<code>ssh-copy-id</code>命令会自动创建该文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-copy-id -i key_file user@host</code></pre><ul><li>注意，<code>ssh-copy-id</code>是直接将公钥添加到<code>authorized_keys</code>文件的末尾。如果<code>authorized_keys</code>文件的末尾不是一个换行符，会导致新的公钥添加到前一个公钥的末尾，两个公钥连在一起，使得它们都无法生效。所以，如果<code>authorized_keys</code>文件已经存在，使用<code>ssh-copy-id</code>命令之前，务必保证<code>authorized_keys</code>文件的末尾是换行符（假设该文件已经存在）。</li></ul><h2 id="ssh端口转发">SSH端口转发</h2><blockquote><p>SSH 除了登录服务器，还有一大用途，就是作为加密通信的中介，充当两台服务器之间的通信加密跳板，使得原本不加密的通信变成加密通信。这个功能称为端口转发（port forwarding），又称 SSH 隧道（tunnel）。</p><p>端口转发有两个主要作用：</p><p>（1）将不加密的数据放在 SSH 安全连接里面传输，使得原本不安全的网络服务增加了安全性，比如通过端口转发访问 Telnet、FTP 等明文服务，数据传输就都会加密。</p><p>（2）作为数据通信的加密跳板，绕过网络防火墙。</p></blockquote><h3 id="本地转发正向转发">本地转发（正向转发）</h3><p>把远程服务器的端口映射到本地，绕过防火墙和安全组的限制。比如我在远程服务器的8888端口运行了一个不知名的 Web 应用，如果我要在公网临时查看他的部署结果，毕竟远程服务器一般情况下是没有<code>GUI</code>的，那么我必须开防火墙和安全组让这个端口暴露在公网，完事后还得再关上，比较麻烦。那么就可以使用<code>ssh</code>本地转发。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -L <span class="token punctuation">[</span>local-remote:<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>local-port<span class="token punctuation">&#125;</span>:<span class="token punctuation">&#123;</span>target-host<span class="token punctuation">&#125;</span>:<span class="token punctuation">&#123;</span>target-port<span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>tunnel-host<span class="token punctuation">&#125;</span></code></pre><ul><li><code>local-remote</code>缺省为本机</li><li><code>tunnel-host</code>就是一句能正常登陆你的远程服务器的<code>ssh</code>连接语句</li><li><code>local-port</code>是映射到本地的某个端口</li><li><code>target-host</code>为最终的<code>remote_host</code>，如果是访问<code>tunnel-host</code>的服务，则为<code>localhost</code>，要不就是某个内网机器的 host 地址</li><li><code>target-port</code>为最终的<code>remote_host</code>的端口号，也就是服务真正所在的端口</li></ul><p>当然，你也可以使用万能的 <strong>VSCode</strong> 直接一键转发。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220319224716.png" alt="image-20220319224707914" / loading="lazy"><figcaption aria-hidden="true">image-20220319224707914</figcaption></figure><h3 id="远程转发反向转发">远程转发（反向转发）</h3><p><strong>WARNING！反向转发有一定风险</strong></p><p>把本地的某个端口映射到远程服务器，这个应用场景也很常见，比如我在宿舍的机子上跑了一个不知名的 WEB Docker 容器，但是校园网是经过 <strong>NAT</strong> 没有所谓的公网IP，这样在校外就无法访问到我的应用。那么就可以使用<code>ssh</code>远程转发，这样我就可以通过访问具有公网IP的远程服务器的某个端口访问到我的应用。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -R <span class="token punctuation">[</span>remote-host:<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>remote-port<span class="token punctuation">&#125;</span>:<span class="token punctuation">&#123;</span>target-host<span class="token punctuation">&#125;</span>:<span class="token punctuation">&#123;</span>target-port<span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>tunnel-host<span class="token punctuation">&#125;</span></code></pre><ul><li><code>remote-host</code>缺省为<code>tunnel-host</code>的<code>localhost</code>。如果你想让应用被公网任意地址访问，需要更改为<code>0.0.0.0</code>，否则只能被远程机器用<code>localhost</code>访问，就完全相当于正向转发的逆向了。</li><li><code>remote-port</code>是映射到远程服务器的某个端口，记得打开对应防火墙和安全组</li><li><code>target-host</code>是应用所在的 host ，本地就是<code>localhost</code></li><li><code>target-port</code>是服务真正所在的端口</li></ul><p>但是<code>ssh</code>默认配置的情况下，哪怕你改了<code>remote-host</code>为<code>0.0.0.0</code>也不会让你进行一个公网的访问，这是出于安全考量的。</p><p>如果你使用<code>-v</code>查看的话，就会发现一个警告<code>Remote: Forwarding listen address "192.168.1.1" overridden by server GatewayPorts</code></p><p>so，若果想要开启，需要更改<code>~/.ssh/config</code>的<code>GatewayPorts</code>为yes</p><h3 id="tips">Tips</h3><ol type="1"><li>反向转发注意安全</li><li>可以使用<code>-f</code>后台执行</li><li>可以使用<code>-N</code>不进入ssh交互命令行模式</li><li>通过<code>ssh</code>进行端口转发其实并不稳定，想要构建稳定的端口转发可以了解<code>autossh</code>或者<code>frp</code></li></ol><h2 id="参考">参考</h2><p>https://wangdoc.com/ssh/basic.html</p><p>https://kanda.me/2019/07/01/ssh-over-http-or-socks/</p><p>https://abcdabcd987.com/ssh/</p><p>https://www.cnblogs.com/bonelee/p/12511024.html</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;来学校上了两周网课，两周线下，现在又要上网课了G！上网课就算了，我还要给学弟上网课哈哈。整一波虚拟教师V出道&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220320002327.jpg&quot; alt=&quot;63476067_p0_master1200&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="项目经历" scheme="http://lapras.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="教程" scheme="http://lapras.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="网络" scheme="http://lapras.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>浅谈贝叶斯定理</title>
    <link href="http://lapras.xyz/2022/02/28/8fd34f7b.html"/>
    <id>http://lapras.xyz/2022/02/28/8fd34f7b.html</id>
    <published>2022-02-28T11:03:59.000Z</published>
    <updated>2022-06-26T13:42:13.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>恍恍惚惚，大二下开始学习概率论了，G！</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220228195301.jpg" alt="95841206_p0" / loading="lazy"><figcaption aria-hidden="true">95841206_p0</figcaption></figure><span id="more"></span><h3 id="引例">引例</h3><p>上完了九年义务制教育的朋友们大多知道什么叫概率，再不济也知道古典概型无非就是从有限的盒子里等可能地去摸球。概率嘛，无非就是可能除以总数（X）。好，那让我们来看看下面这个问题：</p><blockquote><p>假设某种疾病在所有人群中的感染率是1%，医院现有的技术对于该疾病检测的灵敏度(Sensitivity)为90%，这意味着100个确诊的人中有10名将会是误诊的。而技术的特异度（Specificity）为91%，这意味着100名健康的人群中会有9人误诊。</p><p>好的，现在请思考一下，假设我们对1000名人员进行该医学检测，而你不幸被检测为阳性（患病），请问你患病的几率大概是多少呢？</p></blockquote><ol type="A"><li><span class="math inline">\(9\over 10\)</span> B.<span class="math inline">\(8\over10\)</span> C.<span class="math inline">\(1\over 10\)</span> D.<span class="math inline">\(1\over 100\)</span></li></ol><p><strong>答案在分割线下！！！</strong></p><hr /><p>嘿嘿，答案是<strong>C</strong>。</p><p>真是奇怪，明明这么高的灵敏度，为什么患病的几率反而如此之低ne？这其实就是一种反直觉的现象。现在让我们一起算一下这题。</p><p>1000个人中的感染率为1%，也就是有10个人是真正的患者，检测的灵敏度为90%，换言之误诊率为10%。这意味着我们会检测出其中的9名真正的患者和1名误诊的。而91%的特异度将会为我们带来 <span class="math display">\[(1000-10)*(1-91\%)\approx89\]</span> 89名误诊！接着用我们都会的条件概率进行简单地计算 <span class="math display">\[P(confirm\,Patient|Patient)=\tfrac{9}{9+89}=0.091\]</span> 不到十分之一的概率为真正的患者，That's so ridiculous。其实不难发现，这里的假阳性比阳性的还要多。</p><h3 id="谬">“谬”</h3><p>这里引用<span class="math inline">\(3b1b\)</span>大佬的话，我们算出的概率并不能体现你患病的几率，正确的观点是我们算出的概率<strong>更新</strong>了你患病的几率。</p><p>这里就可以引出先验概率的概念</p><blockquote><p>先验概率（prior probability）是指根据以往经验和分析得到的概率，如全概率公式，它往往作为"由因求果"问题中的"因"出现的概率。</p></blockquote><p>显然，原本的先验概率为人群中的感染率也就是1%。而检测的值<strong>更新</strong>了这一概率，将概率增加了一个数量级。但这并不是我们想要的答案。在本题中我们只关心检测出为阳性时的情况倾向。 <span class="math display">\[\tfrac{Sensitivity}{1-Specificity}=10\]</span> 这就是似然比(likelihood ratio)，也叫做贝叶斯因子。这里有个著名的经验公式，贝叶斯推断。用于更新<strong>较小的先验概率</strong>。在本例中，先验概率为1%，乘以贝叶斯因子后结果为 0.1 接近了正确答案 0.091。</p><p>再举个例子，将上面的条件由1000人换到100人，患病率由1%换成10%。这意味着我们将有10名确诊（9名真患者，1名误诊），90名正常（8人逃脱，81名正常）。但是我们的似然比保持不变为10。 <span class="math display">\[P(confirm\,Patient|Patient)=\tfrac{9}{9+8}\approx 53\%\]</span> 显然在先验概率过大的情况下随意使用经验公式，会出问题。但事实上，之所以只能在较小的先验概率中使用，是因为他的原型为更新比率而非更新概率。比如50%的概率，他的比率为 1:1。所以真正的贝叶斯公式，<strong>是将先验概率以比率的形式被贝叶斯因子更新。</strong></p><p>回到最开始的条件，先验概率为 1%，比率形式为 1:99，然后用贝叶斯因子更新为 10:99 也就是 10/109 的概率，与我们计算的答案别无二致。</p><p>同样的，当先验概率为10%，比率形式为 1:9 ，更新后为 10:9 也就是 10/19 的概率，正好是 53%。</p><p>回到，我们一开始的问题。给予人们这种错觉的原因往往是条件概率的认知不清。当我们在说准确率为99%准确性的测试的时候，表示的是 <strong>已知一个人得病(B)的情况下检测出阳性(A)的概率</strong>。即 <span class="math inline">\(P(A|B)\)</span>，而人人往往将其等同于 <strong>一个人在检测出阳性(A)的情况下得病(B)的概率</strong>。即<span class="math inline">\(P(B|A)\)</span>。那么，有没有一种………</p><h3 id="贝叶斯">贝叶斯</h3><p>贝叶斯是一种已知结果B反求因A的思想。下面举个例子：</p><div><p>graph TB A1(A1)--&gt;B(B) A2(A2)--&gt;B(B) A3(A3)--&gt;B(B)</p></div><p>显然这里有三条路径来完成整件事情，对于第一条路径 A1-&gt;B 而言： <span class="math display">\[P_1=P(A1)*P(B|A1)\]</span> 同样的，我们可以得到 <span class="math inline">\(P2\)</span> 和 <span class="math inline">\(P3\)</span> ，而他们的求和正好就是B的全概率公式，也是贝叶斯公式的分母。</p><p>那么现在我们求的<strong>因</strong>，也就是其中一条路径在全部路径中的概率，问题就是一个简单的<strong>类古典概型</strong>了。</p><p>给出我们的通式： <span class="math display">\[P(A|B)=\frac{P(B|A)*P(A)}{P(B|A)*P(A)+P(B|A^c)*P(A^c)}\]</span></p><ul><li>这里的<span class="math inline">\(A^c\)</span>是A的对立事件</li><li>分母为<span class="math inline">\(P(B)\)</span>的全概率公式</li></ul><h3 id="参考">参考</h3><p><a href="https://zhuanlan.zhihu.com/p/22467549">Think Bayes</a></p><p><a href="https://www.youtube.com/watch?v=lG4VkPoG3ko">The medical test paradox, and redesigning Bayes' rule</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;恍恍惚惚，大二下开始学习概率论了，G！&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220228195301.jpg&quot; alt=&quot;95841206_p0&quot; /&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;95841206_p0&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    
    <category term="数学" scheme="http://lapras.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>信息茧房脱出-自建RSS</title>
    <link href="http://lapras.xyz/2021/12/15/3db8db5b.html"/>
    <id>http://lapras.xyz/2021/12/15/3db8db5b.html</id>
    <published>2021-12-15T03:37:57.000Z</published>
    <updated>2021-12-16T09:44:47.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>RSS，也就是 Rich Summary Site 。这玩意儿有点时代的眼泪的感觉了。在推荐算法大行其道的当下，RSS本身是一种逆潮流的选择。加之国区对于RSS应用的监管力度之大致使很多优秀的RSS服务在国内被和谐。</p><p>我之前一直使用的是 feeder.co 无奈他的 IPAD 应用不仅要 Dollar，还锁了国区。所以选择折腾一手，自建RSS。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216172339.jpeg" alt="img" style="zoom:67%;" / loading="lazy"></p><span id="more"></span><h2 id="miniflux">Miniflux</h2><p><a href="https://miniflux.app/">Miniflux</a> 是一个免费开源的RSS聚合源，与另一个开源的 <a href="https://tt-rss.org/">TTRSS</a> 相比，它的极简设计风格，深的我心（虽然默认UI都差不多丑）。</p><p>然后 Miniflux 是基于<code>GO</code>的，没有其他奇奇怪怪的依赖项。</p><h3 id="部署">部署</h3><p>如果你没有 Docker 以及 Docker-compose，请立即安装并学习。</p><p><a href="https://vuepress.mirror.docker-practice.com/">Docker 从入门到实践</a></p><ol type="1"><li>新建一个 miniflux 目录</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/miniflux <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> ~/miniflux</code></pre><ol start="2" type="1"><li>创建并修改 <code>docker-compose.yml</code></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">miniflux</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> miniflux/miniflux<span class="token punctuation">:</span>latest    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"&lt;端口>:8080"</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> db    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> DATABASE_URL=postgres<span class="token punctuation">:</span>//miniflux<span class="token punctuation">:</span>&lt;数据库密码<span class="token punctuation">></span>@db/miniflux<span class="token punctuation">?</span>sslmode=disable      <span class="token punctuation">-</span> RUN_MIGRATIONS=1      <span class="token punctuation">-</span> CREATE_ADMIN=1      <span class="token punctuation">-</span> ADMIN_USERNAME=&lt;Miniflux管理员用户名<span class="token punctuation">></span>      <span class="token punctuation">-</span> ADMIN_PASSWORD=&lt;Miniflux管理员密码<span class="token punctuation">></span>  <span class="token key atrule">db</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span class="token punctuation">:</span>latest    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> POSTGRES_USER=miniflux      <span class="token punctuation">-</span> POSTGRES_PASSWORD=&lt;数据库密码<span class="token punctuation">></span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> miniflux<span class="token punctuation">-</span>db<span class="token punctuation">:</span>/var/lib/postgresql/data<span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">miniflux-db</span><span class="token punctuation">:</span> </code></pre><ul><li>自行修改上述带有<code>&lt;&gt;</code>的选项</li></ul><ol start="3" type="1"><li>启动 Miniflux</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> up -d</code></pre><p>访问 <code>localhost:&lt;端口&gt;</code> 进入 Miniflux 的管理页面说明大成功，然后就可以开启相应的防火墙，让外网也可以访问。</p><h2 id="rsshub">RssHub</h2><p>Miniflux 充当的角色是个<strong>聚合的订阅源</strong>，那么源本身从哪里来呢？别人整合的固然方便，但是自定义程度肯定不如自己来得爽。但是有些网站或者博客根本没有做 RSS 订阅（<del>比如我</del>）</p><blockquote><p>RSSHub 是一个开源、简单易用、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。RSSHub 借助于开源社区的力量快速发展中，目前已适配数百家网站的上千项内容</p><p>可以配合浏览器扩展 <a href="https://github.com/DIYgod/RSSHub-Radar">RSSHub Radar (opens new window)</a>和 移动端辅助 App <a href="https://github.com/Cay-Zhang/RSSBud">RSSBud (opens new window)</a>(iOS) 与 <a href="https://github.com/LeetaoGoooo/RSSAid">RSSAid (opens new window)</a>(Android) 食用</p></blockquote><h3 id="使用">使用</h3><p>最常用的场景就是下载一个浏览器插件，他会自动嗅探当前网页，如果有符合的路由规则（来自于开源社区的支持），他会自动帮你生成一个 RSS 源，同时支持一键导入到你的聚合源（在设置界面中添加Miniflux的地址）。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216165507.png" alt="image-20211216165506944" style="zoom:67%;" / loading="lazy"></p><h3 id="部署-1">部署</h3><p>RSSHub默认可以使用官方提供的服务器服务，但出于反爬以及稳定性的考量，还是建议我们选择自建服务。</p><del>如果你没有Docker以及Docker-compose，请立即安装并学习。</del><p>运行下面的命令下载 RSSHub 镜像</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> pull diygod/rsshub</code></pre><p>然后运行</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -d --name rsshub -p <span class="token number">1200</span>:1200 diygod/rsshub</code></pre><h3 id="添加配置">添加配置</h3><p>配置运行在 docker 中的 RSSHub，最便利的方法是使用 docker 环境变量</p><p>以设置缓存时间为 1 小时举例，只需要在运行时增加参数：<code>-e CACHE_EXPIRE=3600</code></p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -d --name rsshub -p <span class="token number">1200</span>:1200 -e <span class="token assign-left variable">CACHE_EXPIRE</span><span class="token operator">=</span><span class="token number">3600</span> </code></pre><p>更多配置项请看 <a href="https://docs.rsshub.app/install/#pei-zhi">官方文档</a></p><h3 id="使用-1">使用</h3><p>同样的，在部署成功之后访问对应的地址。（记得打开防火墙）</p><p>然后就可以在 RSSHub Rader 等的设置页面，使用自定义 RSSHub域名</p><h2 id="阅读器推荐">阅读器推荐</h2><p>说了这么多，总得来点读的，考虑到我的使用场景，所以没有找IOS或者Android的阅读器。</p><h3 id="win10win11">win10&amp;win11</h3><p>推荐国人大佬 云之幻 制作的<a href="https://www.microsoft.com/zh-cn/p/rss-%E8%BF%BD%E8%B8%AA/9n85pv1rjd6v">RSS追踪</a>，界面充分体现了UWP应用一贯的极简且平滑的设计理念👍。</p><blockquote><p>集成多种主流RSS服务的原生UWP阅读器，通过在线服务，你可以实现多端同步。经过全新设计的UI与强化后的功能，是Windows端一个不错的RSS阅读选择</p></blockquote><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216170732.jpeg" alt="img" style="zoom:67%;" / loading="lazy"></p><p>这里选择Fever模式</p><p>进入Miniflux的后台，在设置中打开Fever插件，设置用户名密码后。即可用 <code>http://IP:minifluxport/fever/</code> 的方式导入</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216171232.png" alt="image-20211216171231808" style="zoom:67%;" / loading="lazy"></p><p>总之就是清爽😎</p><h3 id="ipados">ipadOS</h3><p>APPStore 个人觉得最好用的 Feeder 5 已经从国区下架了，国人团队做的 Ego Reader 体验也不错。可惜横屏适配问题一直没有解决。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216172758.jpg" alt="img" style="zoom:67%;" / loading="lazy"></p><h2 id="踩坑">踩坑</h2><h3 id="v2raya代理问题">V2rayA代理问题</h3><p>可能因为<code>/etc/resolv.conf</code>被V2rayA自动修改成本地的53端口来进行<code>redirect</code>透明代理，导致docker内容器出现ping不通，curl不了的问题。经过以下三个步骤，我把docker容器都设置为走V2rayA的代理模式了。</p><ol type="1"><li>重新用docker部署了一遍V2rayA</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># run v2raya</span><span class="token function">docker</span> run -d <span class="token punctuation">\</span>  --restart<span class="token operator">=</span>always <span class="token punctuation">\</span>  --privileged <span class="token punctuation">\</span>  --network<span class="token operator">=</span>host <span class="token punctuation">\</span>  --name v2raya <span class="token punctuation">\</span>  -e <span class="token assign-left variable">V2RAYA_ADDRESS</span><span class="token operator">=</span><span class="token number">0.0</span>.0.0:2017 <span class="token punctuation">\</span>      -v /lib/modules:/lib/modules <span class="token punctuation">\</span>  -v /etc/resolv.conf:/etc/resolv.conf <span class="token punctuation">\</span>  -v /etc/v2raya:/etc/v2raya <span class="token punctuation">\</span>  mzz2017/v2raya</code></pre><ol start="2" type="1"><li>设置<code>~/.docker/config.json</code></li></ol><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"proxies"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"default"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"httpProxy"</span><span class="token operator">:</span> <span class="token string">"http://192.168.1.5:20172"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><code>192.168.1.5</code>是我自定义的docker0 inet，请使用<code>ifconfig</code>或者<code>ip a</code>，自行查看<code>docker0</code>的inet</li><li>20172是我的V2RayA的HTTP分流端口</li></ul><ol start="3" type="1"><li>我的V2rayA的设置</li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216160732.png" alt="image-20211216160732519" style="zoom:50%;" / loading="lazy"></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216160830.png" alt="image-20211216160829968" style="zoom: 67%;" / loading="lazy"></p><h2 id="参考">参考</h2><p><a href="https://miniflux.app/">Miniflux</a></p><p><a href="https://docs.rsshub.app/">RSSHub</a></p><p><a href="https://hydrotho.github.io/Miniflux-Build-Guide/">利用 Miniflux 自建 RSS</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;RSS，也就是 Rich Summary Site 。这玩意儿有点时代的眼泪的感觉了。在推荐算法大行其道的当下，RSS本身是一种逆潮流的选择。加之国区对于RSS应用的监管力度之大致使很多优秀的RSS服务在国内被和谐。&lt;/p&gt;
&lt;p&gt;我之前一直使用的是 feeder.co 无奈他的 IPAD 应用不仅要 Dollar，还锁了国区。所以选择折腾一手，自建RSS。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216172339.jpeg&quot; alt=&quot;img&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="分享" scheme="http://lapras.xyz/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="教程" scheme="http://lapras.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的算法-最短路问题</title>
    <link href="http://lapras.xyz/2021/12/07/adfa5e63.html"/>
    <id>http://lapras.xyz/2021/12/07/adfa5e63.html</id>
    <published>2021-12-07T09:51:02.000Z</published>
    <updated>2022-06-14T06:10:07.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>呜呜呜，考试月要来li</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211207175750.png" style="zoom:50%;" / loading="lazy"></p><span id="more"></span><h2 id="单源最短路">单源最短路</h2><p><strong>最短路径</strong>问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。</p><h3 id="形式">形式</h3><ul><li><strong>确定起点的最短路径问题</strong> - 也叫单源最短路问题，即已知起始结点，求最短路径的问题。在边权非负时适合使用<a href="https://zh.wikipedia.org/wiki/Dijkstra算法">Dijkstra算法</a>，若边权为负时则适合使用<a href="https://zh.wikipedia.org/wiki/Bellman-ford">Bellman-ford算法</a>或者<a href="https://zh.wikipedia.org/wiki/SPFA算法">SPFA算法</a>。</li><li><strong>确定终点的最短路径问题</strong> - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在<a href="https://zh.wikipedia.org/wiki/無向圖">无向图</a>中该问题与确定起点的问题完全等同，在<a href="https://zh.wikipedia.org/wiki/有向图">有向图</a>中该问题等同于把所有路径方向反转的确定起点的问题。</li><li><strong>确定起点终点的最短路径问题</strong> - 即已知起点和终点，求两结点之间的最短路径。</li><li><strong>全局最短路径问题</strong> - 也叫多源最短路问题，求图中所有的最短路径。适合使用<a href="https://zh.wikipedia.org/wiki/Floyd-Warshall算法">Floyd-Warshall算法</a>。</li></ul><h3 id="性质">性质</h3><ul><li>对于边权为正的图，最短路不会经过重复的结点与边</li><li>对于边权为正的图，最短路的结点数不会超过<span class="math inline">\(n\)</span>，边数不会超过<span class="math inline">\(n-1\)</span></li><li><strong>负圈</strong>：总边权值小于零的环，存在负圈时会导致某些算法死循环。</li></ul><h3 id="一些约定">一些约定</h3><ul><li><span class="math inline">\(n\)</span>为结点数，<span class="math inline">\(m\)</span>为边数</li><li><span class="math inline">\(s\)</span>为最短路的起始点</li><li><span class="math inline">\(dis(u)\)</span>为<span class="math inline">\(s\)</span>点到<span class="math inline">\(u\)</span>点的<strong>动态最短路长度</strong></li><li><span class="math inline">\(w(u,v)\)</span>为<span class="math inline">\((u,v)\)</span>的边权</li></ul><h3 id="松弛操作">松弛操作</h3><p>由于最短路的算法，大部分的都有用到松弛（relax）操作，所以这里先理清楚。</p><p>最短路径的估计值（<span class="math inline">\(dis\)</span>）起初是被高估的（初始化为<span class="math inline">\(INF\)</span>），就好像一个被拉长的弹簧。但事实上，我们可以找到更短的路径来替代这个弹簧，导致弹簧不再紧绷，而是放松下来，不断更新，最终找到最短路径。其实就是一种动态规划的思想。</p><p>公式：对于边<span class="math inline">\((u,v)\)</span>，有<span class="math inline">\(dis(v)=min(dis(v),dis(u)+w(u,v))\)</span></p><h2 id="floyd-warshall">Floyd-Warshall</h2><h3 id="思想">思想</h3><p>求两点<span class="math inline">\(i，j\)</span>之间的的距离，可以分成两种情况考虑。即经过某个点<span class="math inline">\(k\)</span>，或者不经过某个点<span class="math inline">\(k\)</span>，然后就取两者中的较短路径，最终得到最短路径。<del>就是动态规划</del>。那么，记<span class="math inline">\(f(x,y)\)</span>为x到y的最短路径长度，可以得到</p><p>​ <span class="math inline">\(f(x,y)=min(f(x,y),f(x,k)+f(k,y))\)</span></p><h3 id="实现">实现</h3><p>使用邻接矩阵<span class="math inline">\(G\)</span>储存图，初始化为<span class="math inline">\(INF\)</span>。</p><pre class="language-none"><code class="language-none">初始化：    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            if (i &#x3D;&#x3D; j) d[i][j] &#x3D; 0;            else d[i][j] &#x3D; INF;&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离void floyd()&#123;    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);&#125;</code></pre><h3 id="细节">细节</h3><ul><li>显然是<span class="math inline">\(O(n^3)\)</span></li><li>可以得到图上所有点到所有点的最短路<span class="math inline">\(d[i][j]\)</span></li><li>不难发现，<span class="math inline">\(d[i][i]\)</span>最后的值为，从<span class="math inline">\(i\)</span>出发到<span class="math inline">\(i\)</span>的最短路径，也就是出去绕一圈回来的路径</li><li>利用上述条件，Floyd算法可以快速判断图中是否存在<strong>负圈</strong>，也就是判断<span class="math inline">\(diag(d)\)</span>是否存在小于0的值</li></ul><h2 id="bellman-ford">Bellman-Ford</h2><h3 id="思想-1">思想</h3><p>不断尝试对图上的每一条边进行<strong>松弛操作</strong>，直到一次循环结束，没有边进行松弛操作为止。</p><h3 id="实现-1">实现</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">edges</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> v<span class="token punctuation">;</span>  <span class="token keyword">int</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>edges<span class="token operator">></span> e<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">bellmanford</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">fill_n</span><span class="token punctuation">(</span>dis<span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>INF<span class="token punctuation">)</span><span class="token punctuation">;</span>  dis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">></span> n<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"存在负圈!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> u <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> u<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">.</span>v<span class="token punctuation">]</span> <span class="token operator">></span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> i<span class="token punctuation">.</span>w<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>          dis<span class="token punctuation">[</span>i<span class="token punctuation">.</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> i<span class="token punctuation">.</span>w<span class="token punctuation">;</span>          flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="细节-1">细节</h3><ul><li>每次循环遍历边的复杂度显然是<span class="math inline">\(O(m)\)</span>。每进行一次松弛，则会让最短路的边数+1，而最短边的上限为<span class="math inline">\(n-1\)</span>，所以为<span class="math inline">\(O(nm)\)</span></li><li>Bellman算法从<span class="math inline">\(s\)</span>出发，如果抵达一个负环，松弛操作会无限进行下去，但是由于最短路边数存在上限<span class="math inline">\(n-1\)</span>，所以也可以快速判断<strong>负圈</strong></li><li>上述结论其实不大严谨</li></ul><blockquote><p>负环判断中存在的常见误区</p><p>需要注意的是，以S点为源点跑 Bellman-Ford 算法时，如果没有给出存在负环的结果，只能说明从S点出发不能抵达一个负环，而不能说明图上不存在负环。</p><p>因此如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为 0 的边，然后以超级源点为起点执行 Bellman-Ford 算法。</p></blockquote><h3 id="优化">优化</h3><p>根据前面的思想可以知道，计算和调整结点<span class="math inline">\(u\)</span>到结点<span class="math inline">\(s\)</span>的最短距离后，如果紧接着调整<span class="math inline">\(u\)</span>的邻居结点，势必会触发新的<strong>松弛操作</strong>，而Bellman算法，则在尝试大量不相关结点的边松弛操作，这显然是低效的。</p><p>因此，在计算结点<span class="math inline">\(u\)</span>之后，下一部只计算和调整它的邻居节点，这样就能大幅度加快收敛的过程。而这显然类似于<span class="math inline">\(BFS\)</span>，所以不难想到用队列进行操作，而这就是<del>被广为诟病的</del>SPFA。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">edge</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> e<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">SPFA</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">fill_n</span><span class="token punctuation">(</span>dis<span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>INF<span class="token punctuation">)</span><span class="token punctuation">;</span>  dis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> v <span class="token operator">=</span> i<span class="token punctuation">.</span>v<span class="token punctuation">,</span> w <span class="token operator">=</span> i<span class="token punctuation">.</span>w<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">></span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">;</span>        cnt<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 记录最短路经过的边数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">>=</span> n<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>          <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"存在负圈"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>          q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>SPFA并不稳定，其最坏情况同样也是O(nm)</li></ul><h2 id="dijkstra">Dijkstra</h2><h3 id="思想-2">思想</h3><p>将结点分成两个集合，<span class="math inline">\(S\)</span>（已确定最短路长度的点集）， <span class="math inline">\(T\)</span>（未确定最短路长度的点集），初始化<span class="math inline">\(dis(s)=0,dis(else)=INF\)</span></p><p>然后重复以下操作，直到<span class="math inline">\(T\)</span>为空</p><ol type="1"><li>从<span class="math inline">\(T\)</span>中，选取最短路长度最小的结点，移动到<span class="math inline">\(S\)</span>中</li><li>对刚加入<span class="math inline">\(S\)</span>的结点的所有出边进行松弛操作</li></ol><h3 id="实现-2">实现</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">edge</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> e<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">fill_n</span><span class="token punctuation">(</span>dis<span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>INF<span class="token punctuation">)</span><span class="token punctuation">;</span>  dis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mind <span class="token operator">=</span> INF<span class="token punctuation">;</span><span class="token comment">//mind为u的最短路长度</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dis<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mind<span class="token punctuation">)</span>        u <span class="token operator">=</span> j<span class="token punctuation">,</span> mind <span class="token operator">=</span> dis<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> v <span class="token operator">=</span> i<span class="token punctuation">.</span>v<span class="token punctuation">,</span> w <span class="token operator">=</span> i<span class="token punctuation">.</span>w<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">></span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span>        dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="优化-1">优化</h3><p>如果不适用任何数据结构维护，显然复杂度为<span class="math inline">\(O(n^2+m)\)</span>，考虑使用二叉堆或者优先队列进行优化</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> e<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> dis<span class="token punctuation">,</span> u<span class="token punctuation">;</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> node<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> dis <span class="token operator">></span> a<span class="token punctuation">.</span>dis<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">fill_n</span><span class="token punctuation">(</span>dis<span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>INF<span class="token punctuation">)</span><span class="token punctuation">;</span>  dis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  priority_queue<span class="token operator">&lt;</span>node<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>node<span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>node<span class="token operator">>></span> q<span class="token punctuation">;</span> <span class="token comment">//创建优先级队列</span>  q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>u<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> v <span class="token operator">=</span> i<span class="token punctuation">.</span>v<span class="token punctuation">,</span> w <span class="token operator">=</span> i<span class="token punctuation">.</span>w<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">></span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>由于二叉堆和优先队列的插入删除元素只需要<span class="math inline">\(O(logn)\)</span>，所以复杂度可以达到<span class="math inline">\(O((m+n)logn)\)</span>和<span class="math inline">\(O(mlogn)\)</span></li></ul><h2 id="打印路径问题">打印路径问题</h2><p>比较简单，用一个整形数组path，在更新距离的时候，记录点是如何转移的即可</p><p>比如 Floyd 就要记录 <code>path[i][j] = k;</code>，Bellman-Ford 和 Dijkstra 一般记录 <code>path[v] = u</code>。</p><h2 id="参考">参考</h2><p><a href="https://oi-wiki.org/graph/shortest-path/">OI-WIKI</a></p><p>《算法导论》</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;呜呜呜，考试月要来li&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211207175750.png&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="http://lapras.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="http://lapras.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="优先队列" scheme="http://lapras.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="图" scheme="http://lapras.xyz/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>小米/红米 AC2100急速刷Breed</title>
    <link href="http://lapras.xyz/2021/12/03/e5ccadb4.html"/>
    <id>http://lapras.xyz/2021/12/03/e5ccadb4.html</id>
    <published>2021-12-03T09:58:06.000Z</published>
    <updated>2021-12-03T10:54:33.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>开热点联机文明6太折磨了，于是入了一台小米AC2100，原本想整个软路由的，日后再嗦。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211203180825.jpeg" alt="小米路由器AC2100立即购买-小米商城" style="zoom: 50%;" / loading="lazy"></p><span id="more"></span><h2 id="准备工作">准备工作</h2><ol type="1"><li><p>插上电源</p></li><li><p>准备两根网线，一根连接网口和<code>WAN</code>口（确保路由器有网络），一根连接<code>LAN</code>口（三选一）和电脑</p></li></ol><h2 id="回退版本">回退版本</h2><h3 id="下载固件">下载固件</h3><p>小米AC2100的 <strong>2.0.722</strong> 版本和红米AC2100的<strong>2.0.7</strong>版本，都留下的SSH漏洞，能让我们进系统刷机。目前全球的AC2100刷机方案，似乎都是由这个漏洞来的，感觉是小米官方有意为之。<del>那你倒是给个开发者模式啊！</del></p><p>所以我们需要先回退到之前的版本，拿到权限后再刷机。</p><blockquote><p><strong>官方下载链接：</strong> 红米RM2100： http://cdn.cnbj1.fds.api.mi-img.com/xiaoqiang/rom/rm2100/miwifi_rm2100_firmware_d6234_2.0.7.bin 小米R2100：http://cdn.cnbj1.fds.api.mi-img.com/xiaoqiang/rom/r2100/miwifi_r2100_firmware_4b519_2.0.722.bin</p></blockquote><h3 id="更换固件">更换固件</h3><p>进入小米路由器的网关(192.168.31.1)</p><p>在常用设置-&gt;系统状态-&gt;升级检测-&gt;手动升级，上传上一步下载好的固件。等待路由器降级重启完成。检查版本无误即可</p><h2 id="刷breed">刷Breed</h2><p>Breed是一个不死uboot，可以方便的刷固件并且保证不会变砖</p><h3 id="漏洞注入">漏洞注入</h3><p>进入网关，可以看到地址栏的链接为</p><pre class="language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.31.1&#x2F;cgi-bin&#x2F;luci&#x2F;;stok&#x3D;&lt;STOK&gt;&#x2F;web&#x2F;home#router</code></pre><p><code>&lt;STOK&gt;</code>是每次登陆都会动态变化的，把他记录下来</p><p>接着在浏览器地址栏中输入以下代码，<strong>注意替换掉<code>&lt;STOK&gt;</code>部分</strong>：</p><pre class="language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.31.1&#x2F;cgi-bin&#x2F;luci&#x2F;;stok&#x3D;&lt;STOK&gt;&#x2F;api&#x2F;misystem&#x2F;set_config_iotdev?bssid&#x3D;Xiaomi&amp;user_id&#x3D;longdike&amp;ssid&#x3D;-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20&#39;s%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg&#39;%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B</code></pre><ul><li>返回<code>&#123;"code":0&#125;</code>代表成功</li><li>返回<code>401</code> 或者<code>404</code>请检查固件版本或者链接</li></ul><h3 id="重启路由">重启路由</h3><p>在上步刷入成功之后，路由器系统灯（下面那个）会从蓝熄灭，然后变黄，再变蓝进入系统</p><p>此时<strong>拔掉电源，按住reset键（红米用针顶住reset孔）同时接上电源</strong>，此时电源灯会经历双闪，然后网络灯（上面那个）蓝色闪烁不停，说明Breed刷机成功。</p><h3 id="访问breed后台">访问Breed后台</h3><p>地址栏输入192.168.1.1或者192.168.2.1可以进入Breed的网关。如果进入失败，请检查以太网的IP设置。</p><p>在网络适配器中更改IPv4协议属性，设置手动获取IP。</p><pre class="language-none"><code class="language-none">IP地址192.168.1.1子网掩码255.255.255.0默认网关192.168.1.1</code></pre><h2 id="刷自定义固件">刷自定义固件</h2><p>固件更新-&gt;选中固件-&gt;然后上传即可</p><p>关于固件我这里推荐老毛子也就是Padavan</p><p><a href="https://opt.cn2qq.com/padavan/">老毛子</a>（红米选择RM2100 小米选择R2100）</p><p>然后等待重启，访问192.168.123.1即可</p><blockquote><p>默认配置</p><p>固件网关：192.168.123.1</p><p>管理页面：http://my.router/</p><p>管理帐号：admin</p><p>管理密码：admin</p><p>WIFI密码：1234567890</p><p>（刷机不会恢复默认配置）</p></blockquote><p>一键更新固件脚本：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> --no-check-certificate -O- https://opt.cn2qq.com/opt-script/up.sh <span class="token operator">></span> /tmp/up.sh <span class="token operator">&amp;&amp;</span> <span class="token function">bash</span> <span class="token operator">&lt;</span> /tmp/up.sh <span class="token operator">&amp;</span></code></pre><h2 id="参考">参考</h2><p>https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=4066963&amp;extra=page%3D2%26filter%3Dtypeid%26typeid%3D43</p><p>http://openwrt.ink:88/archives/s-breed</p><p><a href="https://opt.cn2qq.com/">Breed固件</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;开热点联机文明6太折磨了，于是入了一台小米AC2100，原本想整个软路由的，日后再嗦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211203180825.jpeg&quot; alt=&quot;小米路由器AC2100立即购买-小米商城&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="折腾系列" scheme="http://lapras.xyz/categories/%E6%8A%98%E8%85%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="教程" scheme="http://lapras.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="网络" scheme="http://lapras.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>数据结构期末复习</title>
    <link href="http://lapras.xyz/2021/12/01/e7c345c1.html"/>
    <id>http://lapras.xyz/2021/12/01/e7c345c1.html</id>
    <published>2021-12-01T04:26:03.000Z</published>
    <updated>2021-12-02T17:01:10.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>好好好，cxg又让我水了一篇博客。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211203005405.gif" alt="img" style="zoom:50%;" / loading="lazy"></p><span id="more"></span><h2 id="introduction">Introduction</h2><h3 id="基本概念">基本概念</h3><h4 id="基本概念-1">1. 基本概念</h4><ol type="1"><li>数据：可被计算机识别并加工的对象</li><li>数据元素：由数据组成的具有一定意义的基本单位，也称为元素、记录。</li><li>数据项：是组成数据元素的不可分割的最小单位</li></ol><h4 id="数据结构">2. 数据结构</h4><ul><li>逻辑结构<ul><li>线性结构 -&gt; 学生信息</li><li>树形结构 -&gt; 族谱</li><li>图结构 -&gt; 地图</li><li>集合结构 -&gt; 班级团体</li></ul></li><li>储存结构<ul><li>顺序存储结构</li><li>链式存储结构</li></ul></li></ul><h3 id="抽象数据类型">抽象数据类型</h3><h4 id="数据类型">1. 数据类型</h4><p>数据类型是性质相同的<strong>值的集合</strong>以及定义在该值集上的<strong>运算集合</strong>，比如整形、字符型等等</p><h4 id="抽象数据类型adt">2. 抽象数据类型（ADT）</h4><p>抽象数据类型（ADT）是纯粹理论实体，用于简化描述抽象算法，分类与评价数据结构，形式描述程序设计语言的类型系统。</p><ul><li>与存放数据的机器无关</li><li>与数据存储的物理结构无关</li><li>与实现操作的算法和编程语言均无关</li></ul><h3 id="算法及分析">算法及分析</h3><h4 id="算法的特征">1. 算法的特征</h4><ul><li>输入：有零个或若干个输入</li><li>输出：有一个或多个输出</li><li>可行性：每一个步骤能能通过基本运算实现</li><li>确定性：不会产生二义性</li><li>有穷性：算法必须有限步骤后终止</li></ul><h4 id="判断算法优劣的标准">2. 判断算法优劣的标准</h4><ul><li>正确性</li><li>可读性</li><li>鲁棒性（健壮性）</li><li>高效性</li></ul><h4 id="算法的时间复杂度oi-wiki">3. 算法的时间复杂度（<a href="https://oi-wiki.org/basic/complexity/#_4">OI-WIKI</a>）</h4><blockquote><p>衡量一个算法的快慢，一定要考虑数据规模的大小。所谓数据规模，一般指输入的数字个数、输入中给出的图的点数与边数等等。一般来说，数据规模越大，算法的用时就越长。而在算法竞赛中，我们衡量一个算法的效率时，最重要的不是看它在某个数据规模下的用时，而是看它的用时随数据规模而增长的趋势，即 <strong>时间复杂度</strong>。</p></blockquote><p>算法的运行用时并非完全由输入规模决定，而是也与输入的内容相关。所以，时间复杂度又分为几种，例如：</p><ol type="1"><li>最坏时间复杂度，即每个输入规模下用时最长的输入对应的时间复杂度。由于输入可以在给定的数据范围内任意给定，我们为保证算法能够通过某个数据范围内的任何数据，一般考虑最坏时间复杂度。</li><li>平均（期望）时间复杂度，即每个输入规模下所有可能输入对应用时的平均值的复杂度（随机输入下期望用时的复杂度）。</li></ol><h5 id="渐进符号">渐进符号</h5><p>简单来说，渐进符号忽略了一个函数中增长较慢的部分以及各项的系数（在时间复杂度相关分析中，系数一般被称作“常数”），而保留了可以用来表明该函数增长趋势的重要部分。</p><h6 id="大-θ-符号上下界">大 Θ 符号(上下界)</h6><p>对于函数 <span class="math inline">\(f(n)\)</span> 和 <span class="math inline">\(g(n)\)</span>，<span class="math inline">\(f(n)=\Theta(g(n))\)</span>，当且仅当 <span class="math inline">\(\exists c_1,c_2,n_0&gt;0\)</span>，使得 <span class="math inline">\(\forall n \ge n_0, 0\le c_1\cdot g(n)\le f(n) \le c_2\cdot g(n)\)</span>。</p><p>也就是说，如果函数 <span class="math inline">\(f(n)=\Theta(g(n))\)</span>，那么我们能找到两个正数 <span class="math inline">\(c_1, c_2\)</span> 使得 <span class="math inline">\(f(n)\)</span> 被 <span class="math inline">\(c_1\cdot g(n)\)</span> 和 <span class="math inline">\(c_2\cdot g(n)\)</span> 夹在中间。</p><p>例如，<span class="math inline">\(3n^2+5n-3=\Theta(n^2)\)</span>,<span class="math inline">\(n\sqrt n + n\log^5 n+m\log m+nm=\Theta(n\sqrt n+m\log m+nm)\)</span>。</p><h6 id="大-o-符号渐进上界">大 O 符号（渐进上界）</h6><p><span class="math inline">\(\Theta\)</span> 符号同时给了我们一个函数的上下界，如果只知道一个函数的渐进上界而不知道其渐进下界，可以使用 <span class="math inline">\(O\)</span> 符号。<span class="math inline">\(f(n)=O(g(n))\)</span>，当且仅当 <span class="math inline">\(\exists c,n_0\)</span>，使得 <span class="math inline">\(\forall n \ge n_0,0\le f(n)\le c\cdot g(n)\)</span>。</p><p>研究时间复杂度时通常会使用 <span class="math inline">\(O\)</span> 符号，因为我们关注的通常是程序用时的上界，而不关心其用时的下界。</p><p>需要注意的是，这里的“上界”和“下界”是对于函数的变化趋势而言的，而不是对算法而言的。算法用时的上界对应的是“最坏时间复杂度”而非大 <span class="math inline">\(O\)</span> 记号。所以，使用 <span class="math inline">\(\Theta\)</span> 记号表示最坏时间复杂度是完全可行的，甚至可以说 <span class="math inline">\(\Theta\)</span> 比 <span class="math inline">\(O\)</span> 更加精确，而使用 <span class="math inline">\(O\)</span> 记号的主要原因，一是我们有时只能证明时间复杂度的上界而无法证明其下界（这种情况一般出现在较为复杂的算法以及复杂度分析），二是 <span class="math inline">\(O\)</span> 在电脑上输入更方便一些。</p><h6 id="大-ω-符号渐进下界">大 Ω 符号（渐进下界）</h6><p>同样的，我们使用 <span class="math inline">\(\Omega\)</span> 符号来描述一个函数的渐进下界。<span class="math inline">\(f(n)=\Omega(g(n))\)</span>，当且仅当 <span class="math inline">\(\exists c,n_0\)</span>，使得 <span class="math inline">\(\forall n \ge n_0,0\le c\cdot g(n)\le f(n)\)</span>。</p><h6 id="小-o-符号">小 o 符号</h6><p>如果说 <span class="math inline">\(O\)</span> 符号相当于小于等于号，那么 <span class="math inline">\(o\)</span> 符号就相当于小于号。</p><p><span class="math inline">\(f(n)=o(g(n))\)</span>，当且仅当对于任意给定的正数 <span class="math inline">\(c\)</span>，<span class="math inline">\(\exists n_0\)</span>，使得 <span class="math inline">\(\forall n \ge n_0,0\le f(n)&lt; c\cdot g(n)\)</span>。</p><h6 id="小-ω-符号">小 ω 符号</h6><p>如果说 <span class="math inline">\(\Omega\)</span> 符号相当于大于等于号，那么 <span class="math inline">\(\omega\)</span> 符号就相当于大于号。</p><p><span class="math inline">\(f(n)=\omega(g(n))\)</span>，当且仅当对于任意给定的正数 <span class="math inline">\(c\)</span>，<span class="math inline">\(\exists n_0\)</span>，使得 <span class="math inline">\(\forall n \ge n_0,0\le c\cdot g(n)&lt; f(n)\)</span>。</p><h5 id="主定理-master-theorem">主定理 (Master Theorem)</h5><p>我们可以使用 Master Theorem 来快速求得关于递归算法的复杂度。 假设我们有递推关系式</p><p><span class="math display">\[ T(n) = a T\left(\frac{n}{b}\right)＋f(n)\qquad \forall n &gt; b \]</span></p><p>那么</p><p><span class="math display">\[ T(n) = \begin{cases}\Theta(n^{\log_b a}) &amp; f(n) = O(n^{\log_b a-\epsilon}) \\ \Theta(f(n)) &amp; f(n) = \Omega(n^{\log_b a+\epsilon}) \ \\Theta(n^{\log_b a}\log^{k+1} n) &amp; f(n)=\Theta(n^{\log_b a}\log^k n),k\ge 0 \end{cases} \]</span></p><h2 id="线性表">线性表</h2><p><a href="https://lapras.xyz/2021/03/28/c335c6ca.html">从零开始的数据结构-线性结构</a></p><h2 id="数组和字符串coming-soon">数组和字符串(coming soon)</h2><h2 id="树和二叉树">树和二叉树</h2><p><a href="https://lapras.xyz/2021/03/28/389e8dec.html">从零开始的数据结构-树（上）</a></p><p><a href="https://lapras.xyz/2021/04/01/8022ea89.html">从零开始的数据结构-树（下）</a></p><h2 id="搜索">搜索</h2><p><a href="https://lapras.xyz/2021/04/07/170718db.html">从零开始的数据结构-堆</a></p><p><a href="https://lapras.xyz/2021/10/24/db7ea760.html">搜索算法小整理（上）</a></p><h2 id="散列表coming-soon">散列表(coming soon)</h2><h2 id="图coming-soon">图(coming soon)</h2><h2 id="排序coming-soon">排序(coming soon)</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;好好好，cxg又让我水了一篇博客。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211203005405.gif&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="http://lapras.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="http://lapras.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lapras.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>微软三件套安装以及配置</title>
    <link href="http://lapras.xyz/2021/10/26/f77b55e6.html"/>
    <id>http://lapras.xyz/2021/10/26/f77b55e6.html</id>
    <published>2021-10-26T09:27:59.000Z</published>
    <updated>2021-10-27T08:56:33.410Z</updated>
    
    <content type="html"><![CDATA[<h3 id="section"><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211026174036.jpg" alt="cxdxhh2f9r071" style="zoom:50%;" / loading="lazy"></h3><span id="more"></span><h2 id="windows-terminal">Windows Terminal</h2><blockquote><p>Windows 终端是一个面向命令行工具和 shell（如命令提示符（cmd）、PowerShell 和适用于 Linux 的 Windows 子系统 (WSL)）用户的新式终端应用程序。 它的主要功能包括多个选项卡、窗格、Unicode 和 UTF-8 字符支持、GPU 加速文本呈现引擎，你还可用它来创建你自己的主题并自定义文本、颜色、背景和快捷方式。</p></blockquote><del>好看才是第一生产力，所以别在用cmd的黑框还有powershell的蓝框了</del><h3 id="安装">安装</h3><p>方法一 <a href="https://aka.ms/terminal">微软商店</a>（推荐方式）</p><p>方法二 Windows Terminal 的 <a href="https://github.com/microsoft/terminal/releases">Github Releases</a> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211026175219.png" alt="image-20211026175219873" style="zoom:67%;" / loading="lazy"></p><ul><li>选择完版本（preview是预览版），选择后缀为<code>.msixbundle</code>的文件下载安装即可</li></ul><p>方法三 winget</p><p>首先你得微软商店（搜索应用安装程序）通过<a href="https://github.com/microsoft/winget-cli/releases">Github Releases</a> 安装winget，然后打开你的powershell 输入</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell">winget install <span class="token operator">--</span>id=Microsoft<span class="token punctuation">.</span>WindowsTerminal <span class="token operator">-</span>e<span class="token comment">#安装成功后查看版本</span>winget <span class="token operator">-</span>v</code></pre><ul><li><p>如果提示没有这个命令，考虑重启终端或者重启电脑</p></li><li><p>推荐安装一下，因为后续的 powershell7 配置（美化）还会用到这个东西</p></li></ul><p>安装成功之后</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211026180656.png" alt="image-20211026180655833" style="zoom: 50%;" / loading="lazy"></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211026180900.png" alt="image-20211026180900388" style="zoom: 50%;" / loading="lazy"></p><p>你会发现你的界面和我的不大一样，问题不大，下面开始配置</p><h3 id="配置">配置</h3><p>选择<strong>设置</strong>可以进行一些基础功能的设置，比较明了，不作介绍。所有的配置项都在<code>setting.json</code>（点击设置后，选择打开JSON文件）中保存。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211026184621.png" alt="image-20211026184621095" / loading="lazy"><figcaption aria-hidden="true">image-20211026184621095</figcaption></figure><ul><li>最外层都是一些全局设置，具体的配置选项可以去<a href="https://docs.microsoft.com/zh-cn/windows/terminal/json-fragment-extensions">微软文档</a>中看</li><li><code>defaultProfile</code>：值是一个UUID，也就是<code>profiles</code>的<code>guid</code></li><li><code>keybindings</code>：自定义一些快捷键</li><li><code>profiles</code>的默认选项是对所有配置文件生效的<ul><li><code>acrylicOpacity</code>：亚克力面板效果</li><li><code>fontFace</code>：选择安装含有PL（powerline）且等宽（Mono）的字体（推荐https://www.nerdfonts.com/font-downloads）</li><li><code>list</code>：含有众多配置的单独设置，如果你自己新建的话，注意<code>guid</code>别自己写。然后如果配置要连接你的服务器<code>commandline</code>就可以写成ssh之类的</li></ul></li><li><code>schemes</code>：配色方案</li></ul><h2 id="powershell-7">PowerShell 7</h2><blockquote><p>Windows PowerShell 5.1 是在 .NET Framework v4.5 基础上构建的。 随着 PowerShell 6.0 的发布，PowerShell 成为基于 .NET Core 2.0 构建的开源项目。 PowerShell 7.0 是在 .NET Core 3.1 基础上构建的。 随着 PowerShell 7.2 的发布，将在 .NET 6.0 基础上构建 PowerShell。 从 .NET Framework 转换到 .Net Core 使 PowerShell 成为可跨平台的解决方案。 PowerShell 在 Windows、macOS 和 Linux 上运行。</p></blockquote><h3 id="安装-1">安装</h3><p>方法一 微软商店<del>连Powershell都上了VSCode呢？</del></p><p>方法二 PowerShell的<a href="https://github.com/PowerShell/PowerShell/releases/">Github Releases</a> windows选择<code>.msi</code>后缀即可</p><p>方法三 winget</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell">winget install <span class="token operator">--</span>name PowerShell <span class="token operator">--</span>exact <span class="token operator">--</span>source winget</code></pre><h3 id="配置-1">配置</h3><p>首先是要让之前安装的 windows terminal 默认开启 powershell 7 而不是原装的 windows powershell</p><p>打开之前的<code>Profile</code>在如下位置添加<code>commandline</code></p><pre class="language-json" data-language="json"><code class="language-json"><span class="token property">"profiles"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"defaults"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"commandline"</span><span class="token operator">:</span> <span class="token string">"pwsh.exe"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span></code></pre><h4 id="安装gsudo">安装gsudo</h4><p>在命令行中提供管理员权限，而无需另起管理员powershell</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell">winget install <span class="token operator">--</span>name gsudo <span class="token operator">--</span>source winget<span class="token comment">#安装成功后查看版本</span>sudo <span class="token operator">-</span>v<span class="token comment">#使用</span>sudo yourcommand</code></pre><ul><li>后续的命令中有一些需要管理员权限</li></ul><h4 id="安装oh-my-posh-3">安装Oh-My-Posh 3</h4><p>有的人应该知道oh-my-zsh，都是懒癌福音，一键解锁终端主题。</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">Install-Module</span> oh-my-posh <span class="token operator">-</span>Scope AllUsers</code></pre><p>安装中基本一直y即可</p><p>安装完成之后，可以查看现有的主题，然后选择一个更换。</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#查看主题</span><span class="token function">Get-PoshThemes</span><span class="token comment">#设置主题</span><span class="token function">Set-PoshPrompt</span> <span class="token operator">-</span>Theme ThemeName</code></pre><ul><li>如果你发现主题中有大量方框乱码，请回到上文考虑修改默认字体</li></ul><p>当然如果你想要自定义主题的话可以导出主题配置文件，然后修改其json文件再重新设置</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#导出主题</span><span class="token function">Export-PoshTheme</span> <span class="token operator">-</span>FilePath ~<span class="token operator">/</span><span class="token punctuation">.</span>mytheme<span class="token punctuation">.</span>omp<span class="token punctuation">.</span>json<span class="token comment">#设置主题</span><span class="token function">Set-PoshPrompt</span> <span class="token operator">-</span>Theme ~<span class="token operator">/</span><span class="token punctuation">.</span>mytheme<span class="token punctuation">.</span>omp<span class="token punctuation">.</span>json</code></pre><p>但是你会发现重启终端之后就失效了，这是为什么嘞？，其实是要修改 PowerShell 自身的配置文件（类似于.zshrc或者.bashrc）。</p><h4 id="安装psreadline">安装PSReadLine</h4><p>PSReadLine会根据你的历史记录来进行预测和补全命令</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">Install-Module</span> PSReadLine <span class="token operator">-</span>Scope AllUsers</code></pre><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 显示所有可以配置的选项</span><span class="token function">Get-PSReadLineOption</span>  <span class="token comment"># 显示所有可以配置的快捷键</span><span class="token function">Get-PSReadLineKeyHandler</span>  </code></pre><h4 id="配置profile">配置Profile</h4><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">Test-Path</span> <span class="token operator">-</span>Path <span class="token variable">$PROFILE</span><span class="token punctuation">.</span>AllUsersCurrentHost<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">New-Item</span> <span class="token operator">-</span>ItemType File <span class="token operator">-</span>Path <span class="token variable">$PROFILE</span><span class="token punctuation">.</span>AllUsersCurrentHost <span class="token operator">-</span>Force<span class="token punctuation">&#125;</span></code></pre><ul><li>一个简单的脚本判断你是否已经创建了配置文件</li></ul><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#使用vscode编辑</span>code <span class="token variable">$Profile</span> <span class="token comment">#使用记事本编辑 （呜呜呜别再用记事本了）</span>notepad <span class="token variable">$Profile</span></code></pre><p>在<code>$Profile</code>中添加：</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 设置 oh-my-posh</span><span class="token function">Import-Module</span> oh-my-posh<span class="token comment"># 设置 ps-read-line</span><span class="token function">Import-Module</span> PSReadLine<span class="token comment"># 设置主题</span><span class="token function">Set-PoshPrompt</span> paradox<span class="token comment"># 设置预测文本来源为历史记录</span><span class="token function">Set-PSReadLineOption</span> <span class="token operator">-</span>PredictionSource History<span class="token comment"># 每次回溯输入历史，光标定位于输入内容末尾</span><span class="token function">Set-PSReadLineOption</span> <span class="token operator">-</span>HistorySearchCursorMovesToEnd<span class="token comment"># 设置 Tab 为菜单补全和 Intellisense</span><span class="token function">Set-PSReadLineKeyHandler</span> <span class="token operator">-</span>Key <span class="token string">"Tab"</span> <span class="token operator">-</span><span class="token keyword">Function</span> MenuComplete<span class="token comment"># 设置向上键为后向搜索历史记录</span><span class="token function">Set-PSReadLineKeyHandler</span> <span class="token operator">-</span>Key UpArrow <span class="token operator">-</span><span class="token keyword">Function</span> HistorySearchBackward<span class="token comment"># 设置向下键为前向搜索历史纪录</span><span class="token function">Set-PSReadLineKeyHandler</span> <span class="token operator">-</span>Key DownArrow <span class="token operator">-</span><span class="token keyword">Function</span> HistorySearchForward</code></pre><p>最后重启终端即可！</p><h2 id="wsl">WSL</h2><blockquote><p>适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。</p><p>您可以：</p><ul><li><a href="https://aka.ms/wslstore">在 Microsoft Store</a> 中选择你偏好的 GNU/Linux 分发版。</li><li>运行常用的命令行软件工具（例如 <code>grep</code>、<code>sed</code>、<code>awk</code>）或其他 ELF-64 二进制文件。</li><li>运行 Bash shell 脚本和 GNU/Linux 命令行应用程序，包括：</li><li>工具：vim、emacs、tmux</li><li>语言：<a href="https://docs.microsoft.com/zh-cn/windows/nodejs/setup-on-wsl2">NodeJS</a>、Javascript、<a href="https://docs.microsoft.com/zh-cn/windows/python/web-frameworks">Python</a>、Ruby、C/ C++、C# 与 F#、Rust、Go 等。</li><li>服务：SSHD、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">MySQL</a>、Apache、lighttpd、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">MongoDB</a>、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">PostgreSQL</a>。</li><li>使用自己的 GNU/Linux 分发包管理器安装其他软件。</li><li>使用类似于 Unix 的命令行 shell 调用 Windows 应用程序。</li><li>在 Windows 上调用 GNU/Linux 应用程序。</li><li>现已支持CUDA！一起来炼丹吧！</li></ul></blockquote><h3 id="安装-2">安装</h3><pre class="language-powershell" data-language="powershell"><code class="language-powershell">wsl <span class="token operator">--</span>install</code></pre><ul><li>此命令将启用所需的可选组件，下载最新的 Linux 内核，将 WSL 2 设置为默认值，并默认安装 Ubuntu</li><li>而后会新建用户并设置密码</li></ul><p>然后重启电脑。在终端就看见一个新的选项卡</p><p>而后的Linux配置可以参考组内另一名讲师（莫非）的<a href="https://closed-linen-ea9.notion.site/Ubuntu-cb4d33bdbcc2400b9b04cc56ba21d080">虚拟机安装Ubuntu教程</a></p><h2 id="参考">参考</h2><p><a href="https://docs.microsoft.com/en-us/">微软官方文档</a></p><p><a href="https://zhuanlan.zhihu.com/p/137595941">Windows Terminal 完美配置 PowerShell 7.1</a></p><p><a href="https://zhuanlan.zhihu.com/p/351281543">Window Terminal 安装以及使用</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;section&quot;&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211026174036.jpg&quot; alt=&quot;cxdxhh2f9r071&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/h3&gt;</summary>
    
    
    
    
    <category term="工具" scheme="http://lapras.xyz/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="分享" scheme="http://lapras.xyz/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>搜索算法小整理（上）</title>
    <link href="http://lapras.xyz/2021/10/24/db7ea760.html"/>
    <id>http://lapras.xyz/2021/10/24/db7ea760.html</id>
    <published>2021-10-24T06:19:22.000Z</published>
    <updated>2021-10-25T09:29:21.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>10月24日，程序猿节？昨天招新结束，做了一下午牢还行。。。刚好cxg讲到搜索了，写个水博客摸摸鱼。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024174654.jpg" alt="93565599_p0" style="zoom: 50%;" / loading="lazy"></p><span id="more"></span><h2 id="一些概念">一些概念</h2><p><strong>平均搜索长度</strong>（<span class="math inline">\(ASL\)</span>）：确定一个键值在表中的位置，需要进行若干次比较，比较次数的期望值就是所谓的<span class="math inline">\(ASL\)</span></p><p><strong>搜索成功的平均长度</strong>（<span class="math inline">\(ASL_s\)</span>）：字面意思</p><p><strong>搜索失败的平均长度</strong>（<span class="math inline">\(ASL_f\)</span>）：字面意思</p><h2 id="顺序查找暴力">顺序查找（暴力）</h2><h3 id="思路">思路</h3><del>暴力要什么思路？</del><p>将线性表从头至尾遍历一次。</p><h3 id="代码">代码</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">SeqSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>      <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><p><span class="math inline">\(O(N)\)</span></p></li><li><p><span class="math inline">\(ASL_s\)</span>：<span class="math inline">\(\frac{1}{n}\sum^{n}_{i=1}i=\frac{(n+1)}{2}\)</span></p></li><li><p><span class="math inline">\(ASL_f\)</span>：<span class="math inline">\(\frac{1}{n+1}\sum^{n+1}_{i=1}i=1+\frac{n}{2}\)</span></p><ul><li>可以理解为成功版本的插空，如果程序中使用<span class="math inline">\(inf\)</span>哨兵判断遍历到数组末尾，则还需再加1</li></ul></li></ul><h2 id="二分查找binarysearch">二分查找（BinarySearch）</h2><h3 id="思路-1">思路</h3><p>经典二分法，给定一个<strong>有序</strong>的线性表，校验其中间值，然后分成左右两个线性表，继续递归地寻找答案</p><h3 id="代码-1">代码</h3><h4 id="递归版">递归版</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binSearch_rec</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> r<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>    <span class="token keyword">return</span> mid<span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">binSearch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token function">binSearch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="循环版">循环版</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binSearch_loop</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>      <span class="token keyword">return</span> mid<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>      l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>      r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="极简板">极简板</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span>      r <span class="token operator">=</span> mid<span class="token punctuation">;</span> <span class="token comment">// check()判断mid是否满足性质</span>    <span class="token keyword">else</span>      l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><span class="math inline">\(O(log_2N)\)</span></li><li><code>int mid = l + (r - l) / 2;</code>是防止数据溢出</li><li>极简版本只适用于确定答案在数组中的题目</li></ul><h3 id="二叉搜索树">二叉搜索树</h3><p>(具体见<a href="https://lapras.xyz/2021/04/01/8022ea89.html">从零开始的数据结构-树</a>)</p><p>也称为 二叉查找树 、二分搜索树 、有序二叉树或排序二叉树。</p><p>满足以下几个条件：</p><ul><li>若它的左子树不为空，左子树上所有节点的值都小于它的根节点。</li><li>若它的右子树不为空，右子树上所有的节点的值都大于它的根节点。</li></ul><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024203611.png" alt="image-20211024203611557" / loading="lazy"><figcaption aria-hidden="true">image-20211024203611557</figcaption></figure><p>显然地，如果我们对这颗树进行中序遍历，就会得到一个有序的线性表。那么反之，我们之前的二分查找的过程，也可以用这颗树来表示。</p><ul><li>每一个根节点都是中点(偶数个为左)</li><li>左子数为左边的线性子表，右子树为右边的线性子表</li></ul><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024204318.gif" alt="GIF 2021-10-24 20-42-50" / loading="lazy"><figcaption aria-hidden="true">GIF 2021-10-24 20-42-50</figcaption></figure><p>来计算一下<span class="math inline">\(ASL_s\)</span>，显然地第一层只需要对比1次，第二次需要两次，以此类推<span class="math inline">\(ASL_s=(1*1+2*2+3*4+4*3)/10\)</span>。</p><p>计算<span class="math inline">\(ASL_f\)</span>我们只需要将图上的二叉搜索树的每个结点用空白结点进行补齐。那么这些空白结点就代表着失败的区间。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024210117.png" alt="graph (7)" style="zoom:67%;" / loading="lazy"></p><p><span class="math inline">\(ASL_f=(4*4+5*6)/10\)</span></p><h2 id="插值查找interpolationsearch">插值查找（InterpolationSearch）</h2><h3 id="思路-2">思路</h3><p>插值查找的核心思想确实和翻字典差不多。毕竟没人翻字典是二分查找的吧。它和二分查找唯一的区别就在于<code>mid</code>的更新。</p><p>二分查找的<code>mid</code>只是简单地取了中点，而插值查找则有一点按照比例分配的感觉。</p><p><span class="math inline">\(mid = l+ [\frac{key - a[l]}{a[r]-a[l]}](r-l)\)</span></p><p>可以看到，原来的系数<span class="math inline">\(\frac{1}{2}\)</span>被替换为了<span class="math inline">\([\frac{key - a[l]}{a[r]-a[l]}]\)</span>，我们假定一个完全平均分配的数组<code>[1,2,3,4,5,6,7,8,9,10]</code>使用插值查找7，</p><p>则<span class="math inline">\(mid = 0+ \frac{7 - 1}{10-1}(9-0)=6\)</span>直接 <span class="math inline">\(O(1)\)</span> 获得了7的下标。但同样的，如果数组分布非常不均匀，则会退化成<span class="math inline">\(O(N)\)</span>。</p><p>比如<code>[0, 99, 100, 100, 100, 100, 100]</code>使用插值查找99，则<span class="math inline">\(mid\)</span>会依次更新为5，3，1反而比直接二分来的慢了。</p><h3 id="代码-2">代码</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binSearch_inp</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>target <span class="token operator">-</span> a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">-</span> a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>      <span class="token keyword">return</span> mid<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>      l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>      r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>期望<span class="math inline">\(O(loglogN)\)</span></li><li>最坏<span class="math inline">\(O(N)\)</span></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;10月24日，程序猿节？昨天招新结束，做了一下午牢还行。。。刚好cxg讲到搜索了，写个水博客摸摸鱼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024174654.jpg&quot; alt=&quot;93565599_p0&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="http://lapras.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++" scheme="http://lapras.xyz/tags/C/"/>
    
    <category term="算法" scheme="http://lapras.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索" scheme="http://lapras.xyz/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>记frp实现内网穿透</title>
    <link href="http://lapras.xyz/2021/09/12/dae1adad.html"/>
    <id>http://lapras.xyz/2021/09/12/dae1adad.html</id>
    <published>2021-09-12T07:30:53.000Z</published>
    <updated>2021-10-24T06:21:09.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>啊，服务器配置太低，只能把服务配置在本地，但是校园网哪来的公网IP，无奈只能穿透了捏~</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210912153717.webp" alt="img" style="zoom:50%;" / loading="lazy"></p><span id="more"></span><h2 id="简介">简介</h2><p><code>frp</code> 是一个可用于内网穿透的高性能的反向代理应用，支持 <code>tcp</code>, <code>udp</code> 协议，为<code>http</code>和 <code>https</code>应用协议提供了额外的能力，且尝试性支持了点对点穿透。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p><h2 id="工具">工具</h2><blockquote><p>提供服务的客户端（我这里是Win10）</p><p>拥有公网ip的服务端（我这里是CentOS8）</p><p>一个@解析到服务端ip的域名</p><p>frp</p></blockquote><h2 id="服务端篇">服务端篇</h2><h3 id="下载">下载</h3><p><a href="https://github.com/fatedier/frp/releases">FRP 下载地址</a></p><p>选择你服务器内核对应的压缩包即可，下载完成后解压</p><h3 id="配置">配置</h3><p>可以看到软件目录一共有两个程序、四个配置文件</p><blockquote><p>frps 表示frp server</p><p>frpc 表示frp client</p><p>frps.ini是服务端配置文件</p><p>frpc.ini是客户端配置文件</p><p>frps_full.ini是服务端的配置文件模板</p><p>frpc_full.ini是客户端的配置文件模板</p></blockquote><p>配置服务端文件<code>frps.ini</code>：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>common<span class="token punctuation">]</span><span class="token comment">#监听的ip，通常为0.0.0.0，意为监听所有的地址</span>bind_addr <span class="token operator">=</span> <span class="token number">0.0</span>.0.0<span class="token comment">#与客户端绑定端口须一致</span>bind_port <span class="token operator">=</span> <span class="token number">7000</span><span class="token comment">#监听 HTTP 请求端口</span>vhost_http_port <span class="token operator">=</span> <span class="token number">5089</span><span class="token comment">#域名设置</span>subdomain_host <span class="token operator">=</span> yourdomain.com <span class="token comment">#dashboard 用户名</span>dashboard_user <span class="token operator">=</span> username<span class="token comment">#dashboard 密码</span>dashboard_pwd <span class="token operator">=</span> <span class="token function">passwd</span><span class="token comment">#dashboard 端口，启动成功后可通过浏览器访问如http://ip:23333</span>dashboard_port <span class="token operator">=</span> <span class="token number">23333</span> <span class="token comment">#设置服务端token，对应客户端也需要配置相同</span>token <span class="token operator">=</span> <span class="token number">1145141818</span>     </code></pre><h3 id="运行">运行</h3><pre class="language-bash" data-language="bash"><code class="language-bash">./frps -c ./frps.ini</code></pre><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210912160616.png" / loading="lazy"></p><ul><li>记得打开相应的防火墙以及安全组</li></ul><h3 id="设置服务">设置服务</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/systemd/system/frps.service</code></pre><p>添加以下内容：</p><pre class="language-none"><code class="language-none">[Unit]Description&#x3D;frps daemonAfter&#x3D;syslog.target  network.targetWants&#x3D;network.target [Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;frp&#x2F;frps -c &#x2F;usr&#x2F;local&#x2F;frp&#x2F;frps.iniRestart&#x3D; alwaysRestartSec&#x3D;1min [Install]WantedBy&#x3D;multi-user.target</code></pre><ul><li><code>ExecStart</code>根据frp安装目录自行更改</li></ul><p>现在就可以<code>systemctl</code>来控制frp啦</p><h2 id="客户端篇">客户端篇</h2><h3 id="下载-1">下载</h3><p><a href="https://github.com/fatedier/frp/releases">FRP 下载地址</a></p><p>选择你服务器内核对应的压缩包即可，下载完成后解压</p><h3 id="配置-1">配置</h3><p>配置客户端文件<code>frpc.ini</code>：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>common<span class="token punctuation">]</span><span class="token comment"># 服务器IP或者地址</span>server_addr <span class="token operator">=</span> address or domain<span class="token comment"># 服务器提供的端口号(需与客户端一致)</span>server_port <span class="token operator">=</span> <span class="token number">7000</span>           <span class="token comment">#设置客户端token(需与客户端一致)</span>token <span class="token operator">=</span> <span class="token number">1145141818</span><span class="token punctuation">[</span>Asoul<span class="token punctuation">]</span><span class="token builtin class-name">type</span> <span class="token operator">=</span> httplocal_ip <span class="token operator">=</span> <span class="token number">127.0</span>.0.1<span class="token comment">#内网服务放置的端口</span>local_port <span class="token operator">=</span> <span class="token number">8080</span><span class="token comment">#二级域名设置</span>subdomain <span class="token operator">=</span> <span class="token builtin class-name">test</span></code></pre><ul><li><p>这里我只配置了一个web应用的穿透，更多的比如ssh登录，远程桌面等等见参考</p></li><li><p>访问服务的方式是：<code>subdomain.domain.com:vhost_http_port</code></p></li></ul><h3 id="运行-1">运行</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">\</span>frpc.exe -c .<span class="token punctuation">\</span>frpc.ini</code></pre><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210912162600.png" alt="image-20210912162600590" / loading="lazy"><figcaption aria-hidden="true">image-20210912162600590</figcaption></figure><h3 id="设置服务-1">设置服务</h3><p>新建一个<code>vbs</code>：</p><pre class="language-vbscript" data-language="vbscript"><code class="language-vbscript">Copyset ws&#x3D;WScript.CreateObject(&quot;WScript.Shell&quot;)ws.Run &quot;&#123;yourpath&#125;\frpc.exe -c &#123;yourpath&#125;\frpc.ini&quot;,0</code></pre><p><code>win</code>+<code>R</code>运行打开<code>shell:startup</code>把该文件放进去即可嘞。</p><h2 id="window服务">Window服务</h2><p>介绍个好用的玩意儿<a href="https://github.com/kohsuke/winsw">winsw</a>，它可以将Windows上的任何一个程序注册为服务，这比<code>shell:startup</code>方便多嘞，它的使用类似于Linux平台上的<code>systemctl</code>，只不过其的配置文件是用xml格式写的</p><h3 id="下载-2">下载</h3><p>https://github.com/winsw/winsw/releases/</p><p>如果电脑有安装<code>.NET Framework 4.6.1</code>以上版本就可以选择<code>WinSW-net461.exe</code>，反之选择x64或者x86版本</p><h3 id="配置-2">配置</h3><ol type="1"><li>将下载好的exe文件改个名字<code>winsw.exe</code></li><li>新建一个<code>winsw</code>目录，移动<code>winsw.exe</code>并将其添加进系统环境变量中</li><li>在该目录下新建一个<code>frp.xml</code>文件</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 该服务的唯一标识 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>frp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 该服务的名称 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>frpc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 该服务的描述 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>frpc客户端 这个服务用 frpc 实现内网穿透<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 要运行的程序路径 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executable</span><span class="token punctuation">></span></span>&#123;yourpath&#125;\frpc.exe<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executable</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 携带的参数 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arguments</span><span class="token punctuation">></span></span>-c &#123;yourpath&#125;\frpc.ini<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>arguments</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 第一次启动失败 60秒重启 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onfailure</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>restart<span class="token punctuation">"</span></span> <span class="token attr-name">delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>60 sec<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token comment">&lt;!-- 日志模式 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logmode</span><span class="token punctuation">></span></span>append<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>logmode</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 指定日志文件目录(相对于executable配置的路径) --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logpath</span><span class="token punctuation">></span></span>frplogs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>logpath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>service</span><span class="token punctuation">></span></span></code></pre><ol start="4" type="1"><li>安装服务</li></ol><pre class="language-powershell" data-language="powershell"><code class="language-powershell">winsw install <span class="token punctuation">&#123;</span>yourpath<span class="token punctuation">&#125;</span>\winsw\frp<span class="token punctuation">.</span>xml</code></pre><ol start="5" type="1"><li>启动服务</li></ol><pre class="language-powershell" data-language="powershell"><code class="language-powershell">winsw <span class="token function">start</span> <span class="token punctuation">&#123;</span>yourpath<span class="token punctuation">&#125;</span>\winsw\frp<span class="token punctuation">.</span>xml</code></pre><pre class="language-none"><code class="language-none">&#x2F;&#x2F;全部命令：&#x2F;&#x2F;注册服务winsw.exe install xxx&#x2F;&#x2F;卸载服务winsw.exe uninstall xxx&#x2F;&#x2F;启动服务winsw.exe start xxx&#x2F;&#x2F;停止服务winsw.exe stop xxx&#x2F;&#x2F;重启服务winsw.exe restart xxx&#x2F;&#x2F;查看状态winsw.exe status xxx</code></pre><h2 id="参考">参考</h2><p>http://kan.lol/posts/c067e7e3/</p><p>https://blog.csdn.net/nextyu/article/details/78284663</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;啊，服务器配置太低，只能把服务配置在本地，但是校园网哪来的公网IP，无奈只能穿透了捏~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210912153717.webp&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="项目经历" scheme="http://lapras.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="分享" scheme="http://lapras.xyz/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="网络" scheme="http://lapras.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>记录在linux上的武当梯云纵</title>
    <link href="http://lapras.xyz/2021/08/24/a04e8961.html"/>
    <id>http://lapras.xyz/2021/08/24/a04e8961.html</id>
    <published>2021-08-24T08:43:49.000Z</published>
    <updated>2021-09-03T03:43:09.074Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>手机和PC上都是直接V2ray+机场直接走了，一直没认真配过，没想到一搞就是一天……</p><p>买的腾讯云学生机git速度感人 –&gt; V2ray客户端 –&gt; git V2速度感人 –&gt; ……-&gt; 白嫖Azure大失败 –&gt; ……–&gt;trojan真好用</p><span id="more"></span><h3 id="工具">工具</h3><blockquote><p>一台ip在国外的VPS（我用的<a href="https://my.vultr.com/">vultr</a>，支持小时计费还有支付宝，一个人用最便宜的都绰绰有余）</p><p>一台ip在国内想要学武当梯云纵的VPS</p><p>一个能正常使用的终端（Windows Terminal好用的很）</p><p>一个闲置的域名（最好别备案，国内国外皆可）</p><p>DNS服务商（免费的<a href="https://www.cloudflare.com/zh-cn/">cloudflare</a>，当然你顺手在国内解析也行，不过大概率会被叫去实名）</p></blockquote><h3 id="服务端篇">服务端篇</h3><h4 id="购买篇">购买篇</h4><p>因为只买过vultr，所以只聊聊vultr的购买选项</p><p><strong>地区</strong></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210824195804.png" alt="image-20210824195804260" / loading="lazy"><figcaption aria-hidden="true">image-20210824195804260</figcaption></figure><ul><li>有些地区会有2.5刀的only ipv6 版（考虑到目前中国的ipv6发展水平，最好别选），有些地区有3.5刀的青春版</li></ul><p><strong>镜像</strong></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210824200139.png" alt="image-20210824200139053" / loading="lazy"><figcaption aria-hidden="true">image-20210824200139053</figcaption></figure><ul><li>一般来说就选 CentOS和Ubuntu/Debian 即可（别的我也没怎么用过）</li></ul><p><strong>可选项（）</strong></p><ul><li>Enable IPv6：分配个IPv6的地址给你</li><li>Enable Auto Backups：增值服务，自动备份。</li><li>Enable DDOS Protection：增值服务，防范DDOS攻击。</li><li>Enable Private Networking：分配个内网IP给你</li></ul><p>总结：如果只是为了上武当学艺，这四个都可以不用</p><p>然后是<strong>Startup Script</strong>和 <strong>SSH Keys</strong>。我选择朴实无华的自己ssh，故也不填</p><p>最后<strong>Server Hostname</strong>随便填个名儿就行</p><p>返回主页，就可以看见自己的服务器正在加载，加载成功之后记住他的IP和root密码就行，vultr默认没有防火墙，要是设置过防火墙记得打开80（ssh）和443（代理）端口</p><h4 id="域名解析篇">域名解析篇</h4><p>我们需要有一个域名作为伪装域名</p><p><strong>国内</strong></p><p>我们随便买完域名之后，如果是在腾讯云（阿里云）阿里云买的，则去其对应的后台</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210824201801.png" alt="image-20210824201801267" / loading="lazy"><figcaption aria-hidden="true">image-20210824201801267</figcaption></figure><p>然后填写自己的服务端IP即可</p><p><strong>国外</strong></p><p>在成功注册cloudflare之后会让你填写解析记录，如图所示填写即可，内容是服务端的IP，注意代理状态一定要选仅限DNS</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210824202529.png" alt="image-20210824202529566" / loading="lazy"><figcaption aria-hidden="true">image-20210824202529566</figcaption></figure><p>弄好之后可以在https://dns.tech/l检验一下基本就没有问题li</p><h4 id="上机篇">上机篇</h4><p>随便打开个终端用ssh连接你的服务器</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> root@<span class="token string">'your IP or Domain'</span></code></pre><p>如果是初次登录，会提示在本地生成ssh key，yes即可</p><p>然后输入密码，成功进入服务器</p><p>安装前置软件 curl</p><p>Debian/Ubuntu：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> -y <span class="token function">curl</span></code></pre><p>CentOS：</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> -y <span class="token function">curl</span></code></pre><p>然后执行一键安装脚本</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">bash</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">curl</span> -sL https://s.hijk.art/trojan.sh<span class="token punctuation">)</span></code></pre><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210824204000.png" alt="image-20210824204000807" style="zoom:67%;" / loading="lazy"></p><ul><li>trojan端口：443貌似是最快的，但是最近好像有些不稳定，一堆人被封掉了</li><li>伪装站：是真的能上2333</li><li>允许搜索引擎or爬取网站：建议选择允许，耗不了几个流量，但是能给你的网站带来多元的正常流量，大大的良民</li><li>然后就一路enter即可</li></ul><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210824204510.png" alt="image-20210824204510388" style="zoom:67%;" / loading="lazy"></p><p>可喜可贺！记住下面四行信息即可。</p><h3 id="客户端篇">客户端篇</h3><h4 id="安装篇">安装篇</h4><p>官方客户端过于“简约”，windows客户端建议使用V2rayN或者Clash for Windows，mac客户端建议使用ClashX，安卓客户端建议使用V2rayNG。</p><p>欧可，重点是linux客户端上的配置，因为连接github太慢了，只能放弃舒服的一键脚本（我要是能一键脚本，我还配个der）</p><p>自行找个镜像站下载</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/src <span class="token operator">&amp;&amp;</span> <span class="token function">wget</span> https://d2.netfiles.pw/trojan/trojan-1.16.0-linux-amd64.tar.xz</code></pre><p>解压</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> xvf trojan-1.16.0-linux-amd64.tar.xz</code></pre><p>修改配置文件</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/src/trojan<span class="token function">vim</span> config.json</code></pre><p>其配置文件很多，但我们只需要关注如下几个</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token string">"run_type"</span><span class="token builtin class-name">:</span> <span class="token string">"client"</span>,<span class="token string">"local_addr"</span><span class="token builtin class-name">:</span> <span class="token string">"127.0.0.1"</span>,//0.0.0.0也可<span class="token string">"local_port"</span><span class="token builtin class-name">:</span> <span class="token number">1080</span>,//0~65535 挑个不会被占用的即可<span class="token string">"remote_addr"</span><span class="token builtin class-name">:</span> <span class="token string">"xxx.xxx"</span>,//您的域名<span class="token string">"remote_port"</span><span class="token builtin class-name">:</span> <span class="token number">443</span>,//国外服务器trojan的端口<span class="token string">"password"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"xxxxxxxxxxx"</span><span class="token punctuation">]</span>,//密码 可以有多个</code></pre><ul><li>[FATAL] fatal: load_verify_file: No such file or director，这时ssl中的verify和verify_hostname需要设置成false，好像是证书的问题，选择一种懒人危险法</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token string">"verify"</span><span class="token builtin class-name">:</span> false,<span class="token string">"verify_hostname"</span><span class="token builtin class-name">:</span> false,<span class="token string">"cert"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,</code></pre><p>接着配置trojan service</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/systemd/system/trojan.service</code></pre><p>复制如下代码进去</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span><span class="token assign-left variable">Description</span><span class="token operator">=</span>trojan<span class="token assign-left variable">After</span><span class="token operator">=</span>network.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span><span class="token assign-left variable">Type</span><span class="token operator">=</span>simple<span class="token assign-left variable">PIDFile</span><span class="token operator">=</span>/usr/src/trojan/trojan.pid<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/src/trojan/trojan -c /usr/src/trojan/config.json -l /usr/src/trojan/trojan.log<span class="token assign-left variable">ExecReload</span><span class="token operator">=</span>/bin/kill -HUP <span class="token punctuation">\</span><span class="token variable">$MAINPID</span><span class="token assign-left variable">Restart</span><span class="token operator">=</span>on-failure<span class="token assign-left variable">RestartSec</span><span class="token operator">=</span>1s<span class="token punctuation">[</span>Install<span class="token punctuation">]</span><span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>multi-user.target</code></pre><p>这样之后就可以用<code>systemctl start trojan</code>来启动trojan了，除此之外</p><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl restart trojan 重启trojansystemctl stop trojan 停止trojansystemctl status trojan 查看当前trojan状态systemctl status trojan -l查看当前trojan完整状态systemctl <span class="token builtin class-name">enable</span> trojan设置开机启动<span class="token function">cat</span> /usr/src/trojan/server.conf 查看trojan配置<span class="token function">cat</span> /usr/src/trojan/trojan.log 查看trojan日志</code></pre><p>输入<code>curl cip.cc --socks5 127.0.0.1:&#123;you_local_port&#125;</code>检测结果</p><h4 id="其他小技巧">其他小技巧</h4><p>linux下代理一般是通过<code>http_proxy</code>和<code>https_proxy</code>这两个环境变量，但是很多软件并不使用这两个变量，导致流量无法走代理（这又是另一个悲伤的故事了）。 而且直接更改这两个环境变量总是会导致某些奇奇怪怪的错误产生。所以在不使用vpn的前提下，linux并没有转发所有流量的真全局代理。但是可以用<strong>proxychains-ng</strong>为程序指定走代理，从而变相达到全局代理。</p><p><strong>安装</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/rofl0r/proxychains-ng<span class="token builtin class-name">cd</span> proxychains-ng./configure --prefix<span class="token operator">=</span>/usr --sysconfdir<span class="token operator">=</span>/etc<span class="token function">make</span> <span class="token function">make</span> <span class="token function">install</span><span class="token function">make</span> install-config<span class="token builtin class-name">cd</span> <span class="token punctuation">..</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -rf proxychains-ng</code></pre><p><strong>配置</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/proxychains.conf<span class="token comment">#socks4         127.0.0.1 9050 </span>socks5 <span class="token number">127.0</span>.0.1 <span class="token punctuation">&#123;</span>you_local_port<span class="token punctuation">&#125;</span></code></pre><p>注释或删除掉最后一行的默认配置，然后添加你的代理端口，现在你只需要在程序前面加上<code>proxychains4</code>就可以走代理执行命令。</p><p>比如<code>proxychains4 curl cip.cc</code></p><p><strong>别名</strong></p><p><code>proxychains4</code>也太长了吧。所以给它取个别名把</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#bash</span><span class="token function">vim</span> ~/.bashrc<span class="token comment">#zsh</span><span class="token function">vim</span> ~/.zshrc</code></pre><p>在末尾追加</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">pxy</span><span class="token operator">=</span>proxychains4</code></pre><p>然后退出</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#bash</span><span class="token builtin class-name">source</span> ~/.bashrc<span class="token comment">#zsh</span><span class="token builtin class-name">source</span> ~/.zshrc</code></pre><h3 id="回到心心念念的v2ray">回到心心念念的v2ray</h3><p>虽说trojan确实配置简单，但也是相对我的服务器一开始无法走代理而言的。既然现在可以走代理了，那么不如再来安装一次V2ray！</p><h4 id="v2ray-core">v2ray-core</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">bash</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">curl</span> -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh<span class="token punctuation">)</span></code></pre><p>官网的一键安装只需要用到这个脚本，无奈在没有代理的情况下，笑死，根本没有<span class="math inline">\(SPEED\)</span>​。</p><p>然后我看了一眼脚本内容，但其实这个脚本有参数可以<strong>选择使用代理下载</strong>。</p><pre class="language-bash" data-language="bash"><code class="language-bash">-p, --proxy     <span class="token comment">#Download through a proxy server, e.g., -p http://127.0.0.1:8118 or -p socks5://127.0.0.1:1080'</span></code></pre><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pxy <span class="token function">wget</span> https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh<span class="token function">sudo</span> <span class="token function">bash</span> install-release.sh -p socks5://127.0.0.1:<span class="token punctuation">&#123;</span>you_local_port<span class="token punctuation">&#125;</span></code></pre><p>不出意外的话应该就成功地安装完成了，而且官方脚本不需要我们自己写<code>systemd</code>配置，然后把<code>trojan</code>关一下。先不用管v2ray的服务。</p><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl stop trojanststemctl disable trojan</code></pre><h4 id="v2raya">v2raya</h4><p><code>v2raya</code>在web端提供了GUI，省去了切换节点修改配置文件的麻烦。能像其他客户端一样一键订阅可太方便了。</p><p>Ubuntu(Debian)</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> -qO - https://apt.v2raya.mzz.pub/key/public-key.asc <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -<span class="token builtin class-name">echo</span> <span class="token string">"deb https://apt.v2raya.mzz.pub/ v2raya main"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/apt/sources.list.d/v2raya.list<span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> v2raya</code></pre><p>CentOS</p><p>在https://github.com/v2rayA/v2rayA/releases下载对应的rpm包</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://github.com/v2rayA/v2rayA/releases/download/v1.5.1/installer_redhat_x64_v1.5.1.rpm<span class="token function">sudo</span> y -i installer_redhat_x64_v1.5.1.rpm</code></pre><p><strong>配置</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#打开2017端口</span>firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span><span class="token number">2017</span> --permanent<span class="token comment"># 启动 v2raya</span>systemctl start v2raya<span class="token comment"># 开机自启 v2raya</span>systemctl <span class="token builtin class-name">enable</span> v2raya</code></pre><p>然后可以访问<code>http://localhost:2017/</code>或者<code>http://&#123;your_vps_IP&#125;:2017/</code>进行配置</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210827185428.png" alt="image-20210827185428715" style="zoom: 50%;" / loading="lazy"></p><p>然后就可以通过导入订阅连接或者Vmess的方式（同其他端的操作一致）</p><p>最后是设置，将socks5端口改成之前的{your_local_port}这样就可以继续使用pxy进行全局代理</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210827185616.png" alt="image-20210827185616188" style="zoom:50%;" / loading="lazy"></p><h3 id="参考">参考</h3><p><a href="https://v2raytech.com/trojan-one-click-scrip/">trojan一键脚本</a></p><p><a href="https://www.cnblogs.com/BOHB-yunying/articles/12205099.html">Centos 7安装Proxychains实现Linux 代理</a></p><p><a href="https://p4gefau1t.github.io/trojan-go/basic/full-config/">Trojan-Go Docs</a></p><p><a href="https://github.com/v2rayA/v2rayA">v2rayA</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;手机和PC上都是直接V2ray+机场直接走了，一直没认真配过，没想到一搞就是一天……&lt;/p&gt;
&lt;p&gt;买的腾讯云学生机git速度感人 –&amp;gt; V2ray客户端 –&amp;gt; git V2速度感人 –&amp;gt; ……-&amp;gt; 白嫖Azure大失败 –&amp;gt; ……–&amp;gt;trojan真好用&lt;/p&gt;</summary>
    
    
    
    <category term="项目经历" scheme="http://lapras.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="分享" scheme="http://lapras.xyz/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="网络" scheme="http://lapras.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>暑假补题记录(2)</title>
    <link href="http://lapras.xyz/2021/07/27/468672cb.html"/>
    <id>http://lapras.xyz/2021/07/27/468672cb.html</id>
    <published>2021-07-26T16:00:00.000Z</published>
    <updated>2021-09-03T03:43:09.058Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>莫队真好写 在学了在学了 <del>学完就写篇博客</del></p><span id="more"></span><h1 id="i-love-counting">I love counting</h1><h3 id="描述">描述</h3><blockquote><p><strong>Problem Description</strong></p><p>Mr W likes interval counting.</p><p>One day,Mr W constructed a sequence of length n, each position of this sequence has a weight c (c≤n).</p><p>There are a total of Q queries, and each query is given an interval (l,r) and two parameters a, b, and ask how many kinds of weights of this interval satisfy c⨁a≤b where ⨁ is the binary Bitwise XOR operation.</p><p><strong>Input</strong></p><p>There is only one test case for this question.</p><p>In the first line contains a positive integer n (n≤100000) represents the length of the sequence.</p><p>In the second line contains n positive integers, The i-th number in the sequence represents the weight ci (1≤ci≤n)of the i-th position.</p><p>In the third line, a positive integer Q (Q≤100000) represents the number of queries.</p><p>In the next Q line, each line has four positive integers l, r, a, b (1≤l≤r≤n,a≤n+1,b≤n+1), which represent the parameters of the query.</p><p><strong>Output</strong></p><p>For each query, output an integer on a line to represent the number of weights that meet the conditions.</p><p><strong>Sample Input</strong></p><pre class="language-none"><code class="language-none">&gt;5&gt;1 2 2 4 5&gt;4&gt;1 3 1 3&gt;2 4 4 2&gt;1 5 2 3&gt;4 5 3 6</code></pre><p><strong>Sample Output</strong></p><pre class="language-none"><code class="language-none">&gt;2&gt;1&gt;2&gt;1</code></pre></blockquote><h3 id="题意分析">题意分析</h3><p>对于一个序列的多区间的离线询问问题，就可以考虑选择莫队。用莫队维护每次询问的<strong>每个块内元素种类</strong>，以及<strong>i元素是否在当前询问区间内</strong>。</p><p>分析题目的核心条件： <span class="math inline">\(c⨁a\le b\)</span>​​ 。先考虑小于号的情况，二进制展开后从高到底考虑。</p><p>第<span class="math inline">\(j\)</span>​位：</p><p>如果b是1，a是1，那么c是1，一定小于b</p><p>如果b是1，a是0，那么c是0，一定小于b</p><p>如果b是0，a是1，那么c只能是1才有可能小于b</p><p>如果b是0，a是0，那么c只能是0才有可能小于b</p><p>那么，我们只需要统计一定小于的情况（使用前缀和的思想）。最后加上<span class="math inline">\(c⨁a = b\)</span>的情况（<span class="math inline">\(c=a ⨁ b\)</span>​）</p><h3 id="算法">算法</h3><h4 id="莫队">莫队</h4><p>暂时先不仔细展开了，后续如果学完莫队就更一篇博客连接。这里先简单介绍一下，这题莫队的部分</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Mo</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> id<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//莫队的结构体定义，其中id是来保存询问的顺序的</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>l<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> q <span class="token operator">+</span> m<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Mo x<span class="token punctuation">,</span> Mo y<span class="token punctuation">)</span>       <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span>l <span class="token operator">/</span> k <span class="token operator">==</span> y<span class="token punctuation">.</span>l <span class="token operator">/</span> k <span class="token operator">?</span> x<span class="token punctuation">.</span>r <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>r <span class="token operator">:</span> x<span class="token punctuation">.</span>l <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>l<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//莫队核心1：对询问区间进行排序。相同块比较r，不同块比较l</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">></span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>l<span class="token punctuation">)</span>      <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">--</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//区间左端点向左扩大</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>l<span class="token punctuation">)</span>      <span class="token function">sub</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//区间左端点向右扩大</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">)</span>      <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">++</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//区间右端点向右扩大</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">></span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">)</span>      <span class="token function">sub</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>r<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//区间右端点向左减少</span>    <span class="token comment">//莫队核心2：区间的移动通过加减两边元素达成</span>  ｝</code></pre><h4 id="核心代码">核心代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">ask</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token comment">//经典的分块求和</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> x <span class="token operator">/</span> k <span class="token operator">*</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> x<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    res <span class="token operator">+=</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> x <span class="token operator">/</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    res <span class="token operator">+=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> t <span class="token operator">=</span> s<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">>></span> j <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">>></span> j <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span>          t <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">;</span>        <span class="token keyword">else</span>          s <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">;</span>        ans<span class="token punctuation">[</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token function">ask</span><span class="token punctuation">(</span>t <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">ask</span><span class="token punctuation">(</span>t <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//前缀和更新答案</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">else</span>      <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">>></span> j <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span>          s <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    ans<span class="token punctuation">[</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">+=</span> c<span class="token punctuation">[</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a <span class="token operator">^</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//加上相等的一个或者没有</span></code></pre><ul><li><code>b &gt;&gt; j &amp; 1</code>这是一定可以更新答案的小于情况</li><li><code>ans[q[i].id] += ask(t + (1 &lt;&lt; j) - 1) - ask(t - 1);</code> 这是更新第j位为1的答案</li></ul><h4 id="完整程序">完整程序</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">150000</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">998244353</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span>LL m<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//m储存下标为i的最大值，s储存下标为i~n的最大值</span>LL a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">inline</span> LL <span class="token function">Max</span><span class="token punctuation">(</span>LL a<span class="token punctuation">,</span> LL b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> t<span class="token punctuation">;</span>  cin <span class="token operator">>></span> t<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    LL ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        m<span class="token punctuation">[</span>i <span class="token operator">&amp;</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Max</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span>i <span class="token operator">&amp;</span> j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>      s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Max</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      ans <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      ans <span class="token operator">=</span> ans <span class="token operator">%</span> M<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="i-love-max-and-multiply">I love max and multiply</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=6971">原题</a></p><h3 id="题意分析-1">题意分析</h3><p><span class="math inline">\(c_k = max(a_ib_j) (i\&amp;j \ge k)\)</span>​​​,求其和</p><p>这篇博客讲的很好 <a href="https://www.cnblogs.com/Bamboo-Wind/p/15059655.html">HDU6971. I love max and multiply数学推理部分</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;莫队真好写 在学了在学了 &lt;del&gt;学完就写篇博客&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="http://lapras.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++" scheme="http://lapras.xyz/tags/C/"/>
    
    <category term="算法" scheme="http://lapras.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>暑假补题记录(1)</title>
    <link href="http://lapras.xyz/2021/07/21/6dab2108.html"/>
    <id>http://lapras.xyz/2021/07/21/6dab2108.html</id>
    <published>2021-07-21T00:58:00.000Z</published>
    <updated>2021-09-03T03:43:09.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>第一次正经打ICPC赛制的比赛。和队友合力砍下24的罚时，可喜可贺，可喜可贺……莫队在学了在学了……</p><span id="more"></span><h2 id="mod-or-and-everything">1001 Mod, Or and Everything</h2><h3 id="描述">描述</h3><blockquote><p><strong>Problem Description</strong></p><p>You are given an integer n.</p><p>You are required to calculate (n mod 1) or (n mod 2) or ... or (n mod (n - 1)) or (n mod n).</p><p>The "or" operation means "bitwise OR".</p><p><strong>Input</strong></p><p>The first line contains an integer <span class="math inline">\(T(1≤T≤5000\)</span>)representing the number of test cases.</p><p>For each test case, there is an integer <span class="math inline">\(n(1≤n≤10^{12}\)</span>​​)in one line.</p><p><strong>Sample Input</strong></p><pre class="language-none"><code class="language-none">512345</code></pre><p><strong>Sample Output</strong></p><pre class="language-none"><code class="language-none">00113</code></pre></blockquote><h3 id="题意分析">题意分析</h3><p>求将n模1到n-1的值全部<strong>按位或</strong>的结果，其中<strong>按位或</strong>就是指用二进制展开之后，逐位进行或运算。</p><p>以5为例，<code>5 % 1 = 0</code> <code>5 % 2 = 1</code> <code>5 % 3 = 2</code> <code>5 % 4 = 1</code>,那也就是<code>0|1|2|1</code>,二进制展开得<code>00|01|10|01</code></p><p>显然答案是11也就是3，可以发现只有数位为1的数才会对答案有贡献。那么问题就可以转化成求取的n-1个值全部转化为二进制表示之后，可以得到多少个不重复的值为1的数位。</p><p>继续打表寻找规律，可以发现：</p><ul><li><code>n mod i</code>会在中间取到一个最大值m，对于偶数来说i是 <code>n/2 + 1</code> ，对奇数是<code>(n+1) / 2</code></li><li>进一步观察可以发现m的值也可以直接得到,对于偶数来说m是 <code>n/2 - 1</code> ，对奇数是 <code>(n-1) / 2</code></li><li>打表可得，当i&lt;=m时，有<code>n mod (n-i)=i</code>，换句话说就是可以取得从0~m的所有值，再换言之就是可以把m的二进制位数全用1铺满</li></ul><p>显然只需把m变成二进制数，然后求得m的位数k，那么答案就是<span class="math inline">\(2^k-1\)</span></p><p>问题就变成了<strong>如何计算一个十进制数字的二进制位数</strong></p><h3 id="算法">算法</h3><h4 id="朴素算法">朴素算法</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span><span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span>m<span class="token operator">>>=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> cnt<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>不适用于负数（补码前面全是1）</li><li>考虑到m为<span class="math inline">\(5*10^{11}\)</span>​也就可以达到<span class="math inline">\(2^{40}\)</span>​，emmmm这个常数显然有点大</li></ul><h4 id="打表二分">打表+二分</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ll powo<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//储存从2^0 ~2^49</span><span class="token keyword">int</span> <span class="token function">binSearch</span><span class="token punctuation">(</span>ll n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">49</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> r <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>powo<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> n<span class="token punctuation">)</span>      r <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token keyword">else</span>      l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><span class="math inline">\(O(logn)\)</span></li><li>打表高，二分硬，直接进行一个log的优化</li></ul><h4 id="位运算">位运算</h4><p>经过再进一步的观察：</p><p>如果 <code>lowbit(n) == n</code>，显然n为2的幂次数，也是偶数，那么m就是<code>n/2 - 1</code> ，并且m的二进制一定是全1的。</p><p>例如： n为16-&gt;10000，m为<code>(10000 &gt;&gt; 1)- 1</code>即为111</p><p>那么我们不需要计算位数就能直接得到答案。（注意特判0）</p><p>推广开来，只需要得到n的2进制表示，然后只取首1，其余全0，就得到<span class="math inline">\(2^k\)</span>,再减去1就是答案</p><p>附上STD：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LL</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span>LL T<span class="token punctuation">,</span>n<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>T<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">-</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0ll</span><span class="token punctuation">,</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//特判0</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">-</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>n<span class="token punctuation">)</span>n<span class="token operator">-=</span><span class="token punctuation">(</span>n<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">-</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过不断的减去lowbit 达成首1全0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><span class="math inline">\(O(logn)\)</span></li></ul><h2 id="minimum-spanning-tree">1005 Minimum spanning tree</h2><h3 id="描述-1">描述</h3><blockquote><p><strong>Problem Description</strong></p><p>Given n-1 points, numbered from 2 to n, the edge weight between the two points a and b is lcm(a, b). Please find the minimum spanning tree formed by them.</p><p>A minimum spanning tree is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. That is, it is a spanning tree whose sum of edge weights is as small as possible.</p><p>lcm(a, b) is the smallest positive integer that is divisible by both a and b.</p><p><strong>Input</strong></p><p>The first line contains a single integer t (t&lt;=100) representing the number of test cases in the input. Then t test cases follow.</p><p>The only line of each test case contains one integers n (2&lt;=n&lt;=10000000) as mentioned above.</p><p><strong>Output</strong></p><p>For each test case, print one integer in one line, which is the minimum spanning tree edge weight sum.</p><p><strong>Sample Input</strong></p><pre class="language-none"><code class="language-none">&gt;2&gt;2&gt;6</code></pre><p><strong>Sample Output</strong></p><pre class="language-none"><code class="language-none">&gt;0&gt;26</code></pre></blockquote><h3 id="题意分析-1">题意分析</h3><p>给 n-1 个点，编号 2~n ，要求连边变成一棵树，边权为 lcm(i, j) ，求树所有边权之和的最小值</p><blockquote><p>考虑编号为 i, j 的两个点，根据 lcm 的性质<span class="math inline">\(lcm(i,j) = i*j/gcd(i,j)\)</span>。那么，对于所有的质数，我们都应该直接连边到 2 号点上，所有的合数都连边到其任意因子编号点上。那么，对于质数 i ，它对边权和的贡献仅为 i<em>2，对于合数 i ，它对边权和的贡献仅为 i。所以，计算最小的边权和，需要计算 2~n 内的质数和 S1 以及合数和 S2，得出最终答案为 S1 </em> 2 + S2 。通过线性筛，我们能够在 O(n) 的时间复杂度下解决该问题</p><p>​ 圆形战士 J.C</p></blockquote><p>​</p><h3 id="算法-1">算法</h3><h4 id="线性筛">线性筛</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// primes[]存储所有素数</span><span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// st[x]存储x是否被筛掉</span><span class="token keyword">void</span> <span class="token function">getPrime_eu</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>      primes<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      st<span class="token punctuation">[</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><span class="math inline">\(O(n)\)</span></li><li>核心思想：用每个数的最小质因子筛掉合数，保证每个合数只被标记一次，从而在埃筛<span class="math inline">\(O(nlognlogn)\)</span>的基础上进一步优化</li><li><code>primes[j] &lt;= n / i</code>保证不会筛大于<span class="math inline">\(n\)</span>​的数</li><li>当<code>i % primes[j] != 0</code>时,说明此时遍历到的<span class="math inline">\(primes[j]\)</span>​不是<span class="math inline">\(i\)</span>​的质因子，那么只可能是此时的<span class="math inline">\(primes[j]&lt;i\)</span>的最小质因子,所以<span class="math inline">\(primes[j]*i\)</span>的最小质因子就是<span class="math inline">\(primes[j]\)</span></li><li>当<code>i % primes[j] == 0</code>时,说明此时遍历到的<span class="math inline">\(primes[j]\)</span>​是<span class="math inline">\(i\)</span>​的最小质因子，因此<span class="math inline">\(primes[j]*i\)</span>​的最小质因子也就应该是<span class="math inline">\(primes[j]\)</span>​</li></ul><h4 id="完整程序">完整程序</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10000000</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span> <span class="token comment">// primes[]存储所有素数</span><span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// st[x]存储x是否被筛掉</span>ll ans<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment">//答案打表</span><span class="token keyword">void</span> <span class="token function">getPrime_eu</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>      primes<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      st<span class="token punctuation">[</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> t<span class="token punctuation">;</span>  cin <span class="token operator">>></span> t<span class="token punctuation">;</span>  <span class="token function">getPrime_eu</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>  ans<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//没有被筛掉说明是素数</span>      ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>    <span class="token keyword">else</span>      ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><span class="math inline">\(O(n)\)</span></li></ul><h2 id="maximal-submatrix">1008 Maximal submatrix</h2><h3 id="描述-2">描述</h3><blockquote><p><strong>Problem Description</strong></p><p>Given a matrix of n rows and m columns,find the largest area submatrix which is non decreasing on each column</p><p><strong>Input</strong></p><p>The first line contains an integer T(1≤T≤10)representing the number of test cases. For each test case, the first line contains two integers n,m(1≤n,m≤2∗103)representing the size of the matrix the next n line followed. the i-th line contains m integers <span class="math inline">\(v_{ij} (1≤ v_{ij}≤5∗10^3)\)</span>representing the value of matrix It is guaranteed that there are no more than 2 testcases with n∗m&gt;10000</p><p><strong>Output</strong></p><p>For each test case, print a integer representing the Maximal submatrix</p><p><strong>Sample Input</strong></p><pre class="language-none"><code class="language-none">&gt;1&gt;2 3&gt;1 2 4&gt;2 3 3</code></pre><p><strong>Sample Output</strong></p><pre class="language-none"><code class="language-none">&gt;4</code></pre></blockquote><h3 id="题意分析-2">题意分析</h3><p>给一个<span class="math inline">\(n*m\)</span>的矩阵，求其中每列不递减的最大面积子矩阵。</p><p>我们可以这样处理矩阵，遍历每一列如果不递减就++，反之变为1。之后，我们以行的视角观察得到的新矩阵，就会发现是n行的柱形图。那么问题就转化为了在n行柱形图中求最大矩形的面积。那么， <del>很自然</del>想到单调栈。</p><h3 id="算法-2">算法</h3><h4 id="处理矩阵">处理矩阵</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> mat<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>      mat1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> mat1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>      mat1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span></code></pre><h4 id="单调栈求柱形图最大面积">单调栈求柱形图最大面积</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>h<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span>  <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  h<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//防止h递增导致答案无法更新</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> h<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">>=</span> h<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> height <span class="token operator">=</span> h<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> i <span class="token operator">*</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span>        ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>维护一个单调递增栈，所有元素各进栈和出栈一次即可。每个元素出栈的时候更新最大的矩形面积。</li><li>栈内存放的是下标，用于计算宽度 = $i $与 <span class="math inline">\(s.top()\)</span> 之间的柱子个数</li><li><strong>面积 = 弹出的高度 * 宽度</strong></li></ul><h4 id="完整程序-1">完整程序</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stack></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">2e3</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> mat<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> mat1<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> t<span class="token punctuation">;</span>  cin <span class="token operator">>></span> t<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> mat<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>          mat1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> mat1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>          mat1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> h<span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        h<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>mat1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><span class="math inline">\(O(m*n)\)</span></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;第一次正经打ICPC赛制的比赛。和队友合力砍下24的罚时，可喜可贺，可喜可贺……莫队在学了在学了……&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="http://lapras.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++" scheme="http://lapras.xyz/tags/C/"/>
    
    <category term="算法" scheme="http://lapras.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的数据结构-堆</title>
    <link href="http://lapras.xyz/2021/04/07/170718db.html"/>
    <id>http://lapras.xyz/2021/04/07/170718db.html</id>
    <published>2021-04-07T06:36:35.000Z</published>
    <updated>2021-10-16T02:21:52.439Z</updated>
    
    <content type="html"><![CDATA[<p>实习周摸鱼真不戳啊真不戳</p><span id="more"></span><h2 id="堆heap">堆（Heap）</h2><h2 id="二叉堆binary-heap">二叉堆(Binary Heap)</h2><h3 id="基本性质">基本性质</h3><ul><li>二叉堆是一棵<strong>完全二叉树</strong></li><li>每个节点的键值都大于等于/小于等于其父结点的键值。<ul><li>每个节点的键值都大于等于其父结点键值的堆叫<strong>小根堆/最小堆</strong>，</li><li>每个节点的键值都小于等于其父结点键值的堆叫<strong>大根堆/最大堆</strong>。</li><li><a href="https://oi-wiki.org/lang/csl/container-adapter/#_13">STL 中的 <code>priority_queue</code></a> 其实就是一个大根堆。</li></ul></li></ul><h4 id="存储实现">存储实现</h4><p>选择的是静态数组创建树的方式</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElementType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">HeapNode</span> <span class="token operator">*</span>MaxHeap<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">HeapNode</span><span class="token punctuation">&#123;</span>  ElementType <span class="token operator">*</span>Data<span class="token punctuation">;</span> <span class="token comment">//储存堆键值的数组</span>  <span class="token keyword">int</span> Size<span class="token punctuation">;</span>          <span class="token comment">//堆的当前元素</span>  <span class="token keyword">int</span> Capacity<span class="token punctuation">;</span>      <span class="token comment">//堆的最大容量</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="操作集">操作集</h3><pre class="language-c" data-language="c"><code class="language-c">MaxHeap <span class="token function">CtreatHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxSize<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//创建空堆</span><span class="token keyword">void</span> <span class="token function">Insert</span><span class="token punctuation">(</span>MaxHeap H<span class="token punctuation">,</span> ElementType item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//插入一个元素</span>ElementType <span class="token function">DeleteMax</span><span class="token punctuation">(</span>MaxHeap H<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 从最大堆H中取出键值为最大的元素，并删除一个结点</span><span class="token keyword">void</span> <span class="token function">BuildHeap</span><span class="token punctuation">(</span>MaxHeap H<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//建堆</span></code></pre><h4 id="插入">插入</h4><p>以大根堆为例，插入操作要保证插入后的二叉堆也是一颗<strong>完全二叉树</strong>。显然，我们选择最底层的最右边进行插入，然后令其与其父节点比较，<strong>向上调整</strong>。 值得一提的是，如果当前插入的元素大于堆中的任意元素则需要特判，或者在定义堆时建立了<strong>哨兵0</strong>（大于取值范围的最大值）。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Insert</span><span class="token punctuation">(</span>MaxHeap H<span class="token punctuation">,</span> ElementType item<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsFull</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//堆满</span>  <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Heap is Fulled!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token operator">++</span>H<span class="token operator">-></span>Size<span class="token punctuation">;</span> H<span class="token operator">-></span>Data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> item<span class="token punctuation">;</span> i <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">//在最小处开始，向上调整</span>    H<span class="token operator">-></span>Data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token operator">-></span>Data<span class="token punctuation">[</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                 <span class="token comment">//父结点向下</span>  H<span class="token operator">-></span>Data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>                             <span class="token comment">//插入</span><span class="token punctuation">&#125;</span></code></pre><ul><li>O(logn)</li></ul><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092927.gif" alt="GIF 2021-4-7 23-19-52" style="zoom:67%;" / loading="lazy"></p><h4 id="删除">删除</h4><blockquote><p>删除操作指删除堆中最大的元素，即删除根结点。</p><p>但是如果直接删除，则变成了两个堆，难以处理。</p><p>所以不妨考虑插入操作的逆过程，设法将根结点移到最后一个结点，然后直接删掉。</p><p>然而实际上不好做，我们通常采用的方法是，把根结点和最后一个结点直接交换。</p><p>于是直接删掉（在最后一个结点处的）根结点，<strong>但是新的根结点可能不满足堆性质</strong>……</p><p><strong>向下调整</strong>：在该结点的儿子中，找一个最大的，与该结点交换，重复此过程直到底层。</p><p>可以证明，删除并向下调整后，没有其他结点不满足堆性质。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c">ElementType <span class="token function">DeleteMax</span><span class="token punctuation">(</span>MaxHeap H<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> Parent<span class="token punctuation">,</span> Child<span class="token punctuation">;</span>  ElementType MaxItem<span class="token punctuation">,</span> X<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"最大堆已为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  MaxItem <span class="token operator">=</span> H<span class="token operator">-></span>Data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 取出根结点</span>  <span class="token comment">/* 用最大堆中最后一个元素与根节点交换后从根结点开始向下调整 */</span>  X <span class="token operator">=</span> H<span class="token operator">-></span>Data<span class="token punctuation">[</span>H<span class="token operator">-></span>Size<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录最小值X注意当前堆的规模要减小</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>Parent <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> Parent <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> H<span class="token operator">-></span>Size<span class="token punctuation">;</span> Parent <span class="token operator">=</span> Child<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    Child <span class="token operator">=</span> Parent <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Child <span class="token operator">!=</span> H<span class="token operator">-></span>Size<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>H<span class="token operator">-></span>Data<span class="token punctuation">[</span>Child<span class="token punctuation">]</span> <span class="token operator">&lt;</span> H<span class="token operator">-></span>Data<span class="token punctuation">[</span>Child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      Child<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// Child指向左右子结点的较大者</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>X <span class="token operator">>=</span> H<span class="token operator">-></span>Data<span class="token punctuation">[</span>Child<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">/* 找到了合适位置 */</span>    <span class="token keyword">else</span>      H<span class="token operator">-></span>Data<span class="token punctuation">[</span>Parent<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token operator">-></span>Data<span class="token punctuation">[</span>Child<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//向下调整</span>  <span class="token punctuation">&#125;</span>  H<span class="token operator">-></span>Data<span class="token punctuation">[</span>Parent<span class="token punctuation">]</span> <span class="token operator">=</span> X<span class="token punctuation">;</span>  <span class="token keyword">return</span> MaxItem<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>O(logn)</li></ul><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092930.gif" alt="GIF 2021-4-7 23-21-02" / loading="lazy"><figcaption aria-hidden="true">GIF 2021-4-7 23-21-02</figcaption></figure><h4 id="建堆">建堆</h4><p>如果用插入建堆，显然是O(nlogn)。<del>那么有没有一种</del></p><p>再来观察一波插入和删除的操作。发现向上调整和向下调整是两个算法的核心，单独抽象出来看看：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">></span> h<span class="token punctuation">[</span>x <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>x <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    x <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//自下而上同插入</span><span class="token keyword">void</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    t <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span> t<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    x <span class="token operator">=</span> t<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//自上而下同删除</span></code></pre><ul><li>考虑使用向上调整：显然复杂度为：<span class="math inline">\(log1+log2+......+logn=O(nlogn)\)</span><del>(留给读者自证)</del>证明见oiwiki</li><li>考虑使用向下调整：不是很显然的得出复杂度为：<span class="math inline">\(nlogn-log1-log2......-logn\le O(n)\)</span></li></ul><p>具体地说明一下：</p><ul><li>考虑现在读入一个无序的二叉堆</li><li>从最后一个具有子结点的结点开始，向下调整建立子堆</li><li>向左移动，重复上述过程</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*----------- 建造最大堆 -----------*/</span><span class="token keyword">void</span> <span class="token function">PercDown</span><span class="token punctuation">(</span>MaxHeap H<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">/* 下滤：将H中以H->Data[p]为根的子堆调整为最大堆 */</span>  <span class="token keyword">int</span> Parent<span class="token punctuation">,</span> Child<span class="token punctuation">;</span>  ElementType X<span class="token punctuation">;</span>  X <span class="token operator">=</span> H<span class="token operator">-></span>Data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 取出根结点存放的值 */</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>Parent <span class="token operator">=</span> p<span class="token punctuation">;</span> Parent <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> H<span class="token operator">-></span>Size<span class="token punctuation">;</span> Parent <span class="token operator">=</span> Child<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    Child <span class="token operator">=</span> Parent <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Child <span class="token operator">!=</span> H<span class="token operator">-></span>Size<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>H<span class="token operator">-></span>Data<span class="token punctuation">[</span>Child<span class="token punctuation">]</span> <span class="token operator">&lt;</span> H<span class="token operator">-></span>Data<span class="token punctuation">[</span>Child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      Child<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">/* Child指向左右子结点的较大者 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>X <span class="token operator">>=</span> H<span class="token operator">-></span>Data<span class="token punctuation">[</span>Child<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">/* 找到了合适位置 */</span>    <span class="token keyword">else</span>      H<span class="token operator">-></span>Data<span class="token punctuation">[</span>Parent<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token operator">-></span>Data<span class="token punctuation">[</span>Child<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  H<span class="token operator">-></span>Data<span class="token punctuation">[</span>Parent<span class="token punctuation">]</span> <span class="token operator">=</span> X<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">BuildHeap</span><span class="token punctuation">(</span>MaxHeap H<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">/* 调整H->Data[]中的元素，使满足最大堆的有序性  */</span>  <span class="token comment">/* 这里假设所有H->Size个元素已经存在H->Data[]中 */</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token comment">/* 从最后一个结点的父节点开始，到根结点1 */</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> H<span class="token operator">-></span>Size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token function">PercDown</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="C:%5CUsers%5CAdministrator%5CDesktop%5CGIF%202021-4-7%2023-23-44.gif" alt="GIF 2021-4-7 23-23-44" style="zoom:67%;" / loading="lazy"></p><p>向上调整O(nlogn)</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092933.gif" alt="GIF 2021-4-7 23-24-45" style="zoom:67%;" / loading="lazy"></p><p>向下调整O(n)</p><h2 id="参考">参考</h2><p>https://oi-wiki.org/ds/heap/</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;实习周摸鱼真不戳啊真不戳&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="http://lapras.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="http://lapras.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lapras.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的数据结构-树（下）</title>
    <link href="http://lapras.xyz/2021/04/01/8022ea89.html"/>
    <id>http://lapras.xyz/2021/04/01/8022ea89.html</id>
    <published>2021-04-01T11:21:25.000Z</published>
    <updated>2021-10-29T02:45:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="清明时节雨纷纷路上行人欲断魂">清明时节雨纷纷，路上行人欲断魂。</h2><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092838.jpeg" / loading="lazy"></p><p>强烈推荐配合<a href="https://visualgo.net/zh/bst">VISUALOGO</a>食用</p><span id="more"></span><h2 id="二叉搜索树binarysearchtrees">二叉搜索树（BinarySearchTrees）</h2><h3 id="基本性质">基本性质</h3><ul><li>非空左子树的所有键值小于其根结点的键值</li><li>非空右子树的所有键值大于其根结点的键值。</li><li>二叉查找树的中序遍历可以得到有序的数据流。</li><li>左、右子树都是二叉搜索树。</li><li>最小元素一定在最左边，最大元素一定在最右边,换言之，最小值的结点一定无左子树，最大值的结点一定无右子树。</li></ul><h3 id="操作集">操作集</h3><pre class="language-c" data-language="c"><code class="language-c">BinTree <span class="token function">Find</span><span class="token punctuation">(</span>ElementType X<span class="token punctuation">,</span> BinTree BST<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回指定Data结点的指针</span>BinTree <span class="token function">Findmin</span><span class="token punctuation">(</span>BinTree BST<span class="token punctuation">)</span><span class="token punctuation">;</span>BinTree <span class="token function">Findmax</span><span class="token punctuation">(</span>BinTree BST<span class="token punctuation">)</span><span class="token punctuation">;</span>BinTree <span class="token function">Insert</span><span class="token punctuation">(</span>BinTree BST<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="查找">查找</h4><pre class="language-c" data-language="c"><code class="language-c">BinTree <span class="token function">Find</span><span class="token punctuation">(</span>ElementType X<span class="token punctuation">,</span> BinTree BST<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>BST<span class="token punctuation">)</span>    <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>X <span class="token operator">></span> BST<span class="token operator">-></span>Data<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">Find</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>X <span class="token operator">&lt;</span> BST<span class="token operator">-></span>Data<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">Find</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    <span class="token keyword">return</span> BST<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>BinTree <span class="token function">Findmin</span><span class="token punctuation">(</span>BinTree BST<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>BST<span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>BST<span class="token operator">-></span>Left<span class="token punctuation">)</span>      BST <span class="token operator">=</span> BST<span class="token operator">-></span>Left<span class="token punctuation">;</span>  <span class="token keyword">return</span> BST<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>BinTree <span class="token function">Findmax</span><span class="token punctuation">(</span>BinTree BST<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>BST<span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>BST<span class="token operator">-></span>Right<span class="token punctuation">)</span>      BST <span class="token operator">=</span> BST<span class="token operator">-></span>Right<span class="token punctuation">;</span>  <span class="token keyword">return</span> BST<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092840.gif" alt="GIF 2021-4-1 20-20-50" style="zoom:50%;" / loading="lazy"></p><h4 id="插入">插入</h4><pre class="language-c" data-language="c"><code class="language-c">BinTree <span class="token function">Insert</span><span class="token punctuation">(</span>ElementType X<span class="token punctuation">,</span> BinTree BST<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>BST<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    BST <span class="token operator">=</span> new TreeNode<span class="token punctuation">;</span>    BST<span class="token operator">-></span>Data <span class="token operator">=</span> X<span class="token punctuation">;</span>    BST<span class="token operator">-></span>Left <span class="token operator">=</span> BST<span class="token operator">-></span>Right <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>X <span class="token operator">&lt;</span> BST<span class="token operator">-></span>Data<span class="token punctuation">)</span>      BST<span class="token operator">-></span>Left <span class="token operator">=</span> <span class="token function">Insert</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>X<span class="token operator">></span>BST<span class="token operator">-></span>Data<span class="token punctuation">)</span>      BST<span class="token operator">-></span>Right <span class="token operator">=</span> <span class="token function">Insert</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> BST<span class="token punctuation">;</span><span class="token comment">//空则返回空，相等则不插入</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092842.gif" alt="GIF 2021-4-1 20-25-35" style="zoom:50%;" / loading="lazy"></p><h4 id="删除">删除</h4><p>前面的查找和插入都比较容易，但是对于删除我们得分析一波：</p><ul><li>删除的结点是叶结点：EZ,直接删除，并且将其父结点的指针指向为nullptr。</li><li>删除的结点有一个子结点：EZ，将其父结点的指针指向其子结点后删除。</li><li>发现以上两种情况可以合并：即将父节点指向该节点的子结点（）</li><li>删除的结点有两个子结点：<ul><li>法1：取左子树中最大值替换该结点</li><li>法2：取右子树中最小值替换该节点</li><li>这样我们就将二子结点变为了有0/1个子结点的情况,而后就可以递归来实现我们的操作</li></ul></li></ul><pre class="language-c" data-language="c"><code class="language-c">BinTree <span class="token function">Delete</span><span class="token punctuation">(</span>ElementType X<span class="token punctuation">,</span> BinTree BST<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  BinTree Temp<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>BST<span class="token punctuation">)</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"要删除的元素未找到"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>X <span class="token operator">&lt;</span> BST<span class="token operator">-></span>Data<span class="token punctuation">)</span>      BST<span class="token operator">-></span>Left <span class="token operator">=</span> <span class="token function">Delete</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//向左递归</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>X <span class="token operator">></span> BST<span class="token operator">-></span>Data<span class="token punctuation">)</span>      BST<span class="token operator">-></span>Right <span class="token operator">=</span> <span class="token function">Delete</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> BST<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//向右递归</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>      <span class="token comment">/* 如果被删除结点有左右两个子结点 */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>BST<span class="token operator">-></span>Left <span class="token operator">&amp;&amp;</span> BST<span class="token operator">-></span>Right<span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        Temp <span class="token operator">=</span> <span class="token function">Findmin</span><span class="token punctuation">(</span>BST<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从右子树中找最小的元素填充删除结点</span>        BST<span class="token operator">-></span>Data <span class="token operator">=</span> Temp<span class="token operator">-></span>Data<span class="token punctuation">;</span>        BST<span class="token operator">-></span>Right <span class="token operator">=</span> <span class="token function">Delete</span><span class="token punctuation">(</span>Temp<span class="token operator">-></span>Data<span class="token punctuation">,</span>BST<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除右子树中最小的结点,并将结果树接回来</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">else</span>      <span class="token punctuation">&#123;</span> <span class="token comment">/* 被删除结点有一个或无子结点 */</span>        Temp <span class="token operator">=</span> BST<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>BST<span class="token operator">-></span>Left<span class="token punctuation">)</span>           BST <span class="token operator">=</span> BST<span class="token operator">-></span>Right<span class="token punctuation">;</span>        <span class="token keyword">else</span>           BST <span class="token operator">=</span> BST<span class="token operator">-></span>Left<span class="token punctuation">;</span>        <span class="token function">delete</span><span class="token punctuation">(</span>Temp<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> BST<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092844.gif" alt="GIF 2021-4-1 20-30-15" style="zoom:50%;" / loading="lazy"></p><h2 id="平衡二叉树balancedbinarytreeavl">平衡二叉树（BalancedBinaryTree/AVL）</h2><p>二叉查找树的查找效率在理想状态下是<strong>O(lgn)</strong>，使用该树进行查找总是比链表快得多。但是，该论点并不总是正确，因为查找效率和二叉树的形状息息相关。就像这样：</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092846.jpeg" alt="img" style="zoom:50%;" / loading="lazy"></p><h3 id="基本性质-1">基本性质</h3><ul><li><p>平衡二叉树是二叉搜索树的子集</p></li><li><p>平衡因子：<strong>左子树高度和右子树高度的差</strong></p></li><li><p>非空树的条件下，任意结点的左右子树高度差&lt;=1，即平衡因子只有-1，0，1三种值。</p></li><li><p>平衡二叉树的搜索期望次数是最低的，换言之他的高度能达到满二叉树的的<span class="math inline">\(log_2n\)</span>：</p><ul><li>显然<span class="math inline">\(N_1=1,N_2=2,N_3=4\)</span></li><li>根据平衡二叉树的定义不难发现高度为h的结点数目最少的平衡二叉树符合: <span class="math inline">\(N_h=N_{h-1}+N_{h-2}+1\)</span></li><li>上述公式是不是有种斐波那契数列的既视感？通过简单的列表归纳，最终得到：<span class="math inline">\(N_h=F_{h+2}-1\)</span></li><li><span class="math inline">\(F_i \approx\frac{1}{\sqrt5}(\frac{1+\sqrt5}{2}^i)\)</span></li><li><span class="math inline">\(N_h\approx\frac{1}{\sqrt5}(\frac{1+\sqrt5}{2}^{h+2})-1\)</span></li></ul></li><li><p>由上式很明显可以看出<span class="math inline">\(h\approx log_2n\)</span></p></li></ul><h3 id="avl的平衡">AVL的平衡</h3><p>显然，当AVL树插入或者删除结点的时候，树的平衡会被打破，换言之会出现+2（插入）或者是-2（删除）的平衡因子。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092848.jpeg" alt="v2-cb3751bc5726d2664787391476e39b25_720w" style="zoom:50%;" / loading="lazy"></p><h4 id="基本操作">基本操作</h4><h5 id="左旋">左旋</h5><p><strong>逆时针</strong>旋转AVL树的两个结点X和Y，使得父结点被自己的右子结点取代，而自己成为自己的左子结点。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092854.jpeg" alt="v2-47d498a63c57af9f8bd1e469c9f7ceef_r" style="zoom: 67%;" / loading="lazy"></p><ul><li>左旋可以提高左子树的高度，降低右子树的高度</li></ul><h5 id="右旋">右旋</h5><p><strong>顺时针</strong>旋转AVL树的两个结点X和Y，使得父结点被自己的左子结点取代，而自己成为自己的右子结点。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092852.jpeg" alt="v2-86b10ae6e319bbaadef69e8401dee163_720w" style="zoom:67%;" / loading="lazy"></p><ul><li>右旋可以提高左子树的高度，降低左子树的高度</li></ul><p>品：<strong>左旋拎右左挂右，右旋拎左右挂左</strong></p><h4 id="应用">应用</h4><h5 id="左左情况ll">左左情况（LL）</h5><blockquote><p>不平衡结点A有一个<strong>左</strong>子结点B，而结点B又有一个<strong>左</strong>子结点C。标号1,2,3,4的三角形是各个结点的子树。</p><p>在这种局面下，我们以结点A为轴，进行<strong>右旋</strong>操作：</p></blockquote><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092858.jpeg" alt="img" style="zoom:67%;" / loading="lazy"></p><h5 id="右右情况rr">右右情况（RR）</h5><blockquote><p>不平衡结点A有一个<strong>右</strong>子结点B，而结点B又有一个<strong>右</strong>子结点C。</p><p>在这种局面下，我们以结点A为轴，进行<strong>左旋</strong>操作：</p></blockquote><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092859.jpeg" alt="v2-8b05f1507e7d61a2ada9b7ff6a16dcb3_720w (2)" style="zoom:67%;" / loading="lazy"></p><h5 id="左右局面lr">左右局面（LR）</h5><blockquote><p>不平衡结点A有一个<strong>左</strong>子结点B，而结点B又有一个<strong>右</strong>子结点C。</p><p>在这种局面下，我们先以结点B为轴，进行<strong>左旋</strong>操作：</p></blockquote><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092904.jpeg" alt="v2-4b5478dd38a9bd8970129da504f80c75_720w" style="zoom:67%;" / loading="lazy"></p><blockquote><p>这样就转化成了左左局面。我们继续以结点A为轴，进行右旋操作：</p></blockquote><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092908.jpeg" alt="v2-0c207419c8861ffe5909b483aaf7bd1a_720w (1)" style="zoom:67%;" / loading="lazy"></p><h5 id="右左局面rl">右左局面（RL）</h5><blockquote><p>不平衡结点A有一个右子结点B，而结点B又有一个左子结点C。</p><p>在这种局面下，我们先以结点B为轴，进行<strong>右旋</strong>操作：</p></blockquote><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092910.jpeg" alt="v2-46e9e5d75fd6d6fe29681456aa52cfd6_720w" style="zoom:67%;" / loading="lazy"></p><blockquote><p>这样就转化成了右局面。我们继续以结点A为轴，进行左旋操作：</p></blockquote><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092913.jpeg" alt="v2-bbeec7d9e0c0b30659e580fb6b324aa7_720w" style="zoom:67%;" / loading="lazy"></p><p>品：左左右右右左旋，左右右左依次旋</p><h3 id="操作集-1">操作集</h3><pre class="language-c" data-language="c"><code class="language-c">AVLTree <span class="token function">SingleLeftRotation</span><span class="token punctuation">(</span>AVLTree A<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//左旋rr</span>AVLTree <span class="token function">SingleRightRotation</span><span class="token punctuation">(</span>AVLTree A<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//右旋ll</span>AVLTree <span class="token function">DoubleLeftRightRotation</span><span class="token punctuation">(</span>AVLTree A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//lr</span>AVLTree <span class="token function">DoubleRightLeftRotation</span><span class="token punctuation">(</span>AVLTree A<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//rl</span></code></pre><pre class="language-c" data-language="c"><code class="language-c">AVLTree <span class="token function">SingleLeftRotation</span><span class="token punctuation">(</span>AVLTree A<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  AVLTree B <span class="token operator">=</span> A<span class="token operator">-></span>Right<span class="token punctuation">;</span><span class="token comment">//左旋拎右</span>  A<span class="token operator">-></span>Right <span class="token operator">=</span> B<span class="token operator">-></span>Left<span class="token punctuation">;</span><span class="token comment">//左挂右</span>  B<span class="token operator">-></span>Left <span class="token operator">=</span> A<span class="token punctuation">;</span><span class="token comment">//父变子</span>  A<span class="token operator">-></span>Height <span class="token operator">=</span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">getHeight</span><span class="token punctuation">(</span>A<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>A<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  B<span class="token operator">-></span>Height <span class="token operator">=</span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">getHeight</span><span class="token punctuation">(</span>B<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">,</span> A<span class="token operator">-></span>Height<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>AVLTree <span class="token function">SingleRightRotation</span><span class="token punctuation">(</span>AVLTree A<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">/* 注意：A必须有一个左子结点B */</span>  <span class="token comment">/* 将A与B做右单旋，更新A与B的高度，返回新的根结点B */</span>  AVLTree B <span class="token operator">=</span> A<span class="token operator">-></span>Left<span class="token punctuation">;</span> <span class="token comment">//右旋拎左</span>  A<span class="token operator">-></span>Left <span class="token operator">=</span> B<span class="token operator">-></span>Right<span class="token punctuation">;</span>  <span class="token comment">//右挂左</span>  B<span class="token operator">-></span>Right <span class="token operator">=</span> A<span class="token punctuation">;</span>        <span class="token comment">//父变子</span>    A<span class="token operator">-></span>Height <span class="token operator">=</span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">getHeight</span><span class="token punctuation">(</span>A<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>A<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  B<span class="token operator">-></span>Height <span class="token operator">=</span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">getHeight</span><span class="token punctuation">(</span>B<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">,</span> A<span class="token operator">-></span>Height<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> B<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>AVLTree <span class="token function">DoubleLeftRightRotation</span><span class="token punctuation">(</span>AVLTree A<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">/* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */</span>  <span class="token comment">/* 将A、B与C做两次单旋，返回新的根结点C */</span>  <span class="token comment">/* 将B与C做左单旋，C被返回 */</span>  A<span class="token operator">-></span>Left <span class="token operator">=</span> <span class="token function">SingleLeftRotation</span><span class="token punctuation">(</span>A<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 将A与C做右单旋，C被返回 */</span>  <span class="token keyword">return</span> <span class="token function">SingleRightRotation</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>AVLTree <span class="token function">DoubleRightLeftRotation</span><span class="token punctuation">(</span>AVLTree A<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">/* 注意：A必须有一个右子结点B，且B必须有一个左子结点C */</span>  <span class="token comment">/* 将A、B与C做两次单旋，返回新的根结点C */</span>  <span class="token comment">/* 将B与C做右单旋，C被返回 */</span>  A<span class="token operator">-></span>Right <span class="token operator">=</span> <span class="token function">SingleRightRotation</span><span class="token punctuation">(</span>A<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 将A与C做左单旋，C被返回 */</span>  <span class="token keyword">return</span> <span class="token function">SingleLeftRotation</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="哈夫曼树haffmantree最优二叉树">哈夫曼树(HaffManTree)/最优二叉树</h2><blockquote><p>哈夫曼树是一类带权路径最短的树。构造这种树的算法最早由哈夫曼提出，这种树在信息检索中很有用。如用于通讯及数据传送中构造传输效率最高的二进制编码（哈夫曼编码），用于编程中构造平均执行时间最短的最佳判断过程。</p></blockquote><p>哈弗曼树的特征就是<strong>带权路径长度(WPL)</strong>最小：</p><p>设二叉树有n个叶子结点,每个叶子结点带有权值<span class="math inline">\(W_k\)</span>,从根结点到每个叶子结点的长度为<span class="math inline">\(L_k\)</span>,则每个叶子结点的带权路径长度之和就是: WPL=<span class="math inline">\(\sum_{k=1}^{n}W_kL_k\)</span></p><p>那么最后我们就会得到一个头重脚轻的哈弗曼树。值得一提的是哈夫曼由于没有限定左右子树的顺序，所以<strong>不是唯一</strong>的。</p><h2 id="哈夫曼树的构建">哈夫曼树的构建</h2><ul><li>对结点按照权进行从小到大的排序</li><li>选择权最小的两个结点从考虑范围内剔除并合并，产生一个父节点，父节点的权为两结点权之和</li><li>把父节点纳入考虑范围 重复上一步骤</li></ul><p>不难发现，对结点的排序可以使用 <strong>最小堆</strong> 来实现（最小堆部分的代码见堆）</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>HuffmanTree<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> Weight<span class="token punctuation">;</span>  HuffmanTree Left<span class="token punctuation">,</span> Right<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>HuffmanTree <span class="token function">Huffman</span><span class="token punctuation">(</span>MinHeap H<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">/*假设H->Size个权值已经存在H->E1ements []->Weight里*/</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  HuffmanTree T<span class="token punctuation">;</span>  <span class="token function">BuildMinHeap</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*将H->Elements []按权值调整为最小堆*/</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> H<span class="token operator">-></span>Size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>                          <span class="token comment">/*做H->size-1次合并*/</span>    T <span class="token operator">=</span> new <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token punctuation">;</span> <span class="token comment">/*建立新结点*/</span>    T<span class="token operator">-></span>Left <span class="token operator">=</span> <span class="token function">DeleteMin</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/*从最小堆中删除一个结点，作为新中的左子结点*/</span>    T<span class="token operator">-></span>Right <span class="token operator">=</span> <span class="token function">DeleteMin</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*从最小堆中删除一个结点，作为新中的右子结点*/</span>    T<span class="token operator">-></span>Weight <span class="token operator">=</span> T<span class="token operator">-></span>Left<span class="token operator">-></span>Weight <span class="token operator">+</span> T<span class="token operator">-></span>Right<span class="token operator">-></span>Weight<span class="token punctuation">;</span>    <span class="token function">Insert</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*将新插入最小堆*/</span>  <span class="token punctuation">&#125;</span>  T <span class="token operator">=</span> <span class="token function">DeleteMin</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> T<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>O(nlogn)</li><li>不存在度为1的结点（构建过程为两个子树的合并）</li><li>n个叶结点的哈夫曼树有2n+1个结点（<span class="math inline">\(n_0=n_2+1)\)</span></li></ul><h2 id="哈夫曼编码">哈夫曼编码</h2><p>上文提及过：哈夫曼编码用于通讯及数据传送中构造传输效率最高的二进制编码。</p><p>对于编码我们可以分为 <strong>等长编码</strong>和 <strong>非等长编码</strong>。</p><p>显然地，类似ASCII RGB 等等都是等长的。这样可以尽量表示更多的字符，且不会有<strong>二义性</strong>的困扰，但是会造成空间上的浪费，比如我使用000~111等长三位编码表示abcdefgh，但是我的字符大部分都是000代表的a，小部分为111代表h，这样就会造成编码上的冗余情况出现。</p><p>考虑非等长编码，我使用0来表示a，111来表示h。还是上述的情况，显然节省了空间，但是会造成二义性。比如010表示的是aba还是ac？对此引入个概念：</p><p><strong>前缀码（peifix code）：任何字符的编码都不是另一字符码的前缀。</strong></p><p>如何实现呢？<del>当然是哈夫曼，不然为什么叫哈夫曼编码？？？</del></p><p>由于哈弗曼树的特点，<strong>所有带有权值的结点只会出现在叶结点处</strong>。规定：<strong>左子结点编码为0，右子结点编码为1</strong>。</p><p>这样一来，上层叶结点的权值大（频率高），字节数小、下层叶结点的权值小（频次低），字节数大。</p><h1 id="参考">参考</h1><p>https://zhuanlan.zhihu.com/p/53851211</p><p><a href="https://zhuanlan.zhihu.com/p/149548859">小灰漫画算法</a></p><p>https://blog.csdn.net/FX677588/article/details/70767446</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;清明时节雨纷纷路上行人欲断魂&quot;&gt;清明时节雨纷纷，路上行人欲断魂。&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092838.jpeg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;强烈推荐配合&lt;a href=&quot;https://visualgo.net/zh/bst&quot;&gt;VISUALOGO&lt;/a&gt;食用&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="http://lapras.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="http://lapras.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lapras.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="http://lapras.xyz/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的数据结构-树（上）</title>
    <link href="http://lapras.xyz/2021/03/28/389e8dec.html"/>
    <id>http://lapras.xyz/2021/03/28/389e8dec.html</id>
    <published>2021-03-28T06:10:35.000Z</published>
    <updated>2021-10-10T07:19:21.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="智慧树上智慧果智慧树下平衡树划分树归并树k-d树pq树主席树树套树">智慧树上智慧果，智慧树下平衡树，划分树，归并树，k-d树，pq树，主席树，树套树。</h3><span id="more"></span><h2 id="树的定义">树的定义</h2><ul><li><p>n 个结点构成的有限集合。</p></li><li><p>当n=0时,称为空树。</p></li><li><p>对于任一棵非空树(n&gt;0) ,它具备以下性质:</p><ul><li><p>树中有一个称为“根(Root) ”的特殊结点,用r表示。</p></li><li><p>其余结点可分为m个互不相交的有限集T, T2, .., , Tm,其中每个集合本身又是一棵树,称为原来树的"子树"(SubTree)。</p></li><li><p>子树是不相交的,除了根结点外,每个结点有且仅有一个父结点。</p></li><li><p>一棵N个结点的树有N-1条边。</p></li></ul></li></ul><h3 id="一些术语">一些术语</h3><ul><li>结点的<strong>度</strong>(Degree) ：结点的子树（子结点）个数</li><li>树的<strong>度</strong>：树的所有结点中最大的度数</li><li>叶结点(Leaf)/外部节点：度为0的结点</li><li>父结点(Parent)：有子树的结点是其子树的根结点的父结点</li><li>子结点(Child)：若A结点是B结点的父结点,则称B结点是A结点的子结点;子结点也称孩子结点。</li><li>兄弟结点(Sibling)：具有同一父结点的各结点彼此是兄弟结点。</li><li>路径和路径长度：从结点<span class="math inline">\(n_1\)</span>到<span class="math inline">\(n_k\)</span>的路径为一个结点序列<span class="math inline">\(n_1,n_2,\cdots,n_k\)</span>,并且<span class="math inline">\(n_i是n_{i+1}\)</span>父结点。则路径所包含边的个数为路径的长度。</li><li>祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。</li><li>子孙结点(Descendant)：某一结点的子树中的所有结点是这个结点的子孙。</li><li>结点的层次(Level)：规定根结点在1层,其它任一结点的层数是其父结点的层数加1.</li><li>深度(Depth)：树中所有结点中的最大层次是这棵树的深度。根的深度为0。</li><li>高度(height)：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有叶结点的高度为0；</li><li>无序树：树中结点的各子树之间的顺序无关，可以交换位置</li><li>有序树：树种结点的各棵子树从左到右顺序相关</li></ul><h2 id="树的表示">树的表示</h2><p>自然而然地，我们会想到用指针来存放一棵树。但毫无疑问地是指针域要按照<strong>树的度</strong>的决定，这样势必就会造成指针域的浪费。</p><p>于是我们引入了一种方法：<strong>左子-右兄弟表示法(left-child right-sibling representation)</strong>：可以将任意树转变为二叉树链表。</p><p><strong>左子-右兄弟表示法</strong>包含的信息：</p><ul><li><p>结点数据（ElementType Data）</p></li><li><p>节点n的父节点（Parent）//基础情况可省略</p></li><li><p>节点n<strong>最左侧</strong>的子结点（Left）</p></li><li><p>节点n<strong>右侧紧邻</strong>的兄弟节点（Right）</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092755.png" alt="image-20210328152116810" / loading="lazy"><figcaption aria-hidden="true">image-20210328152116810</figcaption></figure></li></ul><p>可以和一开始的想法进行对比：</p><p>假设一棵度为 m的树有n个节点。若每个节点直接用m个链指向相应的儿子，则表示这个树所需要的总空间是**n*(m+1)<strong> (假定每个链以及表示节点的数据域都是一个单位空间).。当采用</strong>左子-右兄弟表示法(left-child right-sibling representation)<strong>表示法时，所需的总空间是</strong>3n**。</p><h2 id="二叉树binarytree">二叉树(BinaryTree)</h2><p>作为最基本也是最重要的树结构，请务必能倒写二叉树。</p><ul><li>二叉树是一个有穷的结点集合。</li><li>这个集合可以为空</li><li>若不为空,则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。</li><li>二叉树具有五种基本形态</li></ul><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092753.png" alt="image-20210328155942742" / loading="lazy"><figcaption aria-hidden="true">image-20210328155942742</figcaption></figure><h3 id="二叉树的性质">二叉树的性质</h3><ul><li>第i层的最大结点数为：<span class="math inline">\(2^{i-1}\)</span><span class="math inline">\((i\ge1)\)</span></li><li>深度为k的二叉树的最大结点总数：<span class="math inline">\(2^k-1(k\ge1)\)</span> （显然最大时为满二叉树）</li><li>包含n个结点的的二叉树的高度<strong>最矮</strong>为：<span class="math inline">\([log_2(n+1)]\)</span>（最矮的情况为完全二叉树）</li><li>对于任何非空的二叉树T，若<span class="math inline">\(n_0\)</span>表示叶结点的个数，<span class="math inline">\(n_1\)</span>是度为1的非叶结点的个数,<span class="math inline">\(n_2\)</span>是度为2的非叶结点的个数，那么满足公式：<span class="math inline">\(n_0=n_2+1\)</span>。</li><li>二叉树边的个数：<span class="math inline">\(n_0+n_1+n_2-1=0\times n_0+1\times n_1+2\times n_2\)</span></li></ul><h3 id="特殊的二叉树">特殊的二叉树</h3><h4 id="斜二叉树">斜二叉树</h4><p>只有左子结点或只有右子结点的二叉树称为斜二叉树</p><h4 id="满二叉树">满二叉树</h4><p>满二叉树除了叶结点外所有节点都有两个子节点，且叶结点都在同一层。</p><p>换句话说，除了最后一层的叶结点，以上所有父结点必须有且只有两个子结点。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092748.webp" alt="img" / loading="lazy"><figcaption aria-hidden="true">img</figcaption></figure><h4 id="完全二叉树">完全二叉树</h4><p>对一棵具有n个结点的二叉树按层序编号，则编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点位置完全相同</p><p>换句话说，从根结点开始往下数，除了最下层外都是全满（都有两个子节点），而最下层所有叶结点都向左边靠拢填满。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092747.webp" alt="img" / loading="lazy"><figcaption aria-hidden="true">img</figcaption></figure><ul><li>完全二叉树的高度：<span class="math inline">\(log_2(n+1)\)</span></li><li>从0开始按照层序遍历对结点编号：<ul><li>i = 0：根结点</li><li>i &gt; 0：父结点为 <span class="math inline">\([(i-1)/2]\)</span></li><li>2i +1 &lt; n：则该节点的左子结点为 <span class="math inline">\(2i+1\)</span></li><li>2i +2 &lt; n：则该节点的右子结点为 <span class="math inline">\(2i+2\)</span></li></ul></li></ul><h4 id="扩充二叉树">扩充二叉树</h4><p>除叶结点外，其余结点都必须有两个子结点</p><h3 id="二叉树的实现">二叉树的实现</h3><h4 id="存储实现数组">存储实现（数组）</h4><p>首先来看完全二叉树的数组实现（这里选择从1开始编号）</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092744.png" alt="image-20210328170317981" style="zoom:50%;" / loading="lazy"></p><ul><li>非根结点的父结点的序号是<strong>[i/2]</strong>（[]表示向下取整）</li><li>结点的左子结点的序号是<strong>2i</strong>（2i<span class="math inline">\(\le\)</span>n）</li><li>结点的右子结点的序号是<strong>2i+1</strong>（2i+1<span class="math inline">\(\le\)</span>n）</li></ul><p>那么考虑一般的二叉树，是否也可以通过补全为完全二叉树的方式来进行数组的存储实现呢？</p><p>来看这样一个普通的二叉树：</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092742.png" alt="graph" style="zoom:50%;" / loading="lazy"></p><p>将其补全为完全二叉树：</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092737.png" alt="graph (2)" style="zoom:50%;" / loading="lazy"></p><table><thead><tr class="header"><th style="text-align: left;">结点名称</th><th style="text-align: left;">A</th><th style="text-align: left;">B</th><th style="text-align: left;">C</th><th style="text-align: left;">1</th><th style="text-align: left;">2</th><th style="text-align: left;">D</th><th style="text-align: left;">3</th><th style="text-align: left;">4</th><th>5</th><th>6</th><th>7</th><th>E</th><th>8</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">数组序号</td><td style="text-align: left;">1</td><td style="text-align: left;">2</td><td style="text-align: left;">3</td><td style="text-align: left;">4</td><td style="text-align: left;">5</td><td style="text-align: left;">6</td><td style="text-align: left;">7</td><td style="text-align: left;">8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td></tr></tbody></table><p>显然也符合完全二叉树的规律。但毫无疑问，这会造成空间的浪费。比如十个结点的树，考虑最坏情况就得开1024+5的数组。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">createTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>BinTree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> Data<span class="token punctuation">;</span>  <span class="token keyword">int</span> index<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> Data<span class="token punctuation">;</span>    index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//index从1开始避免后续奇怪的麻烦</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>BinTree<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//父节点不为空</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 寻找插入点</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>Data <span class="token operator">>=</span> BinTree<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//右子结点</span>        index <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">else</span><span class="token comment">//左子结点</span>        index <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    BinTree<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> Data<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="存储实现链表">存储实现（链表）</h4><p>先说说比较简单的<strong>静态链表：</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token punctuation">&#123;</span>  ElementType Data<span class="token punctuation">;</span>  <span class="token keyword">int</span> Left<span class="token punctuation">;</span>  <span class="token keyword">int</span> Right<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>T<span class="token punctuation">[</span>MaxN<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092811.png" alt="image-20210331202227774" style="zoom:50%;" / loading="lazy"></p><ul><li><p>-1表示空节点</p></li><li><p>可以通过建立一个flag数组，在记录二叉树时的左右结点时修改flag，最后遍历flag数组，就可以发现根节点。</p></li></ul><p>以下是<strong>动态链表：</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>BinTree<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token punctuation">&#123;</span>ElementType Data<span class="token punctuation">;</span>BinTree Left<span class="token punctuation">;</span><span class="token comment">//指向左子结点</span>BinTree Right<span class="token punctuation">;</span><span class="token comment">//指向右子结点</span><span class="token punctuation">(</span>BinTree Parent<span class="token punctuation">;</span><span class="token comment">//指向父结点)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-c" data-language="c"><code class="language-c">BinTree <span class="token function">Insert</span><span class="token punctuation">(</span>ElementType Data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  BinTree BT<span class="token punctuation">;</span>  BT <span class="token operator">=</span> <span class="token punctuation">(</span>BinTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  BT<span class="token operator">-></span>Data <span class="token operator">=</span> Data<span class="token punctuation">;</span>  BT<span class="token operator">-></span>Left <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>  BT<span class="token operator">-></span>Right <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>  <span class="token keyword">return</span> BT<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 初始化二叉树</span>BinTree <span class="token function">CreatBinTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  BinTree BT<span class="token punctuation">;</span>  BT <span class="token operator">=</span> <span class="token punctuation">(</span>BinTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  BT<span class="token operator">-></span>Data <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  BT<span class="token operator">-></span>Left <span class="token operator">=</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  BT<span class="token operator">-></span>Right <span class="token operator">=</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  BT<span class="token operator">-></span>Left<span class="token operator">-></span>Left <span class="token operator">=</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  BT<span class="token operator">-></span>Left<span class="token operator">-></span>Right <span class="token operator">=</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  BT<span class="token operator">-></span>Left<span class="token operator">-></span>Right<span class="token operator">-></span>Left <span class="token operator">=</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  BT<span class="token operator">-></span>Right<span class="token operator">-></span>Left <span class="token operator">=</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  BT<span class="token operator">-></span>Right<span class="token operator">-></span>Right <span class="token operator">=</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  BT<span class="token operator">-></span>Right<span class="token operator">-></span>Left<span class="token operator">-></span>Right <span class="token operator">=</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> BT<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092813.png" alt="graph (3)" style="zoom:50%;" / loading="lazy"></p><p>通过以上初始化，我们就创建了一个如图所示的二叉树，现在我们康康怎么遍历他们。</p><h3 id="二叉树的遍历">二叉树的遍历</h3><h4 id="先前序遍历">1）先/前序遍历</h4><p>遍历过程为:</p><p>①访问根结点 ②先序遍历其左子树 ③先序遍历其右子树</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092815.png" style="zoom:50%;" / loading="lazy"></p><p>遍历顺序：A(BDFE)(CGHI)</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PreOrderTraversal</span><span class="token punctuation">(</span>BinTree BT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>BT<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> BT<span class="token operator">-></span>Data<span class="token punctuation">;</span><span class="token comment">//***</span>    <span class="token function">PreOrderTraversal</span><span class="token punctuation">(</span>BT<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PreOrderTraversal</span><span class="token punctuation">(</span>BT<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="中序遍历">2）中序遍历</h4><p>遍历过程为：</p><p>①中序遍历其左子树 ②访问根结点 ③中序遍历其右子树</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092818.png" alt="image-20210328191833131" style="zoom:50%;" / loading="lazy"></p><p>遍历顺序：（DBFE)A(GHCI)</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InOrderTraversal</span><span class="token punctuation">(</span>BinTree BT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>BT<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">InOrderTraversal</span><span class="token punctuation">(</span>BT<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> BT<span class="token operator">-></span>Data<span class="token punctuation">;</span><span class="token comment">//***</span>    <span class="token function">InOrderTraversal</span><span class="token punctuation">(</span>BT<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="后序遍历">3）后序遍历</h4><p>遍历过程为：</p><p>①后序遍历其左子树 ②后序遍历其右子树 ③访问根节点</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092820.png" style="zoom:50%;" / loading="lazy"></p><p>遍历顺序：(DEFB)(HGIC)A</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PostOrderTraversal</span><span class="token punctuation">(</span>BinTree BT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>BT<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">PostOrderTraversal</span><span class="token punctuation">(</span>BT<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PostOrderTraversal</span><span class="token punctuation">(</span>BT<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> BT<span class="token operator">-></span>Data<span class="token punctuation">;</span><span class="token comment">//***</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="非递归利用堆栈实现遍历">4）非递归（利用堆栈）实现遍历</h4><p>前三种遍历方法都是利用<strong>递归</strong>，其本质是<strong>堆栈</strong>。下面开始尝试直接使用堆栈进行对树的遍历。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092821.png" alt="image-20210328191833131" style="zoom:50%;" / loading="lazy"></p><p>以这张中序遍历的图为例，假设我们现在有一个堆栈，我们的目的就是制造一个出栈序列为DBFEAGHCI的堆栈</p><p>OK，开始遍历左子树，中途遇见的结点全部push进栈中，一直到左子树为空，也就是遍历到了D。</p><p>此时pop(D)，然后开始遍历右子树，发现也为空。</p><p>此时回到栈顶元素B，pop掉，然后遍历B的右子树的左子树……</p><p>通过简单的模拟，我们可以得到规律如下：</p><ul><li>遇到一个结点,就把它压栈,并去遍历它的左子树</li><li>当左子树遍历结束后,从栈顶弹出这个结点并访问它</li><li>然后按其右指针再去中序遍历该结点的右子树，如此循环往复</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InOrderTraversal</span><span class="token punctuation">(</span>BinTree BT<span class="token punctuation">)</span><span class="token comment">//非递归中序遍历</span><span class="token punctuation">&#123;</span>  BinTree T <span class="token operator">=</span> BT<span class="token punctuation">;</span>  stack<span class="token operator">&lt;</span>BinTree<span class="token operator">></span> S<span class="token punctuation">;</span><span class="token comment">//初始化栈</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>T <span class="token operator">||</span> <span class="token operator">!</span>S<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token comment">//一路向左遍历左子树</span>    <span class="token punctuation">&#123;</span>      S<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//沿途压栈</span>      T <span class="token operator">=</span> T<span class="token operator">-></span>Left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//压无可压</span>    <span class="token punctuation">&#123;</span>      T <span class="token operator">=</span> S<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问</span>      S<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//出栈</span>      cout <span class="token operator">&lt;&lt;</span> T<span class="token operator">-></span>Data<span class="token punctuation">;</span>      T <span class="token operator">=</span> T<span class="token operator">-></span>Right<span class="token punctuation">;</span><span class="token comment">//开始遍历右子树</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PreOrderTraversal</span><span class="token punctuation">(</span>BinTree BT<span class="token punctuation">)</span><span class="token comment">//非递归先序遍历</span><span class="token punctuation">&#123;</span>  BinTree T <span class="token operator">=</span> BT<span class="token punctuation">;</span>  stack<span class="token operator">&lt;</span>BinTree<span class="token operator">></span> S<span class="token punctuation">;</span><span class="token comment">//初始化栈</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>T <span class="token operator">||</span> <span class="token operator">!</span>S<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token comment">//一路向左遍历左子树</span>    <span class="token punctuation">&#123;</span>      cout <span class="token operator">&lt;&lt;</span> T<span class="token operator">-></span>Data<span class="token punctuation">;</span><span class="token comment">//前序和先序的差别只在这</span>      S<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//沿途压栈</span>      T <span class="token operator">=</span> T<span class="token operator">-></span>Left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//压无可压</span>    <span class="token punctuation">&#123;</span>      T <span class="token operator">=</span> S<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问</span>      S<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//出栈</span>      T <span class="token operator">=</span> T<span class="token operator">-></span>Right<span class="token punctuation">;</span><span class="token comment">//开始遍历右子树</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>关于中序和先序只需调换打印语句的位置这件事，可以这么理解：</li></ul><p>对于先序来说，打印一个结点的时机是第一次访问该节点时；</p><p>对于中序来说，打印一个结点的时机是第二次访问该结点时；</p><p>但是！对于后序来说，打印一个结点是第三次访问该节点时（开始访问，左子树遍历完，右子树遍历完）难点在于：<strong>需要判断上次访问的节点是位于左子树，还是右子树。</strong>若是位于左子树，则需跳过根节点，先进入右子树，再回头访问根节点；若是位于右子树，则直接访问根节点。总结：</p><ul><li>当前结点是叶结点。</li><li>当前结点的右子结点是上一次访问的结点。</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PostOrderTraversal</span><span class="token punctuation">(</span>BinTree BT<span class="token punctuation">)</span><span class="token comment">//非递归后序遍历</span><span class="token punctuation">&#123;</span>  stack<span class="token operator">&lt;</span>BinTree<span class="token operator">></span> S<span class="token punctuation">;</span>  BinTree T<span class="token operator">=</span> BT<span class="token punctuation">;</span>  BinTree pre <span class="token operator">=</span> nullptr<span class="token punctuation">;</span><span class="token comment">//pre指针是为了保存上一次访问的结点状态</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>T <span class="token operator">!=</span> nullptr <span class="token operator">||</span> <span class="token operator">!</span>S<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      S<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>      T <span class="token operator">=</span> T<span class="token operator">-></span>Left<span class="token punctuation">;</span> <span class="token comment">//遍历左子树</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>      <span class="token comment">//每次取栈顶元素</span>      <span class="token comment">//判断栈顶元素的右孩子是否为空，</span>      <span class="token comment">//如果不为空，查看之前访问的节点是不是该栈顶元素的右孩子</span>      T <span class="token operator">=</span> S<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token operator">-></span>Right <span class="token operator">!=</span> nullptr <span class="token operator">&amp;&amp;</span> T<span class="token operator">-></span>Right <span class="token operator">!=</span> pre<span class="token punctuation">)</span><span class="token comment">//如果之前访问的不是当前结点的右结点</span>      <span class="token punctuation">&#123;</span>        T <span class="token operator">=</span> T<span class="token operator">-></span>Right<span class="token punctuation">;</span> <span class="token comment">//遍历右子树</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">else</span>      <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> T<span class="token operator">-></span>Data<span class="token punctuation">;</span> <span class="token comment">//根</span>        S<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//每次访问节点之后，需要将缓存上一次访问的节点为pre，并且将当前指针置空</span>        pre <span class="token operator">=</span> T<span class="token punctuation">;</span>        T <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="层序遍历">5）层序遍历</h4><p>所谓层序遍历就是按照树的层次从上至下，从左至右地遍历树。也就是所谓的树型BFS。</p><p><strong>通过引入一个队列来进行层序遍历：</strong></p><ul><li>先将根结点入队；</li><li>只要队列不为空：<ul><li>出队队首结点，并遍历；</li><li>如果队首结点有左子结点，将左子结点入队；</li><li>如果队首结点有右子结点，将右子结点入队；</li></ul></li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">LevelorderTraversal</span> <span class="token punctuation">(</span> BinTree BT <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   queue<span class="token operator">&lt;</span>BinTree<span class="token operator">></span> Q<span class="token punctuation">;</span><span class="token comment">//初始化队列</span>  BinTree T<span class="token punctuation">;</span><span class="token comment">//T作为临时变量</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>BT<span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">//若为空树直接返回</span>  Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>BT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根节点入队</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    T <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问队首元素</span>    Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 出队</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> T<span class="token operator">-></span>Data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token operator">-></span>Left<span class="token punctuation">)</span>      Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>T<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token operator">-></span>Right<span class="token punctuation">)</span>      Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>T<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>已知二叉树的 先序遍历和中序遍历 或者 后序遍历和中序遍历。可以唯一确定一颗二叉树</li></ul><h3 id="二叉树的操作集及基础应用">二叉树的操作集及基础应用</h3><h4 id="输出叶结点printleaves">1）输出叶结点（PrintLeaves）</h4><p>思路非常简单，在上述遍历的基础上，加上<strong>左右子树皆空的条件即可</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PrintLeaves</span><span class="token punctuation">(</span>BinTree BT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>BT<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">PrintLeaves</span><span class="token punctuation">(</span>BT<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>BT<span class="token operator">-></span>Left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>BT<span class="token operator">-></span>Right<span class="token punctuation">)</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> BT<span class="token operator">-></span>Data<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">PrintLeaves</span><span class="token punctuation">(</span>BT<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="求高度getheight">2）求高度（getHeight）</h4><p>递推公式：<strong>高度=max（左子树高度，右子树高度）+1</strong></p><p>思路也很简单，同样是递归遍历求高度</p><pre class="language-c" data-language="c"><code class="language-c"> <span class="token keyword">int</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>BinTree BT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> HL<span class="token punctuation">,</span> HR<span class="token punctuation">,</span> MaxH<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>BT<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    HL<span class="token operator">=</span><span class="token function">getHeight</span><span class="token punctuation">(</span>BT<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">;</span>    HR <span class="token operator">=</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>BT<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span>    MaxH <span class="token operator">=</span> HL <span class="token operator">></span> HR <span class="token operator">?</span> HL <span class="token operator">:</span> HR<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>MaxH <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//空树返回0</span><span class="token punctuation">&#125;</span></code></pre><h4 id="二元运算表达式树">3）二元运算表达式树</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092826.png" alt="QQ截图20210329185128" style="zoom:50%;" / loading="lazy"></p><p>让我们遍历一下试试:</p><p>后序遍历: abc*+de*f+g*+ //后缀表达式 中序遍历: a+b*c+d*e+f*g //异常的中缀表达式（收到<strong>优先级影响</strong>） 前序遍历: ++a*bc*+*defg //前缀表达式</p><p>那么接下来考虑解决中序的异常情况，这里有一种很讨巧的加括号的方式：</p><ul><li>进入左子树前 打印左括号</li><li>退出右子树后 打印右括号</li></ul><p>不过打印出来的 (((a)+((b)*(c)))+((((d)*(e))+(f))*(g))) 可读性也不怎么样</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InOrderBinaryExpressionTrees</span><span class="token punctuation">(</span>BinTree BT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>BT<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span>    <span class="token function">InOrderBinaryExpressionTrees</span><span class="token punctuation">(</span>BT<span class="token operator">-></span>Left<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> BT<span class="token operator">-></span>Data<span class="token punctuation">;</span> <span class="token comment">//***</span>    <span class="token function">InOrderBinaryExpressionTrees</span><span class="token punctuation">(</span>BT<span class="token operator">-></span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="前序中序-后序">4）前序+中序-&gt;后序</h4><p>假定有某二叉树的前序遍历序列和中序遍历序列那么是否能还原出后序遍历序列呢？</p><p>例：</p><p>前序遍历: GDAFEMHZ</p><p>中序遍历: ADEFGHMZ</p><blockquote><p>第一步，根据前序遍历的特点(根左右)，我们知道根结点为G</p><p>第二步，观察中序遍历(左根右)ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。</p><p>第三步，观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。</p><p>第四步，同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</p><p>第五步，观察发现，上面的过程是<strong>递归</strong>的。</p><p>先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：</p><p>1 确定根,确定左子树，确定右子树。</p><p>2 在左子树中递归。</p><p>3 在右子树中递归。</p><p>4 打印当前根。</p><p><a href="https://blog.csdn.net/u011068702/article/details/51914220">二叉树前序、中序、后序遍历相互求法</a></p></blockquote><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092828.jpeg" alt="img" / loading="lazy"><figcaption aria-hidden="true">img</figcaption></figure><p>这里都是用的字符串指针，在洛谷有看见大佬用stl的string非常惊艳</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">toPostOrder</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>inorder<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>preorder<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">//cout&lt;&lt;"invalid length";</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  BinTree node <span class="token operator">=</span> new TreeNode<span class="token punctuation">;</span>  node<span class="token operator">-></span>Data <span class="token operator">=</span> <span class="token operator">*</span>preorder<span class="token punctuation">;</span> <span class="token comment">//记录先序的首元素，即树的根</span>  <span class="token keyword">int</span> rootIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> rootIndex <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> rootIndex<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>rootIndex<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">*</span>preorder<span class="token punctuation">)</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token comment">//在中序序列中寻找root，并记录其下标rootIndex</span>  <span class="token comment">//特别注意到 左子树的长度 == rootIndex ,右子树的长度 == length - (rootIndex + 1)</span>  <span class="token comment">//Left</span>  <span class="token function">toPostOrder</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> preorder <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rootIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Right</span>  <span class="token function">toPostOrder</span><span class="token punctuation">(</span>inorder <span class="token operator">+</span> rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preorder <span class="token operator">+</span> rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> length <span class="token operator">-</span> <span class="token punctuation">(</span>rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> node<span class="token operator">-></span>Data<span class="token punctuation">;</span>  <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>类似的，不难得出中序和后序求先序的算法。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">toPreOrder</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>inorder<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>postorder<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">//cout&lt;&lt;"invalid length";</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  BinTree node <span class="token operator">=</span> new TreeNode<span class="token punctuation">;</span>  node<span class="token operator">-></span>Data <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>postorder <span class="token operator">+</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取后序排列的末尾，即为根</span>  cout <span class="token operator">&lt;&lt;</span> node<span class="token operator">-></span>Data<span class="token punctuation">;</span>                     <span class="token comment">//由于先序序列第一位是根，直接打印</span>  <span class="token keyword">int</span> rootIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> rootIndex <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> rootIndex<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//a variation of the loop</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>rootIndex<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span>postorder <span class="token operator">+</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token comment">//在中序序列中寻找根,返回其下标</span>  <span class="token comment">//然后得到中序根下标左边为左子树，右边为右子树</span>  <span class="token function">toPreOrder</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span>rootIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//中序左根右，后序左右根，两序列的左子树长度相等</span>  <span class="token function">toPreOrder</span><span class="token punctuation">(</span>inorder <span class="token operator">+</span> rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> postorder <span class="token operator">+</span> rootIndex<span class="token punctuation">,</span> length <span class="token operator">-</span> <span class="token punctuation">(</span>rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//遍历右子树，中序直接遍历到尾</span><span class="token punctuation">&#125;</span></code></pre><h2 id="并查集">并查集</h2><blockquote><p>并查集是一种<strong>树形的</strong>数据结构，顾名思义，它用于处理一些不交集的 <strong>合并</strong> 及 <strong>查询</strong> 问题。 它支持两种操作：</p><ul><li>查找（Find）：确定某个元素处于哪个子集；</li><li>合并（Union）：将两个子集合并成一个集合。</li></ul></blockquote><h3 id="并查集的表示">并查集的表示</h3><p>利用结构体数组进行存储,规定祖先的父结点值为负数。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">1000</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElementType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>ElementType Data<span class="token punctuation">;</span> <span class="token comment">// 存值</span><span class="token keyword">int</span> parent<span class="token punctuation">;</span>  <span class="token comment">// 指向父结点 </span><span class="token punctuation">&#125;</span>SetType<span class="token punctuation">;</span>SetType s<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h3 id="查找">查找</h3><p>方案一（暴力）：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span>ElementType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//x恰好就是根节点</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token keyword">else</span>   <span class="token keyword">return</span> <span class="token function">Find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ul><li>从叶结点开始，一层一层向父结点访问，思路简单，但是效率太低，因为对于一个集合来说我只关心他的根节点（祖宗结点），而不关心他的父结点。<del>那么，有没有一种方法</del><strong>那就是把在路径上的每个节点都直接连接到根上</strong>，这就是<strong>路径压缩</strong>。</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span>ElementType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// x不是根节点</span>    s<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 查找x的祖先直到找到代表,于是顺手路径压缩</span>  <span class="token keyword">return</span> s<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="合并">合并</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span>SetName Root1<span class="token punctuation">,</span> SetName Root2 <span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">/* 这里默认Root1和Root2是不同集合的根结点 */</span>    <span class="token comment">/* 保证小集合并入大集合 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> s<span class="token punctuation">[</span>Root2<span class="token punctuation">]</span> <span class="token operator">&lt;</span> s<span class="token punctuation">[</span>Root1<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 如果集合2比较大 */</span>        s<span class="token punctuation">[</span>Root2<span class="token punctuation">]</span> <span class="token operator">+=</span> s<span class="token punctuation">[</span>Root1<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">/* 集合1并入集合2  */</span>        s<span class="token punctuation">[</span>Root1<span class="token punctuation">]</span> <span class="token operator">=</span> Root2<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                         <span class="token comment">/* 如果集合1比较大 */</span>        s<span class="token punctuation">[</span>Root1<span class="token punctuation">]</span> <span class="token operator">+=</span> s<span class="token punctuation">[</span>Root2<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">/* 集合2并入集合1  */</span>        s<span class="token punctuation">[</span>Root2<span class="token punctuation">]</span> <span class="token operator">=</span> Root1<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="参考">参考</h2><p>https://www.jianshu.com/p/ac95b5a7de8b</p><p>https://cloud.tencent.com/developer/article/1353388</p><p>https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html</p><p>https://www.runoob.com/data-structures/binary-search-level-traverse.html</p><p>https://zhuanlan.zhihu.com/p/34147390</p><p>https://blog.csdn.net/u011068702/article/details/51914220</p><p>https://blog.csdn.net/snowsnowsnow1991/article/details/52541760</p><p>https://oi-wiki.org/ds/dsu/</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;智慧树上智慧果智慧树下平衡树划分树归并树k-d树pq树主席树树套树&quot;&gt;智慧树上智慧果，智慧树下平衡树，划分树，归并树，k-d树，pq树，主席树，树套树。&lt;/h3&gt;</summary>
    
    
    
    <category term="算法学习" scheme="http://lapras.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="http://lapras.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lapras.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="http://lapras.xyz/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的数据结构-线性结构</title>
    <link href="http://lapras.xyz/2021/03/28/c335c6ca.html"/>
    <id>http://lapras.xyz/2021/03/28/c335c6ca.html</id>
    <published>2021-03-28T06:08:35.000Z</published>
    <updated>2021-12-01T05:15:46.762Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="线性表linearlist及其实现">线性表（LinearList）及其实现</h2><p><strong>线性表</strong>：同类型元素构成的一种有序序列。</p><ul><li>表中元素个数称为线性表的长度</li><li>表中无元素时称为空表</li><li>表的起始位置称为表头，末位位置则称为表尾</li></ul><h3 id="线性表的抽象数据类型描述">线性表的抽象数据类型描述</h3><p><strong>类型名称</strong>：线性表List</p><p><strong>数据对象集</strong>：线性表是<strong>n</strong>个元素构成的有序序列</p><p><strong>操作集</strong>:线性表L <span class="math inline">\(\in\)</span> List,整数<strong>i</strong>表示位置,元素x <span class="math inline">\(\in\)</span> ElementType</p><hr /><p><strong>具体代码见ClassDemo</strong></p><h4 id="存储实现顺序存储">存储实现(顺序存储)</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElementType<span class="token punctuation">;</span> <span class="token comment">// ElementType 可定义为任意类型</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>List<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">&#123;</span>  ElementType Data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> Last<span class="token punctuation">;</span> <span class="token comment">// Last 定义线性表的最后一个元素下标</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//下标从0开始</span>List PtrL<span class="token punctuation">;</span>L<span class="token punctuation">.</span>Data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>PtrL<span class="token operator">-></span>Data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 访问下标为i的元素</span>Last<span class="token operator">+</span><span class="token number">1</span> <span class="token comment">//链表长度</span></code></pre><h4 id="存储实现链式存储">存储实现(链式存储)</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElementType<span class="token punctuation">;</span> <span class="token comment">// ElementType 可定义为任意类型</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>List<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">&#123;</span>  ElementType Data<span class="token punctuation">;</span> <span class="token comment">//数据域</span>  List Next<span class="token punctuation">;</span>        <span class="token comment">// 下一个链表的地址</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h2 id="特殊的线性表">特殊的线性表</h2><h3 id="堆栈stack">堆栈（Stack）</h3><p><strong>类型名称</strong>：堆栈(Stack)</p><p><strong>数据对象集</strong>：一个有0个或多个元素的有穷线性表。</p><p><strong>操作集</strong>：长度为MaxSize的堆栈S<span class="math inline">\(\in\)</span>Stack,堆栈元素item <span class="math inline">\(\in\)</span> ElementType</p><h4 id="特点">特点</h4><ul><li><p>只在一端(栈顶, Top)做插入、删除</p></li><li><p>插入数据：入栈(Push)</p></li><li><p>删除数据：出栈(Pop)</p></li><li><p>后进先出：Last In First Out (LIFO)</p></li></ul><h4 id="存储实现顺序存储-1">存储实现（顺序存储）</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElementType<span class="token punctuation">;</span> <span class="token comment">// ElementType 暂时定义为 int 类型</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SNode</span> <span class="token operator">*</span>Stack<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">SNode</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> MaxSize<span class="token punctuation">;</span>  ElementType <span class="token operator">*</span>Data<span class="token punctuation">;</span> <span class="token comment">// 存储堆栈元素</span>  <span class="token keyword">int</span> top<span class="token punctuation">;</span>           <span class="token comment">// 记录栈顶元素下标//从0开始</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><ul><li>值得一提的是数组可以用来同时创建两个栈，从头尾同时向中间逼近</li></ul><h4 id="存储实现链式存储-1">存储实现(链式存储)</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElementType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SNode</span> <span class="token operator">*</span>Stack<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">SNode</span><span class="token punctuation">&#123;</span>  ElementType Data<span class="token punctuation">;</span>  Stack Next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="堆栈的应用">堆栈的应用</h3><h4 id="前缀表达式转为中缀表达式">前缀表达式转为中缀表达式</h4><ul><li>运算数相对顺序不变</li><li>运算符号顺序发生改变</li></ul><blockquote><p>需要存储“等待中”的运算符号</p><p>要将当前运算符号与“等待中”的最后一个运算符号比较</p><p>有括号的情况下需注意优先级的改变</p></blockquote><p>从头到尾读取中缀表达式的每个对象,对不同对象按不同的情况处理：</p><ul><li>运算数:直接输出:</li><li>左括号:压入堆栈:</li><li>右括号:将栈顶的运算符弹出并输出,直到遇到左括号(出栈,不输出)</li><li>运算符：<ul><li>若优先级大于栈顶运算符时,则把它压栈;</li><li>若优先级小于等于栈顶运算符时,将栈顶运算符弹出并输出;再比较新的栈顶运算符,直到该运算符大于栈顶运算符优先级为止,然 后将该运算符压栈;</li></ul></li><li>若各对象处理完毕,则把堆找中存留的运算符一输出</li></ul><h3 id="队列queue">队列（Queue）</h3><p><strong>类型名称</strong>：队列(Queue)</p><p><strong>数据对象集</strong>：一个有0个或多个元素的有穷线性表。</p><p><strong>操作集</strong>：长度为MaxSize的队列Q<span class="math inline">\(\in\)</span>Queue,队列元素item<span class="math inline">\(\in\)</span>ElementType</p><h4 id="特点-1">特点</h4><ul><li>只在一端（队尾/rear）做插入</li><li>只在一端（队头/front）做删除</li><li>插入数据：入队（Add）</li><li>删除数据：出队（Delete）</li><li>先进先出：First In First Out (FIFO)</li></ul><h4 id="存储实现顺序存储-2">存储实现（顺序存储）</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElementType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> Position<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">QNode</span> <span class="token operator">*</span>Queue<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">QNode</span><span class="token punctuation">&#123;</span>  ElementType <span class="token operator">*</span>Data<span class="token punctuation">;</span>  Position front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span> <span class="token comment">//队头，队尾指针</span>  <span class="token keyword">int</span> MaxSize<span class="token punctuation">;</span><span class="token comment">//只使用MaxSize-1的空间</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><ul><li>值得一提的是数组可以用来创建<strong>循环队列</strong>(类似约瑟夫环的处理方法)以节约空间，但是会存在队列空和满无法区分的情况。此时可以使用一个flag记录上次操作为插入还是删除，或者选择只使用其中n-1的数组空间。</li></ul><h4 id="存储实现链式存储-2">存储实现(链式存储)</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElementType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">QNode</span> <span class="token operator">*</span>Queue<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>  ElementType Data<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>Next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">QNode</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>rear<span class="token punctuation">,</span> <span class="token operator">*</span>front<span class="token punctuation">;</span> <span class="token comment">//头尾指针指向头尾元素本身</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;线性表linearlist及其实现&quot;&gt;线性表（LinearList）及其实现&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线性表&lt;/strong&gt;：同类型元素构成的一种有序序列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表中元素个数称</summary>
      
    
    
    
    <category term="算法学习" scheme="http://lapras.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="http://lapras.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lapras.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>UE4学习笔记--地编篇</title>
    <link href="http://lapras.xyz/2021/03/18/330cb86d.html"/>
    <id>http://lapras.xyz/2021/03/18/330cb86d.html</id>
    <published>2021-03-18T11:22:38.000Z</published>
    <updated>2021-09-03T03:43:09.061Z</updated>
    
    <content type="html"><![CDATA[<h3 id="bsp画刷">BSP(画刷)</h3><p>BSP画刷是虚幻的关卡构建中最为基本的工具。从理论上说,最好将BSP想象为可以在关卡中进行填充并切除空间体积的东西。 很久之前, BSP被用来作为关卡设计中的主要构建模块。 但是现在,这个角色由静态网格物体来承担,相较而言,<strong>静态网格物体</strong>远为高效。不过,作为关卡和物体的快速原型化产品的前期应用,以及<strong>对于那些无法使用3D建模工具而需要进行关卡构建的人</strong>来说, BSP依然很有用.</p><span id="more"></span><h3 id="关卡场景开发流程">关卡场景开发流程</h3><p>开发关卡的标准工作流程是这样的:</p><ul><li>设计出关卡章图及关卡路径。</li><li>运行关卡测试流程和游戏性</li><li>修改布局并反复测试</li><li>起始的网格物体环节</li><li>起始的光照环节</li><li>对碰撞及性能问题的游戏测试。</li><li>润色</li></ul><figure><img src="https://i.loli.net/2021/03/18/RAVEbqT3Ue9jKa4.png" alt="image-20210318192700940" / loading="lazy"><figcaption aria-hidden="true">image-20210318192700940</figcaption></figure><h3 id="bsp笔刷基本应用">BSP笔刷基本应用</h3><figure><img src="https://i.loli.net/2021/03/18/KOnHLzvbsIYQlD1.png" alt="image-20210318193525023" / loading="lazy"><figcaption aria-hidden="true">image-20210318193525023</figcaption></figure><ul><li>减去类似于永久且有形状的橡皮擦</li><li>增加和减去的BSP遵循的是后进优先原则，即<strong>先创建的减去型A</strong>无法减去<strong>后创建的添加型B</strong></li></ul><figure><img src="https://i.loli.net/2021/03/18/YTFlzb6PRcHrW9d.png" alt="image-20210318193851632" / loading="lazy"><figcaption aria-hidden="true">image-20210318193851632</figcaption></figure><ul><li><p>值得一提的是在细节栏显示高级详细信息后有一个排序选项可以快速设置物体的优先级</p></li><li><p>对物体缩放请使用细节栏中的缩放功能，这样不会造成材质贴图被拉伸（可以再棋盘格的表现上看出）</p><ul><li>或者缩放后使用几何体-对齐</li></ul></li></ul><p><img src="https://i.loli.net/2021/03/18/hdTLtFs25lN9yGx.png" alt="image-20210318194542047" / loading="lazy">、</p><ul><li>中空：使得视角在物体内时可以看到墙壁 而不是透视</li><li>固体性：可以被减去，且有碰撞检测</li><li>半固体：不可以被减去，且有碰撞检测</li><li>非固体：不可以被减去，且无碰撞检测</li></ul><h4 id="附着材质">附着材质</h4><ul><li>选中材质后创建BSP</li><li>创建BSP后拖动材质附着到面上</li></ul><h4 id="笔刷编辑器">笔刷编辑器</h4><figure><img src="https://i.loli.net/2021/03/18/DwECtI2ngVHZiq8.png" alt="image-20210318200206583" / loading="lazy"><figcaption aria-hidden="true">image-20210318200206583</figcaption></figure><p>可以对BSP的点线面单独操作，妙用无穷</p><h3 id="搭个房子吧asir">搭个房子吧asir</h3>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;bsp画刷&quot;&gt;BSP(画刷)&lt;/h3&gt;
&lt;p&gt;BSP画刷是虚幻的关卡构建中最为基本的工具。从理论上说,最好将BSP想象为可以在关卡中进行填充并切除空间体积的东西。 很久之前, BSP被用来作为关卡设计中的主要构建模块。 但是现在,这个角色由静态网格物体来承担,相较而言,&lt;strong&gt;静态网格物体&lt;/strong&gt;远为高效。不过,作为关卡和物体的快速原型化产品的前期应用,以及&lt;strong&gt;对于那些无法使用3D建模工具而需要进行关卡构建的人&lt;/strong&gt;来说, BSP依然很有用.&lt;/p&gt;</summary>
    
    
    
    
    <category term="UE4" scheme="http://lapras.xyz/tags/UE4/"/>
    
    <category term="游戏" scheme="http://lapras.xyz/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
</feed>
