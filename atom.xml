<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anduin9527的乖离器</title>
  
  <subtitle>正在进修摸鱼学导论</subtitle>
  <link href="http://lapras.xyz/atom.xml" rel="self"/>
  
  <link href="http://lapras.xyz/"/>
  <updated>2022-09-20T11:19:14.179Z</updated>
  <id>http://lapras.xyz/</id>
  
  <author>
    <name>Anduin9527</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Games101-Transform</title>
    <link href="http://lapras.xyz/2022/09/20/918c829e.html"/>
    <id>http://lapras.xyz/2022/09/20/918c829e.html</id>
    <published>2022-09-20T11:00:00.000Z</published>
    <updated>2022-09-20T11:19:14.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是对 <a href="https://www.bilibili.com/video/BV1X7411F744?p=3">Game101</a> L3~L4 的笔记，阅读前请先保证对线性代数几何意义有着较为直观的理解，推荐配合食用 <a href="https://www.bilibili.com/video/BV1ys411472E">3Blue1Brown-线性代数的本质</a></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220920190945.jpeg" alt="img" style="zoom:80%;" / loading="lazy"></p><span id="more"></span><h2 id="向量变换">向量变换</h2><p>空间的变换可以用 <strong>基向量</strong> 的变换来加以描述，这些基向量可以构成单位矩阵。换言之，通过一个矩阵我们就可以描述空间的变化</p><h3 id="线性变换">线性变换</h3><p>利用指向 <span class="math inline">\(x\)</span> 轴正方向的的基向量 <span class="math inline">\(\hat x\)</span> 和指向 <span class="math inline">\(y\)</span> 轴正方向的基向量 <span class="math inline">\(\hat y\)</span>，可以很容易的得出所谓的变换矩阵。而将一个向量左乘一个变换矩阵得到一个新向量的过程，因为其按照矩阵乘法展开式为线性运算形式 <span class="math display">\[v&#39; = M v \\ \\\left[\begin{array}{l}x^{\prime} \\y^{\prime}\end{array}\right]=\left[\begin{array}{ll}a &amp; b \\c &amp; d\end{array}\right]\left[\begin{array}{l}x \\y\end{array}\right]\\ \\x&#39; = ax+by \\y&#39; = cx+dy\]</span> 故称之为 <strong>线性变换</strong></p><p>约定，以下的 <span class="math inline">\(\hat x = \begin{pmatrix} 1 \\ 0 \end{pmatrix}\)</span>，<span class="math inline">\(\hat y = \begin{pmatrix} 0 \\ 1 \end{pmatrix}\)</span></p><h4 id="缩放-scale">缩放 Scale</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220919214655.png" alt="image-20220919214647983" style="zoom: 50%;" / loading="lazy"></p><p>可以使用如下的公式 <span class="math display">\[\left[\begin{array}{l}x^{\prime} \\y^{\prime}\end{array}\right]=\left[\begin{array}{cc}s_x &amp; 0 \\0 &amp; s_y\end{array}\right]\left[\begin{array}{l}x \\y\end{array}\right]\]</span> 也可以直接观察两个基向量的变化情况，<span class="math inline">\(\hat x&#39; = \begin{pmatrix} s_x \\ 0 \end{pmatrix}\)</span>，<span class="math inline">\(\hat y&#39; = \begin{pmatrix} 0 \\ s_y \end{pmatrix}\)</span></p><p>然后将两个新的基向量 <strong>拼合</strong> 即可组成变换矩阵，以上内容后文不再赘述</p><h4 id="对称-reflection">对称 Reflection</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220919220419.png" alt="image-20220919220419759" style="zoom:50%;" / loading="lazy"> <span class="math display">\[\left[\begin{array}{l}x^{\prime} \\y^{\prime}\end{array}\right]=\left[\begin{array}{cc}-1 &amp; 0 \\0 &amp; 1\end{array}\right]\left[\begin{array}{l}x \\y\end{array}\right]\]</span></p><h4 id="剪切-shear">剪切 Shear</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220919221109.png" alt="image-20220919221109356" style="zoom:50%;" / loading="lazy"> <span class="math display">\[\left[\begin{array}{l}x^{\prime} \\y^{\prime}\end{array}\right]=\left[\begin{array}{ll}1 &amp; a \\0 &amp; 1\end{array}\right]\left[\begin{array}{l}x \\y\end{array}\right]\]</span></p><h4 id="旋转-rotation">旋转 Rotation</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220919221229.png" alt="image-20220919221229457" style="zoom:50%;" / loading="lazy"> <span class="math display">\[\left[\begin{array}{l}x^{\prime} \\y^{\prime}\end{array}\right]=\left[\begin{array}{ll}\cos \theta &amp; -\sin \theta \\\sin \theta &amp; \cos \theta\end{array}\right]\left[\begin{array}{l}x \\y\end{array}\right]\]</span></p><h3 id="仿射变换">仿射变换</h3><h4 id="齐次坐标">齐次坐标</h4><blockquote><p>由 August Ferdinand M ö bius 提出的齐次坐标（又称投影坐标，homogeneous coordinates），使图形和几何学的计算在投影空间中成为可能。齐次坐标是用 <span class="math inline">\(N+1\)</span> 个数来表示 <span class="math inline">\(N\)</span> 维坐标的一种方式</p></blockquote><p>要制作齐次坐标，我们只需在现有坐标中增加一个额外的变量 <span class="math inline">\(w\)</span>。具体而言，在齐次坐标中我们把 <strong>点</strong> 和 <strong>向量</strong> 的表示区别开</p><ul><li>将原本的向量<span class="math inline">\((x, y)^T\)</span>表示为<span class="math inline">\((x, y,0)^T\)</span></li><li>点则为<span class="math inline">\((x, y,1)^T\)</span>的形式</li></ul><p>说了这么多，所以为什么要引入 <strong>齐次坐标</strong> 呢？</p><blockquote><p>因为懒是一个一个一个美德。 by 闫令琪</p></blockquote><p>你可以发现，上述线性变化矩阵中并没有熟悉的平移 Translation 的身影</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220919223311.png" alt="image-20220919223311205" style="zoom:50%;" / loading="lazy"></p><p>事实上，他也确实不能写作所谓线性变换的形式（因为原点的位置已经被改变了，而线性变化在几何上直观的特点就是：<strong>原点不变</strong> 以及 <strong>直线在变换后依然为直线</strong>），所以我们不得不写成以下形式 <span class="math display">\[\left[\begin{array}{l}x^{\prime} \\y^{\prime}\end{array}\right]=\left[\begin{array}{ll}a &amp; b \\c &amp; d\end{array}\right]\left[\begin{array}{l}x \\y\end{array}\right]+\left[\begin{array}{l}t_x \\t_y\end{array}\right]\]</span> 这种不统一的形式，显然令人不喜，于是乎引入了 <strong>齐次坐标</strong> 来解决平移的问题。又因为向量具有 <strong>平移不变性</strong>，所以我们将其的 <span class="math inline">\(w\)</span> 设置为 <span class="math inline">\(0\)</span>。事实上，这种设置也确实有更多的实际意义，比如 <span class="math display">\[vector + vector = vector\\point - point = vector\\point + vector = point\\point + point = point\]</span> 注意这里的点之间的加法运算，实际表示的是两点的 <strong>中点</strong>。因为点的完整齐次坐标定义为 <span class="math inline">\((\frac{x}{w},\frac{y}{w},1)^T,\ w\neq 0\)</span></p><h4 id="仿射变换-1">仿射变换</h4><p>通过引入了齐次坐标，我们可以将之前比较丑陋的形式改写为 <strong>旋转缩放平移</strong> 三位一体的仿射变换（Affine transformation）形式 <span class="math display">\[\left(\begin{array}{l}x^{\prime} \\y^{\prime} \\1\end{array}\right)=\left(\begin{array}{llc}a &amp; b &amp; t_x \\c &amp; d &amp; t_y \\0 &amp; 0 &amp; 1\end{array}\right) \cdot\left(\begin{array}{l}x \\y \\1\end{array}\right)\]</span> 我们仍然可以用基向量的方式进行理解，<span class="math inline">\(\hat x&#39;, \hat y&#39;\)</span> 是向量所以其为 <span class="math inline">\((a,c,0)^T,\ (b,d,0)^T\)</span>，最后一个理解为 <strong>变换后的原点坐标</strong> <span class="math inline">\((t_x,t_y,1)^T\)</span>，那么我们就可以用仿射变换轻松地表示之前的旋转缩放平移</p><p><span class="math display">\[\mathbf{S}\left(s_x, s_y\right)=\left(\begin{array}{ccc}s_x &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 \\0 &amp; 0 &amp; 1\end{array}\right)\\ \\\]</span></p><p><span class="math display">\[\mathbf{R}(\alpha)=\left(\begin{array}{ccc}\cos \alpha &amp; -\sin \alpha &amp; 0 \\\sin \alpha &amp; \cos \alpha &amp; 0 \\0 &amp; 0 &amp; 1\end{array}\right)\\ \\\]</span></p><p><span class="math display">\[\mathbf{T}\left(t_x, t_y\right)=\left(\begin{array}{ccc}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1\end{array}\right)\]</span></p><h3 id="d-变换">3D 变换</h3><p>三维的情况基本与二维没有出入，除了旋转有个要注意的点。同样的，定义三维的齐次坐标</p><ul><li>点：<span class="math inline">\((x/w, y/w, z/w,1)^T ,\ w \neq 0\)</span></li><li>向量：<span class="math inline">\((x, y, z,0)^T\)</span></li></ul><p>其仿射变换如下： <span class="math display">\[\left(\begin{array}{c}x^{\prime} \\y^{\prime} \\z^{\prime} \\1\end{array}\right)=\left(\begin{array}{lllc}a &amp; b &amp; c &amp; t_x \\d &amp; e &amp; f &amp; t_y \\g &amp; h &amp; i &amp; t_z \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right) \cdot\left(\begin{array}{l}x \\y \\z \\1\end{array}\right)\]</span></p><h4 id="缩放">缩放</h4><p><span class="math display">\[\mathbf{S}\left(s_x, s_y, s_z\right)=\left(\begin{array}{cccc}s_x &amp; 0 &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 &amp; 0 \\0 &amp; 0 &amp; s_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)\]</span></p><h4 id="平移">平移</h4><p><span class="math display">\[\mathbf{T}\left(t_x, t_y, t_z\right)=\left(\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; 0 &amp; t_y \\0 &amp; 0 &amp; 1 &amp; t_z \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)\]</span></p><h4 id="旋转绕着某个轴">旋转（绕着某个轴）</h4><p><span class="math display">\[\begin{aligned}&amp;\mathbf{R}_x(\alpha)=\left(\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \cos \alpha &amp; -\sin \alpha &amp; 0 \\0 &amp; \sin \alpha &amp; \cos \alpha &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right) \\&amp;\mathbf{R}_y(\alpha)=\left(\begin{array}{cccc}\cos \alpha &amp; 0 &amp; \sin \alpha &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\-\sin \alpha &amp; 0 &amp; \cos \alpha &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right) \\&amp;\mathbf{R}_z(\alpha)=\left(\begin{array}{cccc}\cos \alpha &amp; -\sin \alpha &amp; 0 &amp; 0 \\\sin \alpha &amp; \cos \alpha &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)\end{aligned}\]</span></p><ul><li>不难发现，绕着<span class="math inline">\(Y\)</span>轴旋转的结果有些奇怪，这是因为<span class="math inline">\(X\)</span>轴基向量和<span class="math inline">\(Z\)</span>轴基向量的叉乘为<span class="math inline">\(Y\)</span>轴负向的向量，那么所有的旋转角度都会相当于变为原来的 <strong>负值</strong>，从而才会产生这样的差异</li></ul><h4 id="旋转rodriguesrotation-formula">旋转（Rodrigues'Rotation Formula）</h4><p>绕着转轴 <span class="math inline">\(n\)</span> 旋转 <span class="math inline">\(\alpha\)</span> 角度，<a href="https://www.cnblogs.com/wtyuan/p/12324495.html">推导过程</a>:cry: <span class="math display">\[R(n, \alpha)=\cos (\alpha) E+(1-\cos (\alpha)) n n^T+\sin (\alpha)\left(\begin{array}{ccc}0 &amp; -n_z &amp; n_y \\n_z &amp; 0 &amp; -n_x \\-n_y &amp; n_x &amp; 0\end{array}\right)\]</span></p><h2 id="视图相机变换">视图/相机变换</h2><p>想象我们拍照的过程，首先放置几个人物（模型变换 M），然后给定相机位置（相机变换 V），最后按下快门保存为一张二维的照片（投影变换 P），这就是所谓的 <strong>MVP Transformation</strong></p><h3 id="定义相机属性">定义相机属性</h3><ol type="1"><li>位置（postion）： <span class="math inline">\(\vec{e}\)</span></li><li>视线方向（Look-at / gaze direction）：<span class="math inline">\(\hat g\)</span></li><li>垂直方向（Up direction）：<span class="math inline">\(\hat t\)</span></li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220919232151.png" alt="image-20220919232151055" style="zoom:67%;" / loading="lazy"></p><ul><li><p>事实上将你的头视作摄像机，改变位置很好理解，走两步就行；改变视线方向也很好理解，即让你的视线瞄准一个坐标为<span class="math inline">\((x, y, z)^T\)</span>的物体即可；最后一个垂直方向，是类似法线（呆毛）的概念，你可以通过 <strong>歪头</strong> 这一行为更改</p></li><li><p>约定初始状态，也为了后续表示的方便，相机 <strong>永远</strong> 位于原点，永远视线朝向<span class="math inline">\(-Z\)</span>，永远上方向为<span class="math inline">\(Y\)</span></p></li></ul><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220919234134.png" alt="image-20220919234134279" style="zoom: 67%;" / loading="lazy"></p><p>那么现在的问题就变为，如何将一个由 <span class="math inline">\((\vec{e},\hat g, \hat t)\)</span> 表示的相机，<strong>标准化</strong> 为上述的初始状态呢？不难想到应该由以下几步：</p><ol type="1"><li>将其位置 <span class="math inline">\(\vec{e}\)</span> 移动到原点（平移变换）</li><li>将 $g $ 朝向 <span class="math inline">\(-Z\)</span>（旋转变换）</li><li>将 $t $ 朝向 <span class="math inline">\(Y\)</span>（旋转变换）</li><li>令 $g t $ 朝向 <span class="math inline">\(X\)</span>（旋转变化）</li></ol><p>总体来说，先平移后旋转（先右后左）：<span class="math inline">\(M_v = R_vT_v\)</span></p><p>这样一步步写，无疑是很痛苦的。所以我们考虑其逆矩阵（因为旋转矩阵是正交矩阵，所以其逆矩阵就是它的转置矩阵）</p><p>首先是平移（这步没有必要逆矩阵） <span class="math display">\[T_v =\left[\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; -x_e \\0 &amp; 1 &amp; 0 &amp; -y_e \\0 &amp; 0 &amp; 1 &amp; -z_e \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\]</span> 然后是旋转，这里我们逆向考虑把要求的各个方向的 <strong>基向量</strong> 转到 <span class="math inline">\(\hat g,\ \hat t,\ \hat g \times \hat t\)</span> 即可得到逆旋转矩阵，然后转置即可得到旋转矩阵 <span class="math display">\[\begin{aligned}R_{\text {v }}^{-1} &amp;=\left[\begin{array}{llll}x_{\hat{g} \times \hat{t}} &amp; x_t &amp; x_{-g} &amp; 0 \\y_{\hat{g} \times \hat{t}} &amp; y_t &amp; y_{-g} &amp; 0 \\z_{\hat{g} \times \hat{t}} &amp; z_t &amp; z_{-g} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right] \\R_{\text {v }} &amp;=\left[\begin{array}{cccc}x_{\hat{g} \times \hat{t}} &amp; y_{\hat{g} \times \hat{t}} &amp; z_{\hat{g} \times \hat{t}} &amp; 0 \\x_t &amp; y_t &amp; z_t &amp; 0 \\x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\end{aligned}\]</span></p><h2 id="投影变换">投影变换</h2><h3 id="正交投影">正交投影</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220920124755.jpeg" alt="img" style="zoom: 80%;" / loading="lazy"></p><p>上图显示一个简单的正交投影的三个不同视图，正交投影可以简单理解成</p><ol type="1"><li>摄像机看向 <span class="math inline">\(-Z\)</span> 方向，上方向为 <span class="math inline">\(Y\)</span></li><li>将 <span class="math inline">\(Z\)</span> 设置为 0</li><li>平移并缩放物体至区域 <span class="math inline">\([-1,1]^2\)</span></li></ol><p>但在实际操作中，我们一般用一个立方体以描述正交投影的变换矩阵（Orthographic Projection），以六元组 <span class="math inline">\((l,r,b,t,n,f)\)</span> 表示其左，右，底，顶，近，远平面</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220920174659.jpeg" alt="img" style="zoom:80%;" / loading="lazy"></p><ul><li>注意<span class="math inline">\(Z\)</span>值，这里<span class="math inline">\(z_{far} &lt; z_{near}\)</span></li></ul><p>那我们的目的就是将其缩放到变为一个标准立方体，不难想到也是先平移再缩放 <span class="math display">\[\begin{aligned}\mathbf{P}_o =\mathbf{S}(\mathbf{s}) \mathbf{T}(\mathbf{t}) &amp;=\left(\begin{array}{cccc}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \frac{2}{f-n} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)\left(\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; -\frac{l+r}{2} \\0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\0 &amp; 0 &amp; 1 &amp; -\frac{f+n}{2} \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right) \\&amp;=\left(\begin{array}{cccc}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l} \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b} \\0 &amp; 0 &amp; \frac{2}{f-n} &amp; -\frac{f+n}{f-n} \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right) .\end{aligned}\]</span></p><h3 id="透视投影">透视投影</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220920180456.png" alt="image-20220920180456183" style="zoom: 67%;" / loading="lazy"></p><p>想象把左边的平截头体（Frustum）<strong>挤压</strong> 成右边的立方体，然后再做一次 <strong>正交投影</strong> 即可。显然在 <strong>挤压</strong> 的过程中满足以下条件</p><ol type="1"><li>近平面所有点不变</li><li>远平面所有点坐标 z 值不变</li><li>远平面的中心点坐标值不变</li></ol><p>那么问题就变为了如何 <strong>挤压</strong>，这里用矩阵 <span class="math inline">\(M_{persp \to orho}\)</span> 表示</p><p>首先来看一个纵切面</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220920181358.png" alt="image-20220920181358915" style="zoom: 80%;" / loading="lazy"></p><p>通过小学二年级的相似知识，不难得出 <span class="math inline">\(\dfrac{x&#39;}{x} =\dfrac{y&#39;}{y} = \dfrac{n}{z}\)</span></p><p>即 <span class="math inline">\(y&#39; = \frac{n}{z} y,\ x&#39; = \frac{n}{z}x\)</span>，写成矩阵变换的形式</p><p><span class="math display">\[M_{p \rightarrow o}^{(4 \times 4)}\left(\begin{array}{c}x \\y \\z \\1\end{array}\right)==\left(\begin{array}{c}n x / z \\n y / z \\\text { unknown } \\1\end{array}\right)==\left(\begin{array}{c}n x \\n y \\\text { still unknown } \\z\end{array}\right)\]</span></p><p>如果将矩阵乘法展开第一行，第二行以及最后一行：</p><p><span class="math display">\[Ax+By+Cz+D = nx \\Ex+Fy+Gz+H = ny \\Mx+Ny+Oz+P = z\]</span></p><p>不难发现应得到：<span class="math inline">\(A=F=n,\ O = 1\)</span> 其余项为 0，那么至此 <span class="math inline">\(M_{p\to o}\)</span> 已经可以写出一大半了，只有第三行未知</p><p>这时想到之前的 3 个约束条件：</p><ol type="1"><li><p>近平面所有点不变</p><p><span class="math inline">\((x,y,n,1)^T\)</span> 经过 <span class="math inline">\(M_{p\to o}\)</span> 变换后应该还是为本身才行 <span class="math display">\[\left(\begin{array}{cccc}n &amp; 0 &amp; 0 &amp; 0 \\0 &amp;n &amp; 0 &amp; 0 \\I &amp; J &amp; K &amp; L \\0 &amp; 0 &amp; 1 &amp; 0\end{array}\right) .\left(\begin{array}{c}x  \\y \\n  \\1 \end{array}\right)= \left(\begin{array}{c}x  \\y \\n  \\1 \end{array}\right)\]</span> 很明显，这里只有当 $n =1 $ 时才成立，这显然有问题。所以我们这里选择把结果 <span class="math inline">\((x,y,n,1)^T*n\)</span>，这样 <span class="math display">\[\left(\begin{array}{cccc}n &amp; 0 &amp; 0 &amp; 0 \\0 &amp;n &amp; 0 &amp; 0 \\I &amp; J &amp; K &amp; L \\0 &amp; 0 &amp; 1 &amp; 0\end{array}\right) .\left(\begin{array}{c}x  \\y \\n  \\1 \end{array}\right)= \left(\begin{array}{c}nx  \\ny \\n^2  \\n \end{array}\right)\]</span> 那么就可以开始求取第三行了 <span class="math display">\[Ix+Jy+Kn+L = n^2\]</span> 很明显，<span class="math inline">\(I = J=0,\ Kn+ L = n^2\)</span></p></li><li><p>远平面中心点坐标值不变</p><p><span class="math inline">\((0,0,f,1)\)</span> 经过 <span class="math inline">\(M_{p\to o}\)</span> 变换后应该还是为本身才行，同样的，为了满足第四行选择 <span class="math inline">\((0,0,f,1)^T*f\)</span> <span class="math display">\[\left(\begin{array}{cccc}n &amp; 0 &amp; 0 &amp; 0 \\0 &amp;n &amp; 0 &amp; 0 \\0 &amp; 0 &amp; K &amp; L \\0 &amp; 0 &amp; 1 &amp; 0\end{array}\right) .\left(\begin{array}{c}0  \\0 \\f  \\1 \end{array}\right)= \left(\begin{array}{c}0  \\0 \\f  \\1 \end{array}\right)= =\left(\begin{array}{c}0  \\0 \\f^2  \\f \end{array}\right)\]</span> 那么就可以得到 <span class="math inline">\(Kf+L = f^2\)</span></p></li></ol><p>联立上面两个式子 <span class="math display">\[\begin{cases}   Kn+ L &amp;= n^2\\   Kf+ L &amp;= f^2\end{cases}\]</span> 解得 <span class="math inline">\(K = n+f,\ D = -nf\)</span></p><p>所以就可以得到投影向正交变换的矩阵 <span class="math display">\[\left(\begin{array}{cccc}n &amp; 0 &amp; 0 &amp; 0 \\0 &amp;n &amp; 0 &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1 &amp; 0\end{array}\right) \]</span> 那么，最终的投影矩阵即为 <span class="math display">\[M_{persp} = M_{ortho}M_{p\to o}\]</span></p><h2 id="参考">参考</h2><p>https://blog.csdn.net/weixin_43803133/article/details/107449570</p><p><a href="https://zhuanlan.zhihu.com/p/122411512?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888">推导投影矩阵 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/258437902">什么是齐次坐标? - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/392216888">实时渲染第四版 4.6 投影变换 - 知乎</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文是对 &lt;a href=&quot;https://www.bilibili.com/video/BV1X7411F744?p=3&quot;&gt;Game101&lt;/a&gt; L3~L4 的笔记，阅读前请先保证对线性代数几何意义有着较为直观的理解，推荐配合食用 &lt;a href=&quot;https://www.bilibili.com/video/BV1ys411472E&quot;&gt;3Blue1Brown-线性代数的本质&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220920190945.jpeg&quot; alt=&quot;img&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Games101笔记" scheme="http://lapras.xyz/categories/Games101%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机图形学" scheme="http://lapras.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的文件权限</title>
    <link href="http://lapras.xyz/2022/09/17/c66f2510.html"/>
    <id>http://lapras.xyz/2022/09/17/c66f2510.html</id>
    <published>2022-09-17T04:07:57.000Z</published>
    <updated>2022-09-17T04:13:45.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Turn My Body into Fire！</p><p>Proposing a toast to David！</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220916222848.jpeg" alt="img" style="zoom: 45%;" / loading="lazy"></p><span id="more"></span><h2 id="文件权限">文件权限</h2><p>在阅读之前，记住一件事，Linux 中的权限一般是指文件和用户（用户组）的对应关系，这会很大程度上帮助你理解</p><h3 id="用户与用户组">用户与用户组</h3><p>Linux 的服务器属性注定了会有多用户使用一台机器的需求，所以为了用户之间尽可能不要互相干扰，系统管理员必须做好用户管理，这又是另一个专业的问题了，这里不过多赘述。对于权限部分的知识，只需要知道：</p><p>每个用户都有唯一标识符 <code>UID</code>，其与用户名是一一对应关系。系统会在登录的时候通过查询 <code>/etc/passwd</code> 文件来确定用户的 <code>UID</code> 和主目录。该文件的每一行都描述了一个用户，包含由冒号分隔的 7 个部分</p><pre class="language-none"><code class="language-none">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</code></pre><p>从左到右依次是：登录名：加密密码的预留位置：<code>UID</code>：<code>GID</code>：[GECOS 信息]（可选项）：主目录：登录 <code>shell</code></p><p>Linux 将用户分为三种：超级用户、虚拟用户以及普通用户。超级用户自然就是 root，其 <code>UID</code> 为固定的 0；虚拟用户是为了满足系统进程对文件资源的访问控制而建立的，所以不能用来登录，比如各种 web 服务，daemon，ftp 等等，其 <code>UID</code> 为 1~499</p><p>Linux 中，每个用户都可以拥有多个 <strong>用户组</strong>，但必须有一个作为主用户组，剩余的作为附加用户组，属于某用户组的用户对于某些文件拥有相同的权限。与 <code>/etc/passwd</code> 类似，用户组的信息存放在 <code>/etc/group</code> 中，其包含了每个组的名称以及每个组的成员列表。每一行包含四个字段：组名，加密后的密码，<code>GID</code>，组成员列表</p><blockquote><p>以下是一些更改用户及用户组的命令，但对于本节内容并不重要，所以不多赘述</p><p><code>groupadd</code> 添加用户组，<code>groupdel</code> 删除用户组，<code>groupmod</code> 修改用户组</p><p><code>passwd</code> 修改用户登录密码，<code>adduser</code> 添加用户，<code>userdel</code> 删除用户，<code>usermod</code> 修改用户</p></blockquote><p>在用户和用户组之外，还有一个 <strong>其他用户</strong> 的概念。这个很好理解，比如一个用户张三，其主用户组是张三之家，那么在张三创建的文件看来，隔壁老王既不是张三，也不是张三之家的成员，那么隔壁老王就是 <strong>其他用户</strong></p><h3 id="文件属性">文件属性</h3><p>首先，还是从 <code>ls -l</code> 说起吧，他会以长列表（详情）的方式展示当前目录，这里截取其中一条用以说明</p><pre class="language-none"><code class="language-none">drwxr-xr-x  3 root       root           4096 Sep 10 17:43 postgres&#x2F;</code></pre><ul><li><p>第一栏的第一个字符 <strong>d</strong>，表示这个文件是一个 <strong>目录</strong></p><blockquote><p><strong>-</strong> 表示普通文件</p><p><strong>d</strong> 表示目录，通过 <code>mkdir</code> 创建，通过 <code>rmdir</code> 删除</p><p><strong>l</strong> 表示链接文件，通过 <code>ln -s</code> 创建</p><p><strong>b</strong> 表示块设备文件，例如可供储存的设备，通过 <code>mknod</code> 创建</p><p><strong>c</strong> 表示字符设备文件，例如键盘、鼠标，通过 <code>mknod</code> 创建</p><p><strong>s</strong> 表示本地域套接字，通过 <code>socket</code> 系统调用</p><p><strong>p</strong> 表示具名管道，通过 <code>mknod</code> 创建</p></blockquote></li><li><p>接下来的字符中，以三个为一组，且均为 <code>rwx</code> 的三个参数的组合。其中，<code>r</code> 代表可读（read）、<code>w</code> 代表可写（write）、<code>x</code> 代表可执行（execute）。 没有对应权限，就会出现减号 <code>-</code>。三组 <code>rwx</code> 依次代表了所属用户 user，所属用户组 group 和其他用户 other 的访问权限</p></li><li><p>为了简单起见，我们用三位 8 进制数表示这三组权限，其中 4 表示 <code>r</code>，2 表示 <code>w</code>，1 表示 <code>x</code>，然后每组的权限相加即可，比如 <code>rwxrwxrwx</code> 就可以表示为 777，反之 <code>---------</code> 表示为 000</p></li><li><p>第二栏的数字表示有多少文件名链接到该节点，这部分涉及了 Linux 的 <code>i-node</code> 设计，这里简单地理解为有多少文件可以直接访问到该文件即可</p></li><li><p>第三栏和第四栏分别表示该文件的所属用户和所属用户组，初始情况下为创建该文件的用户</p></li><li><p>第五栏表示文件大小，单位为 <code>Bytes</code></p></li><li><p>第六栏表示该文件的创建或是最近修改日期</p></li><li><p>第七栏自然就是文件的名称</p></li></ul><h3 id="文件权限的意义">文件权限的意义？</h3><h4 id="文件">文件</h4><p>文件是实际含有数据的地方，包括一般文本文件、数据库内容档、二进制可执行文件等等</p><ul><li>r （read）：可读取此一文件的实际内容，如读取文本文件的文字内容等</li><li>w（write）：可以编辑、新增或者是修改该文件的内容，<strong>但不含删除该文件</strong></li><li>x （execute）：该文件具有可以被系统执行的权限</li></ul><h4 id="目录">目录</h4><p>目录主要的内容在记录文件名清单</p><ul><li><p>r （read contents in directory）：</p><p>表示具有 <strong>读取目录结构清单的权限</strong>，所以你具有读取一个目录的权限时，表示你可以使用 <code>ls</code> 命令查询该目录下的文件名数据。</p></li><li><p>w （modify contents of directory）：</p><p>表示你具有改动该目录结构清单的权限，具体来说：</p><ul><li>创建新的文件与目录</li><li>删除已经存在的文件与目录（<strong>无视该文件的本身权限要求</strong>，但是可以用下文提到的 Sticky 解决）</li><li>将已存在的文件或目录进行更名</li><li>移动该目录内的文件、目录位置</li></ul></li><li><p>x （access directory）：</p><p>目录不可以被执行，目录的 <code>x</code> 代表的是使用者能否使用 <code>cd</code> 命令进入该目录并使之成为工作目录。 所谓的工作目录（work directory）就是指当前所在目录（用 <code>pwd</code> 命令查询）</p></li></ul><p>也许你还感觉比较抽象，接着我们用一个比喻来说明这些目录权限的意义：</p><ol type="1"><li>目录看作带有一个 <strong>半透明</strong> 的抽屉，文件看作在抽屉中的一个个密封的文件袋</li><li>目录的 <code>x</code> 权限决定你能否拉开 <code>cd</code> 这个抽屉；<code>w</code> 权限决定你能否放置，丢弃其中的文件袋；<code>r</code> 权限决定这个抽屉里的 <strong>昏暗的小灯</strong> 是否打开，即你是否能看见（<code>ls</code>）里面文件的 <strong>名称</strong></li><li>为什么叫昏暗的小灯呢？因为如果你使用 <code>ls -l</code>，你会发现除了最后的文件名和第一个文件类型，剩余的信息全部都是 <code>?</code>。可以想象这样一个场景，你在半透明抽屉外面透过内部昏暗的灯光（只拥有 <code>r</code> 权限）勉强能分辨出 <strong>文件类型和文件名称</strong>，但剩余的信息需要你 <strong>拉开抽屉</strong>（拥有 <code>x</code> 权限）才能得到</li><li>但灯光 <code>r</code> 也只是辅助你看到文件名称，文件的存在与否与灯光没有关系。所以当你拥有 <strong>拉开抽屉</strong> 的权限时，只要你 <strong>记得</strong> 在黑暗中（这时 TAB 就无效了）有哪些文件，你仍然可以使用一些命令查看或修改他们（只要你拥有对文件本身的具体权限）</li><li>接着是目录的 <code>w</code> 权限，这很好理解，如果我无法拉开抽屉（没有 <code>x</code> 权限），那我即使拥有 <code>w</code> 权限也不能在其中新建或者删除文件。但一旦张三同时拥有了某个目录的 <code>wx</code> 权限，那就可以获得里面所有文件的生杀大权。比如张三无法查看修改李四放在这个目录的的文件，但他可以直接把这个文件丢掉（<code>rm</code>）</li></ol><table><thead><tr class="header"><th>权限</th><th>文件</th><th>目录</th></tr></thead><tbody><tr class="odd"><td>r(读)</td><td>查看文件内容</td><td>浏览目录内容</td></tr><tr class="even"><td>w(写)</td><td>修改文件内容</td><td>在目录中创建文件或目录</td></tr><tr class="odd"><td>x(执行)</td><td>将文件投入运行</td><td>进入目录</td></tr></tbody></table><h3 id="扩展权限">扩展权限</h3><p>Linux 系统中的基本权限位为 9 位权限，加上 3 位特殊权限位，共 12 位权限。</p><ol type="1"><li><p>SUID（setUID）</p><p>只有 <strong>可以执行的二进制程序</strong> 才能设置 <code>SUID</code> 位，<strong>且用户必须拥有该文件的可执行权限</strong>，当用户在 <strong>执行</strong> 该文件时，用户临时拥有该文件 <strong>所属用户</strong> 的权限，直到程序执行结束。表现为所属用户的 <code>x</code> 变为 <code>S</code>（原本无执行权限）或者 <code>s</code>（原本有执行权限）</p><p>常见的栗子就是 <code>/etc/shadow</code> 文件的权限是 <code>000 root root</code>，而更改密码的命令 <code>/bin/passwd</code> 本质上就是修改这个文件，所以按照道理来说，普通用户无法修改 <code>shadow</code> 文件，也就无法更改密码。但是因为 <code>passwd</code> 的权限设置为 <code>rwsr-xr-x root root</code>，其所属用户部分的 <code>s</code> 表示 <code>passwd</code> 命令拥有 setUID 权限，因此一个普通用户在执行该命令时，会 <strong>临时</strong> 获得 <strong>文件所属用户</strong> 也就是 <strong>root</strong> 的权限！而 root 则是可以为所欲为的！同样的，我们最常使用的 <code>sudo</code> 命令也是利用了这一机制</p></li><li><p>SGID（setGID）</p><p>同样的，只有 <strong>可以执行的二进制程序</strong> 才能设置 <code>SGID</code> 位，<strong>且用户必须拥有该文件的可执行权限</strong>，当用户在 <strong>执行</strong> 该文件时，用户临时拥有该文件 <strong>所属用户组</strong> 的权限，直到程序执行结束。表现为所属用户组的 <code>x</code> 变为 <code>S</code>（原本无执行权限）或者 <code>s</code>（原本有执行权限）</p><p>常见的栗子，对于设定了 SetGID 权限的目录来说，普通用户在此目录中的有效组会变成此目录的所属组，若普通用户对此目录拥有 w 权限时，在目录中新建的文件的默认所属组是这个目录的所属组。</p></li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220917010335.png" alt="未命名绘图.drawio" style="zoom:80%;" / loading="lazy"></p><blockquote><p>所以这两个特殊权限并不是直接 <strong>分享权限</strong>，而是 <strong>分享角色</strong></p></blockquote><ol start="3" type="1"><li>Sticky</li></ol><p>Sticky BIT 表示的是粘着位，主要是用来避免其他用户对文件的误操作。表现为 <strong>其他用户</strong> 的 <code>x</code> 变为 <code>T</code>（原本无执行权限）或者 <code>t</code>（原本有执行权限） 粘着位目前只对目录有效，普通用户要对该目录拥有 <code>w</code> 和 <code>x</code> 权限，即普通用户可以在此目录拥有写入权限。如果没有粘着位，因为普通用户拥有 <code>w</code> 权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一但赋予了粘着位，除了 root，目录所属用户，文件所属用户可以删除对应文件，普通用户就算拥有 <code>w</code> 权限也只能删除自己建立的文件，但是不能删除其他用户建立的文件，给予公共文件夹 <code>/tmp</code> 一些安全性</p><p>与 <code>rwx</code> 类似的，我们令 <code>SUID</code> 为 4，<code>GUID</code> 为 2，<code>Sticky</code> 为 1，用一个 8 进制数表示三个扩展权限，并把这个八进制数放置在之前的三组权限前形成 4 个八进制数的表示方法</p><h3 id="改变文件权限">改变文件权限</h3><p>改变文件的权限，需要用到 <code>chmod</code> 命令，其有两种语法形式</p><ol type="1"><li><p>chmod [ugoa] [+-=] [rwxst] 文件列表（空格分隔）</p><blockquote><p><code>u</code> 符号代表当前用户</p><p><code>g</code> 符号代表和当前用户在同一个组的用户，以下简称组用户</p><p><code>o</code> 符号代表其他用户</p><p><code>a</code> 符号代表所有用户</p><p><code>r</code> 符号代表读权限以及八进制数 <code>4</code></p><p><code>w</code> 符号代表写权限以及八进制数 <code>2</code></p><p><code>x</code> 符号代表执行权限以及八进制数 <code>1</code></p><p><code>X</code> 符号代表如果目标文件是可执行文件或目录，可给其设置可执行权限</p><p><code>s</code> 符号代表设置权限 suid 和 sgid，使用权限组合 <code>u+s</code> 设定文件的用户的 ID 位，<code>g+s</code> 设置组用户 ID 位</p><p><code>t</code> 符号代表设置 Sticky，只有目录或文件的所有者才可以删除目录下的文件</p><p><code>+</code> 符号代表添加目标用户相应的权限</p><p><code>-</code> 符号代表删除目标用户相应的权限</p><p><code>=</code> 符号代表添加目标用户相应的权限，<strong>删除未提到的权限</strong></p></blockquote></li><li><p>chmod 八进制权限值 文件列表（空格分隔）</p><blockquote><p>777 代表 <code>rwxrwxrwx</code></p><p>666 代表 <code>rw-rw-rw-</code></p><p>1111 代表 <code>--x--x--t</code></p></blockquote></li></ol><h3 id="权限掩码">权限掩码</h3><p><code>umask</code> 是进程的一个属性，目的是为进程创建的文件或目录定义默认权限，它是进程运行环境的一部分</p><p>Shell 创建的所有子孙都将继承这一属性，用户可通过 <code>umask</code> 命令修改 <code>umask</code> 的值，语法为 <code>umask</code> 八进制权限值</p><h2 id="参考">参考</h2><p>鸟哥的 Linux 私房菜（第四版）</p><p>Unix/Linux 系统管理技术手册（第五版）</p><p>https://blog.csdn.net/wxbmelisky/article/details/51649343</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Turn My Body into Fire！&lt;/p&gt;
&lt;p&gt;Proposing a toast to David！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220916222848.jpeg&quot; alt=&quot;img&quot; style=&quot;zoom: 45%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://lapras.xyz/tags/Linux/"/>
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言程序设计（一）</title>
    <link href="http://lapras.xyz/2022/09/06/fdbc8e77.html"/>
    <id>http://lapras.xyz/2022/09/06/fdbc8e77.html</id>
    <published>2022-09-06T02:54:52.131Z</published>
    <updated>2022-09-06T03:04:44.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>中秋节，真不戳</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906105428.jpg" alt="100953677_p0_master1200" style="zoom:67%;" / loading="lazy"></p><span id="more"></span><p>一些常用名词：</p><ul><li>字长（数据宽度）：微处理器一次可以直接处理的二进制数码的 <strong>位数</strong>，它通常取决于微处理器内部 <strong>通用寄存器</strong> 的位数和 <strong>数据总线</strong> 的宽度</li><li>寻址能力：指 CPU 能直接存取数据的 <strong>内存地址</strong> 的范围，它由 CPU 的 <strong>地址总线</strong> 的数目决定</li><li>主频（时钟频率）：用来表示微处理器的运行速度，主频越高 ，表明微处理器运行越快，主频的单位是 MHz、GHz</li><li>MIPS（Millions of Instruction Per Second）：每秒钟能执行多少百万条指令</li><li>微处理器的集成度：微处理器芯片上集成的晶体管数目</li></ul><h2 id="位微处理器内部结构">16 位微处理器内部结构</h2><blockquote><p>Intel 8086 CPU 与随后推出的 8088 CPU 比较类似。8086CPU 是 16 位微处理器，它有 16 根数据线和 20 根地址线，所以可寻址的地址空间是 <span class="math inline">\(2^{20}B = 1MB\)</span>。8088CPU 的内部寄存器、内部运算部件以及内部操作都是按 16 位设计的，但对外的数据总线只有 8 位，在处理一个 16 位数据时，8088 需要两步操作，因而称 8088 是准 16 位微处理器。后来推出的 80286，它的内部结构除了具备 8086/8088 最基本的功能外，还增加了虚拟存储、特权保护、任务管理等功能，所以支持多用户和多任务系统。</p></blockquote><h3 id="内部结构">内部结构</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/8086/8088%E7%BB%93%E6%9E%84.png" alt="image-20220906091341708" style="zoom:80%;" / loading="lazy"></p><ul><li><strong>总线接口单元</strong> 由段寄存器（<code>CS</code>、<code>DS</code>、<code>SS</code>、<code>ES</code>）、指令指针寄存器（<code>IP</code>)、内部暂存器、指令队列、地址加法器及总线控制电路组成。它的主要作用是负责执行所有的外部总线操作</li><li><strong>执行单元</strong> 由通用寄存器、运算数暂存器、算术逻辑单元（<code>ALU</code>）、标志寄存器（<code>FLAGS</code>）及 <code>EU</code> 控制电路组成。它的主要作用是分析和执行指令</li><li>指令队列主要使 <code>EU</code> 和 <code>BIU</code> 并行工作，取指令操作、分析指令操作重叠进行，从而形成了 <strong>两级指令流水线结构</strong>，减少了 CPU 为取指令而必须等待的时间，提高了 CPU 的利用率，加快了整机运行速度，也降低了对存储器存取速度的要求</li></ul><h3 id="寄存器结构">寄存器结构</h3><h4 id="通用寄存器">通用寄存器</h4><p>8086/8088 微处理器的执行单元中有 8 个 <strong>16 位</strong> 的通用寄存器，这些寄存器都可以存放数据或地址，并能进行 <strong>16 位和 8 位</strong> 的数据运算</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906092902.png" alt="通用寄存器" style="zoom:67%;" / loading="lazy"></p><ul><li>数据寄存器<ul><li><code>AX</code> 称为累加器（Accumulator）使用频度最高，用于算术、逻辑运算以及与外设传送信息</li><li><code>BX</code> 称为基址寄存器（Basc Address Rcgister）常用作存放存储器地址</li><li><code>CX</code> 称为计数器（Counter）作为循环和串操作等指令中的隐含计数器</li><li><code>DX</code> 称为数据寄存器（Data Register）常用来存放双字长数据的高 16 位，或存放外设端口地址</li><li>这四个数据寄存器可作为两个独立的 <strong>8 位寄存器</strong> 使用，低位字节的寄存器分别称为 <code>AL,BL,CL,DL</code>，高位字节的寄存器分别称为 <code>AH,BH,CH,DH</code></li></ul></li><li>变址寄存器<ul><li><code>SI</code> 称为源变址寄存器（Source Index）</li><li><code>DI</code> 是目的变址寄存器（Destination Index）</li><li>常用于存储器变址寻址方式提供地址。在串操作类指令中，用于存放串首或串尾数据单元的偏移地址</li></ul></li><li>指针寄存器<ul><li><code>SP</code> 为堆栈指针寄存器（Stack Pointer），指示堆栈段栈顶的位置（偏移地址）</li><li><code>BP</code> 为基址指针寄存器（Base Pointer）</li><li><code>SP</code> 和 <code>BP</code> 寄存器与 <code>SS</code> 段寄存器联合使用以确定堆栈段中的存储单元地址</li></ul></li></ul><h4 id="段寄存器">段寄存器</h4><p>CPU 内部有 4 个段寄存器。8086/8088 CPU 对寻址的 <span class="math inline">\(1MB\)</span> 内存区域是分段管理的，定义的代码段用于存放指令代码，数据段和附加数据段用于存放数据，堆栈段是按照先进后出的访问原则组织起来的一段内存区域。这 4 个段寄存器为存储器分段管理技术提供了硬件支持</p><ul><li><code>CS</code> 称为代码段寄存器，用于存放 <strong>代码段</strong> 的 <strong>段基址</strong></li><li><code>DS</code> 称为数据段寄存器；<code>ES</code> 称为附加段寄存器，两者都用于存放 <strong>数据段</strong> 和 <strong>附加数据段</strong> 的 <strong>段基址</strong></li><li><code>SS</code> 称为堆栈段寄存器，用于存放 <strong>堆栈段</strong> 的 <strong>段基址</strong></li></ul><h4 id="指令指针寄存器">指令指针寄存器</h4><p><code>IP</code>（Instruction Pointer）为指令指针寄存器，指示内存中指令的位置。随着指令的执行，IP 将自动修改以指示下一条指令所在位置。<code>IP</code> 是一个 <strong>专用寄存器</strong>，与 <code>CS</code> 联合使用以确定下一条指令的存储单元地址</p><h4 id="标志寄存器">标志寄存器</h4><p>执行单元 <code>EU</code> 中有一个标志寄存器 <code>FLAGS</code>，16 位的 <code>FLAGS</code> 可分为标志位和控制位，<strong>标志位</strong> 指明程序运行时微处理器的实时状态；<strong>控制位</strong> 由程序设计者设置，以控制 CPU 进行某种操作</p><h2 id="位微处理器内部结构-1">32 位微处理器内部结构</h2><blockquote><p>Pentium 微处理器的内部寄存器长度都为 <span class="math inline">\(32\)</span> 位，但外部数据总线不像 80386 和 <strong>80486</strong> 那样是 <span class="math inline">\(32\)</span> 位，而是 <span class="math inline">\(64\)</span> 位，总线传输速度高达 <span class="math inline">\(66MHz\)</span>。同时它具有 <span class="math inline">\(32\)</span> 位地址总线，可直接寻址 <span class="math inline">\(4GB\)</span> 的物理内存空间。它有两条相对独立的指令并行流水线，即 U 流水线和 V 流水线</p></blockquote><h3 id="内部结构-1">内部结构</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906094633.png" alt="image-20220906094633289" style="zoom:80%;" / loading="lazy"></p><ul><li><strong>总线接口单元</strong> 实现 CPU 与系统总线的连接，其中包括 64 位数据线、32 位地址线和众多控制信号线，以此实现相互之间的信息交换，并产生相应的总线周期信号</li><li><strong>分段分页单元</strong> 完成将各种地址映射到内存物理地址的功能</li><li><strong>高速缓存</strong> 即 Cache，是容量较小、速度很高的可读写 RAM，用来存放 CPU 最近要使用的数据和指令，Cache 可以加快 CPU 存取数据的速度，减轻总线负担。在 Pentium 微处理器内部，指令 Cache 和数据 Cache 是分开的，目的是提高访问的 <strong>命中率</strong></li><li><strong>指令预取部件</strong> 每次可以取两条指令，如果是简单指令，并且后一条指令不依赖前一条指令的执行结果，那么，指令预取部件便将两条指令分别送到 U 流水线和 V 流水线独立执行</li><li><strong>指令 Cache、指令预取部件</strong> 将原始指令送到指令译码器，分支目标缓冲器则在遇到分支转移指令时用来预测转移是否发生</li><li><strong>浮点处理单元</strong> 主要用于浮点运算，内含专用的加法器、乘法器和除法器，加法器和乘法器均能在 3 个时钟周期内完成相应的运算，除法器则在每个时钟周期产生 2 位二进制商</li><li><strong>控制 ROM</strong> 中含有 Pentium 微处理器的微代码，控制部件直接控制流水线操作。</li></ul><h3 id="寄存器结构-1">寄存器结构</h3><p>80486 内部寄存器分为四类：基本结构寄存器、浮点寄存器、系统级寄存器、调试测试寄存器。应用程序只能访问基本结构寄存器和浮点寄存器。这里只介绍基本结构寄存器，<strong>除了标志寄存器外，其余寄存器的命名和使用方法都没有改变</strong>。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906095449.png" alt="image-20220906095449778" style="zoom:80%;" / loading="lazy"></p><h4 id="通用寄存器-1">通用寄存器</h4><p>能进行 32 位运算的寄存器分别称为 <code>EAX</code>、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>ESI</code>、<code>EDI</code>、<code>EBP</code> 和 <code>ESP</code>。其中 <code>EAX</code>、<code>EBX</code>、<code>ECX</code>、<code>EDX</code> 的 <strong>低 16 位</strong> 构成了 16 位微处理器中的通用寄存器（去掉 E），然后 <strong>低 16 位</strong> 又可以进一步拆成 <strong>两个 8 位</strong> 通用寄存器。</p><h4 id="段寄存器-1">段寄存器</h4><p><strong>6 个 16 位的段寄存器</strong> 用于指示代码和数据所用的地址空间。代码段寄存器 <code>CS</code>、堆栈段寄存器 <code>SS</code>、<code>DS</code>、<code>ES</code>、<code>FS</code> 和 <code>GS</code> 都称为数据段寄存器，除 <code>CS</code> 用于指示指令代码的地址空间外，其他段寄存器都用于指示 <strong>数据</strong> 的地址空间。当微处理器工作在 <strong>实地址模式</strong> 下，这些段寄存器提供的内容就是 <strong>16 位的段基址</strong></p><table><thead><tr class="header"><th>逻辑段</th><th>段基址存放</th><th>偏移地址存放</th><th>初始值</th></tr></thead><tbody><tr class="odd"><td>代码段</td><td>CS</td><td>IP</td><td>操作系统赋值</td></tr><tr class="even"><td>堆栈段</td><td>SS</td><td>SP</td><td>程序员或操作系统赋值</td></tr><tr class="odd"><td>数据段</td><td>DS</td><td>根据不同的寻址方式选择 BX、SI、DI</td><td>程序员赋值</td></tr><tr class="even"><td>附加段</td><td>ES/FS/GS</td><td>根据不同的寻址方式选择 BX、SI、DI</td><td>程序员赋值</td></tr></tbody></table><h4 id="指令指针寄存器-1">指令指针寄存器</h4><p><code>EIP</code> 中存放相对于代码段寄存器 <code>CS</code> 的基址的偏移量。<code>EIP</code> 的低 16 位可作为独立使用的寄存器，称为 <code>IP</code>, 它在实地址模式下，与 <code>CS</code> 组合后，形成 20 位的物理地址</p><h4 id="标志寄存器-1">标志寄存器</h4><p>标志寄存器是 32 位的寄存器，称为 <code>EFLAGS</code>。<code>EFLAGS</code> 中的位同样分为状态标志位和控制标志位两类：</p><ul><li>状态标志位指明程序运行时的微处理器的实时状态，这种状态会像某种先决条件一样影响后面的操作。有 SF、ZF、PF、CF、AF 和 OF</li><li>控制标志位由程序设计者设置，有 DF、 IF、 TF。每个控制标志都对某一种特定的功能起控制作用</li><li><code>EFLAGS</code> 的低位也可作为一个独立的标志寄存器 <code>FLAGS</code>（又称为程序状态字 <code>PSW</code>）来使用。</li></ul><h2 id="位微处理器工作模式">32 位微处理器工作模式</h2><blockquote><p>80x86 系列的 32 位微处理器（80386 及其后继处理器）支持 16 位和 32 位指令系统，32 位指令系统是在 16 位指令系统的基础上扩展而成的。32 位处理器有 3 种工作模式：实地址模式（Real Address Mode)、保护虚拟地址模式(Protected Virtual Address Mode)和虚拟 8086 模式，简称为实模式、保护模式和虚拟 86 模式。</p></blockquote><h3 id="位微处理器地址空间">32 位微处理器地址空间</h3><p>80X86 系列的 32 位微处理器有 3 个明确的存储地址空间，它们是 <strong>物理空间</strong>、<strong>虚拟空间</strong> 和 <strong>线性空间</strong>。</p><ul><li>物理空间是计算机中主存储器的实际空间，也称为主存空间，相应的地址称为 <strong>物理地址</strong> 或 <strong>主存地址</strong>。任一存储单元都具有唯一的一个物理地址。对主存的访问最终必须通过物理地址来实现。32 位微处理器有两个独立的物理空间：一个是 <strong>物理存储空间</strong>，另一个是 <strong>物理 I/O 空间</strong>。80X86 的物理 I/O 空间由<span class="math inline">\(2^{16}(64K)\)</span>个地址组成。它与存储地址不重叠<ul><li>8086：20 根地址线，寻址范围<span class="math inline">\(1M\)</span></li><li>80486：32 根地址线，寻址范围<span class="math inline">\(4GB\)</span></li></ul></li><li><strong>虚拟空间又称为逻辑空间</strong>，是应用程序员编写程序的空间，此空间对应的存储器称为虚拟存储器，该存储空间对应的地址称为虚拟地址或逻辑地址。该空间可比主存实际能提供的空间大很多，即使主存空间不够大，也能运行程序员编写的程序</li><li>32 位微处理器通过 <strong>分段部件</strong> 把虚拟空间变换为 32 位的 <strong>线性空间</strong>，如果分页部件未被选用（实模式），线性地址就是物理地址</li></ul><h3 id="位微处理器工作模式-1">32 位微处理器工作模式</h3><h4 id="实地址模式">实地址模式</h4><blockquote><p>在实模式下，32 位微处理器与它的前款处理器 16 位的 8086 兼容，所以为 8086、80286 编写的程序不需要做任何修改，就可以在 32 位微处理器的实模式下运行，且速度更快。除此之外，在实模式下，还能有效地使用 8086 所没有的寻址方式、32 位寄存器和大部分指令。在实模式下，32 位微处理器具有与 8086 同样的基本体系结构。</p></blockquote><p>实地址的特点：</p><ol type="1"><li>加电、复位之后，486 自动工作在实模式，系统在 DOS 管理下</li><li>在实模式下，微处理器的地址线仅低 20 根启动，所以 486 只能访问最低端的 <span class="math inline">\(1M\)</span> 内存（<span class="math inline">\(00000H\sim FFFFFH\)</span>）</li><li>存储管理部件对存储器只进行分段管理，<strong>没有分页功能（线性地址即为物理地址）</strong>，每一逻辑段的最大容量为 <span class="math inline">\(64K\)</span></li><li>该模式下，段寄存器中存放段基址</li></ol><p>实地址物理地址形成:star:</p><p>实地址模式下，物理地址的地址信息是 20 位的二进制代码，以 16 进制表示是 <span class="math inline">\(00000H\sim FFFFFH\)</span> 中的一个单元，CPU 访问存储器时，地址总线上送出的是 20 位物理地址。但是由于之前的 8086/8088 处理的数据总线宽度只有 16 位，无法传输 20 位的地址，所以在 <strong>编程（虚拟）空间</strong> 引入了 <strong>逻辑地址</strong>，即 <strong>段地址：偏移地址</strong> 的模式，即用 4 个 16 进制表示物理地址。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906103752.png" alt="image-20220906103752489" style="zoom:67%;" / loading="lazy"></p><p>系统将内存分为若干个逻辑段（最大 <span class="math inline">\(64K\)</span>），在同一逻辑段中，各单元的 16 位段地址是相同的，偏移地址是该单元相对于段首的 16 位地址偏移量。系统默认时，段都起始于 16 字节的边界，即段起始物理地址为 <span class="math inline">\(XXXX0H\)</span></p><ul><li>计算方法：将段地址左移 4 位后与偏移地址相加</li></ul><blockquote><p>段寄存器 <code>CS</code> 内容为 <span class="math inline">\(1000H\)</span>，偏移地址在 <code>IP</code> 寄存器中，为 <span class="math inline">\(2345H\)</span></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906104115.png" alt="image-20220906104115472" style="zoom: 50%;" / loading="lazy"></p></blockquote><ul><li>物理地址唯一，逻辑地址不唯一（取决于分段的方式）</li></ul><h3 id="保护虚拟地址模式">保护虚拟地址模式</h3><p>特点：</p><ol type="1"><li>486 支持多任务操作系统</li><li>486 可以访问 4G 物理存储空间</li><li>CPU 内部的存储管理部件对存储器采用分段和分页管理。可以将磁盘等存储设备有效映射到内存，使逻辑地址空间大大超过实际的物理地址空间，这样使主存储器容量似乎很大</li><li>既能进行 16 位运算，也能进行 32 位运算。</li></ol><p>保护机制：高级别的程序可以访问同级或低级的数据段，反之则不行</p><h3 id="虚拟-8086-模式">虚拟 8086 模式</h3><blockquote><p>32 位微处理器允许在实模式和保护模式下执行 8086 的应用程序。后者为系统设计人员提供了 32 位微处理器保护模式的全部功能，因而具有更大的灵活性。保护模式的功能之一是能够在保护和多任务的环境中直接执行实模式的 8086 软件，这个特性称为虚拟 8086 模式，又简称为虚拟 86 模式，这不是一种实际的处理器方式，而是一种准操作方式。虚拟 8086 模式具有保护方式下的任务属性。</p></blockquote><ol type="1"><li>可以执行 8086 的应用程序</li><li>段寄存器的用法和实模式一样，即段寄存器内容左移 <span class="math inline">\(4\)</span> 位加上偏移地址即为线性地址</li><li>存储器寻址空间为 <span class="math inline">\(1MB\)</span></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;中秋节，真不戳&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906105428.jpg&quot; alt=&quot;100953677_p0_master1200&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="汇编语言程序设计" scheme="http://lapras.xyz/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="汇编" scheme="http://lapras.xyz/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（九）</title>
    <link href="http://lapras.xyz/2022/08/29/c4a21082.html"/>
    <id>http://lapras.xyz/2022/08/29/c4a21082.html</id>
    <published>2022-08-29T14:36:12.275Z</published>
    <updated>2022-08-29T14:43:03.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>真不戳，住在郊区真不戳</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/asdasd.jpg" alt="100819348_p0_master1200" style="zoom: 50%;" / loading="lazy"></p><span id="more"></span><h2 id="微操作命令分析">微操作命令分析</h2><p>控制单元具有发出各种 <strong>微操作命令</strong>（即控制信号）序列的功能。而不同的指令对应不同的命令。进一步分析发现，完成不同指令的过程中，有些操作是相同或相似的，如取指令、取操作数地址（当间接寻址时）以及进入中断周期由中断隐指令完成的一系列操作。为更清晰起见，下面按指令周期的 4 个阶段进一步分析其对应的微操作命令。</p><p>下面开始分析，其中除了执行周期以外的周期都在 <strong>指令流水</strong> 章中介绍过了，不再赘述</p><h3 id="执行周期">执行周期</h3><p>不同指令执行周期的微操作是不同的，下面分别讨论非访存指令、访存指令和转移类指令的微操作</p><h4 id="非访存指令">非访存指令</h4><p>顾名思义，这类指令在执行周期不会访问存储器</p><ol type="1"><li><p>清除累加器指令 <span class="math inline">\(CLA\)</span></p><p>完成清除累加器操作，记作 <span class="math inline">\(0 \to ACC\)</span></p></li><li><p>累加器取反指令 <span class="math inline">\(COM\)</span></p><p>将累加器中的内容取反，记作 <span class="math inline">\(\overline{ACC} \to ACC\)</span></p></li><li><p>算术右移一位指令 <span class="math inline">\(SHR\)</span></p><p>将累加器中的内容进行算术右移一位，先右移，记作 <span class="math inline">\(L(ACC)\to R(ACC)\)</span>，然后保证符号位（最高位）不变 <span class="math inline">\(ACC_0 \to ACC_0\)</span></p></li><li><p>循环左移一位指令 <span class="math inline">\(CSL\)</span></p><p>将累加器中的内容进行循环左移一位，先左移，记作 <span class="math inline">\(R(ACC) \to L(ACC)\)</span>，然后将原本的最高位变为最低位，记作 <span class="math inline">\(ACC_0 \to ACC_n\)</span></p></li><li><p>停机指令 <span class="math inline">\(STP\)</span></p><p>计算机中有一个运行标志触发器 <span class="math inline">\(G\)</span>，当其值为 1 时，表示机器运行；反之，则为停机。<span class="math inline">\(STP\)</span> 指令在执行阶段只需将运行标志触发器置零，记作 <span class="math inline">\(0 \to G\)</span></p></li></ol><h4 id="访存指令">访存指令</h4><p>这类指令在执行阶段都需要访问存储器。简单起见，这里只考虑直接寻址的情况</p><ol type="1"><li><p>加法指令 <span class="math inline">\(ADD \ X\)</span></p><p>该指令将了累加器的内容与主存 <span class="math inline">\(X\)</span> 地址单元的内容相加，结果送入累加器。具体过程如下</p><ol type="1"><li>将指令的地址码部分送至存储器地址寄存器，记作 <span class="math inline">\(Ad(IR)\to MAR\)</span></li><li>向主存发读命令，启动主存作读操作，记作 <span class="math inline">\(1 \to R\)</span>。</li><li>将 <span class="math inline">\(MAR\)</span>（通过地址总线）所指的主存单元中的内容（操作数）经数据总线读至 <span class="math inline">\(MDR\)</span> 内，记作 <span class="math inline">\(M(MAR)\to MDR\)</span>。</li><li>给 <span class="math inline">\(ALU\)</span> 发送加命令，将 <span class="math inline">\(ACC\)</span> 的内容和 <span class="math inline">\(MDR\)</span> 的内容相加，结果存于 <span class="math inline">\(ACC\)</span>, 记作 <span class="math inline">\((ACC)+(MDR)\to ACC\)</span></li></ol><p>当然，也有的加法指令指定两个寄存器的内容相加，如 <span class="math inline">\(ADD AX BX\)</span>，该指令在执行阶段无须访存，只需完成 <span class="math inline">\((AX)+(BX)\to AX\)</span> 的操作。</p></li><li><p>存数指令 <span class="math inline">\(STA \ X\)</span></p><p>该指令在执行阶段需将累加器 <span class="math inline">\(ACC\)</span> 的内容存于主存的 <span class="math inline">\(X\)</span> 地址单元中，具体操作如下</p><ol type="1"><li>将指令的地址码部分送至存储器地址寄存器，记作 <span class="math inline">\(Ad(IR) \to MAR\)</span></li><li>向主存发写命令，启动主存作写操作，记作 <span class="math inline">\(1\to W\)</span></li><li>将累加器内容送至 <span class="math inline">\(MDR\)</span>, 记作 <span class="math inline">\(ACC\to MDR\)</span></li><li>将 <span class="math inline">\(MDR\)</span> 的内容（通过数据总线）写入到 <span class="math inline">\(MAR\)</span>(通过地址总线）所指的主存单元中，记作 <span class="math inline">\(MDR\to M(MAR)\)</span></li></ol></li><li><p>取数指令 <span class="math inline">\(LDA\ X\)</span></p><p>该指令在执行阶段需将主存的 <span class="math inline">\(X\)</span> 地址单元中的内容取至累加器 <span class="math inline">\(ACC\)</span> 中，具体操作如下</p><ol type="1"><li>将指令的地址码部分送至存储器地址寄存器，记作 <span class="math inline">\(Ad(IR) \to MAR\)</span></li><li>向主存发读命令，启动主存作写操作，记作 <span class="math inline">\(1\to R\)</span></li><li>将 <span class="math inline">\(MAR\)</span>（通过地址总线）所指的主存单元中的内容（操作数）经过数据总线送入 <span class="math inline">\(MDR\)</span> 内，记作 <span class="math inline">\((MAR) \to MDR\)</span></li><li>将 <span class="math inline">\(MDR\)</span> 的内容送至 <span class="math inline">\(ACC\)</span> 中，记作 <span class="math inline">\(MDR\to ACC\)</span></li></ol></li></ol><h4 id="转移类指令">转移类指令</h4><ol type="1"><li><p>无条件转移指令 <span class="math inline">\(JMP \ X\)</span></p><p>该指令在执行阶段完成将指令的地址码部分 X 送至 PC 的操作，记作 <span class="math inline">\(Ad(IR)\to PC\)</span></p></li><li><p>条件转移指令中的 <strong>负则转</strong> 指令 <span class="math inline">\(BAN \ X\)</span></p><p>该指令根据上一条指令运行的结果决定下一条指令的地址，若结果为负（累加器最高位为 1, 即 <span class="math inline">\(A_0 =1\)</span>），则指令的地址码送至 <span class="math inline">\(PC\)</span>，否则程序按原顺序执行</p><p>由于在取指阶段已完成了 <span class="math inline">\((PC)+1\to PC\)</span>，所以当累加器结果不为负时，就按取指阶段形成的 <span class="math inline">\(PC\)</span> 执行，记作 <span class="math inline">\(A_0 \cdot{Ad}(IR)+\bar{A_0}(PC) \to PC\)</span></p></li></ol><h4 id="三类指令的指令周期">三类指令的指令周期</h4><ul><li>非访存：取指，执行</li><li>直接访存：取指，执行</li><li>间接访存：取指，间址，执行</li><li>转移：取指，执行</li><li>间接转移：取指，间址，执行</li></ul><h2 id="控制单元的功能">控制单元的功能</h2><h3 id="控制单元的外特性">控制单元的外特性</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E5%A4%96%E7%89%B9%E6%80%A7.png" alt="image-20220829185843527" style="zoom:80%;" / loading="lazy"></p><h4 id="输入信号">输入信号</h4><ol type="1"><li><p>时钟</p><p>为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制，即每一个时钟脉冲使控制单元发送一个操作命令，或发送一组需要同时执行的操作命令</p></li><li><p>指令寄存器</p><p>现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，故指令的操作码字段是控制单元的输入信号，它与时钟配合可产生不同的控制信号</p></li><li><p>标志</p><p>控制单元有时需依赖 CPU 当前所处的状态（如 ALU 操作的结果）产生控制信号，控制单元要根据上条指令的结果是否为负而产生不同的控制信号。因此“标志”也是控制单元的输入信号。</p></li><li><p>来自系统总线（控制总线）的控制信号</p><p>例如，INTR 中断请求，HRQ 总线请求</p></li></ol><h4 id="输出信号">输出信号</h4><ol type="1"><li><p>CPU 内的控制信号</p><p>主要用于 CPU 内的寄存器之间的传送和控制 ALU 实现不同的操作</p></li><li><p>送至系统总线（控制总线）的信号</p><p>例如，命令主存或 I/O 读写，中断响应等</p></li></ol><h3 id="控制信号举例">控制信号举例</h3><h4 id="单总线结构数据通路方式">单总线结构数据通路方式</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image-20220829211519492" style="zoom:80%;" / loading="lazy"></p><ul><li>内部总线：指同一部件，如 CPU 内部连接各寄存器及运算部件之间的总线</li><li>系统总线：指同一台计算机系统的各部件，如 CPU、内存、通道和各类 I/O 接口间互相连接的总线</li></ul><ol type="1"><li><p>寄存器之间的数据传送</p><p>例，<span class="math inline">\(PC\)</span> 内容送至 <span class="math inline">\(MAR\)</span>：</p><ol type="1"><li><span class="math inline">\((PC) \to Bus\)</span>，<span class="math inline">\(PCount\)</span> 有效</li><li><span class="math inline">\(Bus \to MAR\)</span>，<span class="math inline">\(MARin\)</span> 有效</li></ol></li><li><p>主存与 CPU 之间的数据传送</p></li></ol><p>例，CPU 从主存读取指令：</p><ol type="1"><li><p><span class="math inline">\((PC) \to Bus \to MAR\)</span>，<span class="math inline">\(PCout,MARin\)</span> 有效</p></li><li><p><span class="math inline">\(1 \to R\)</span>，<span class="math inline">\(CU\)</span> 经过控制总线发送读信号</p></li><li><p>$M(MAR) MDR <span class="math inline">\(，\)</span>MDRinE$（带有 <span class="math inline">\(E\)</span> 表示与主存的数据通路）有效</p></li><li><p><span class="math inline">\(MDR \to Bus \to IR\)</span>，<span class="math inline">\(MDRin, IRin\)</span> 有效</p></li><li><p><span class="math inline">\((PC)+1 \to PC\)</span></p></li><li><p>执行算术或逻辑运算</p><p>例，加法指令（其中一个操作数已在 <span class="math inline">\(ACC\)</span> 中）</p><ol type="1"><li><span class="math inline">\(Ad(IR) \to Bus \to MAR\)</span>，<span class="math inline">\(IRout,MARin\)</span> 有效</li><li><span class="math inline">\(1 \to R\)</span>，<span class="math inline">\(CU\)</span> 发送读命令</li><li><span class="math inline">\(M(MAR) \to MDR\)</span>，<span class="math inline">\(MDRinE\)</span> 有效</li><li><span class="math inline">\(MDR \to Bus \to Y\)</span>，<span class="math inline">\(MDRout, Yin\)</span> 有效，让操作数存放于暂存寄存器（因为 CPU 的数据总线是 <strong>单总线</strong> 只能同时传送一个输入信号，所以让 <span class="math inline">\(ACC\)</span> 走总线，而把另一个操作数放置于与 <span class="math inline">\(ACC\)</span> 有专用数据通路的 <span class="math inline">\(Y\)</span> 寄存器之中）</li><li><span class="math inline">\((ACC) +(Y) \to Z\)</span>，<span class="math inline">\(ACCout,ALUin\)</span> 有效，<span class="math inline">\(CU\)</span> 向 <span class="math inline">\(ALU\)</span> 发送加命令</li><li><span class="math inline">\(Z \to ACC\)</span>，<span class="math inline">\(Zout,ACCin\)</span> 有效</li></ol></li></ol><h4 id="专用数据通路方式">专用数据通路方式</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%93%E7%94%A8%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E6%96%B9%E5%BC%8F.png" alt="image-20220829194527188" style="zoom:80%;" / loading="lazy"></p><ol type="1"><li>取指周期<ol type="1"><li><span class="math inline">\((PC) \to MAR\)</span>，<span class="math inline">\(C_0\)</span> 有效</li><li><span class="math inline">\((MAR) \to MEM\)</span>，<span class="math inline">\(C_1\)</span> 有效</li><li><span class="math inline">\(1 \to R\)</span>，<span class="math inline">\(CU\)</span> 向主存发送读命令</li><li><span class="math inline">\(M(MAR)\to MDR\)</span>，<span class="math inline">\(C_2\)</span> 有效</li><li><span class="math inline">\((MDR)\to IR\)</span>，<span class="math inline">\(C_3\)</span> 有效</li><li><span class="math inline">\((PC)+1 \to PC\)</span></li><li><span class="math inline">\(OP(IR) \to CU\)</span>，<span class="math inline">\(C_4\)</span> 有效，对指令译码</li></ol></li><li>间址周期<ol type="1"><li><span class="math inline">\((MDR)\to MAR\)</span>，<span class="math inline">\(C_5\)</span> 有效</li><li><span class="math inline">\((MAR) \to MEM\)</span>，<span class="math inline">\(C_1\)</span> 有效</li><li><span class="math inline">\(1 \to R\)</span>，<span class="math inline">\(CU\)</span> 向主存发送读命令</li><li><span class="math inline">\(M(MAR)\to MDR\)</span>，<span class="math inline">\(C_2\)</span> 有效，此时 <span class="math inline">\(MDR\)</span> 就保存了操作数的地址</li><li><span class="math inline">\((MDR)\to IR\)</span>，<span class="math inline">\(C_3\)</span> 有效</li></ol></li><li>执行周期，以 $ADD $ 为例<ol type="1"><li><span class="math inline">\((MDR)\to MAR\)</span>，<span class="math inline">\(C_5\)</span> 有效</li><li><span class="math inline">\((MAR) \to MEM\)</span>，<span class="math inline">\(C_1\)</span> 有效</li><li><span class="math inline">\(1 \to R\)</span>，<span class="math inline">\(CU\)</span> 向主存发送读命令</li><li><span class="math inline">\(M(MAR)\to MDR\)</span>，<span class="math inline">\(C_2\)</span> 有效，此时 <span class="math inline">\(MDR\)</span> 就保存了操作数本身</li><li><span class="math inline">\((MDR) + (ACC) \to ACC\)</span>，<span class="math inline">\(C_6,C_7,C_8\)</span> 有效</li></ol></li></ol><h3 id="多级时序系统">多级时序系统</h3><h4 id="机器周期">机器周期</h4><p>机器周期可看做是所有指令执行过程中的一个 <strong>基准时间</strong>，机器周期取决于指令的功能及器件的速度。分析发现，机器内的各种操作大致可归属为对 <strong>CPU 内部的操作</strong> 和 <strong>对主存的操作</strong> 两大类，由于 CPU 内部的操作速度较快，CPU 访存的操作时间较长，因此通常 <strong>以访问一次存储器的时间</strong> 定为基准时间较为合理，这个基准时间就是机器周期。又由于不论执行什么指令，都需要访问存储器取出指令，因此在 <strong>存储字长等于指令字长的前提下，取指周期也可看做机器周期</strong>。</p><h4 id="时钟周期">时钟周期</h4><p>在 <strong>一个机器周期里可完成若干个微操作</strong>，每个微操作都需要一定的时间，可用时钟信号来控制产生每一个微操作命令。时钟就好比计算机的心脏，只要接通电源，计算机内就会产生时钟信号。时钟信号可由机器主振电路（如晶体振荡器）发出的脉冲信号经整形（或倍频、分频）后产生，时钟信号的频率即为 <strong>CPU 主频</strong>。用时钟信号控制节拍发生器，就可产生 <strong>节拍</strong>。每个节拍的宽度正好对应一个 <strong>时钟周期</strong>。在每个节拍内机器可完成一个或几个需同时执行的操作，它是 <strong>控制计算机操作的最小时间单位</strong>。</p><h4 id="多级时序系统-1">多级时序系统</h4><ul><li>机器周期、节拍（状态）组成多级时序系统</li><li>一个指令周期包含若干个机器周期</li><li>一个机器周期包含若干个时钟周期</li></ul><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%A4%9A%E7%BA%A7%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F.png" alt="image-20220829215457197" style="zoom: 67%;" / loading="lazy"></p><p>一般来说，CPU 的主频越快，机器的运行速度也越快。在机器周期所含时钟周期数相同的前提下，两机平均指令执行速度之比等于两机主频之比。例如，CPU 的主频为 <span class="math inline">\(8MHz\)</span>，其平均指令执行速度为 <span class="math inline">\(0.8MIPS\)</span>。若想得到平均指令执行速度为 <span class="math inline">\(0.4MIPS\)</span> 的机器，则只需要用主频为 <span class="math inline">\((8MHz×0.4MIPS)/0.8MIPS=4MHz\)</span> 的 CPU 即可。实际上机器的速度不仅与主频有关，还与机器周期中所含的时钟周期数以及指令周期中所含的机器周期数有关。同样主频的机器，由于机器周期所含时钟周期数不同，运行速度也不同。机器周期所含时钟周期数少的机器，速度更快。</p><h3 id="控制方式">控制方式</h3><p>控制单元控制一条指令执行的过程实质上是依次执行一个确定的微操作序列的过程。由于不同指令所对应的微操作数及其复杂程度不同，因此每条指令和每个微操作所需的执行时间也不同。通常将如何形成控制不同微操作序列所采用的时序控制方式称为 <span class="math inline">\(CU\)</span> 的控制方式。常见的控制方式有同步控制、异步控制、联合控制和人工控制。</p><h4 id="同步控制">同步控制</h4><p>同步控制方式是指，任何一条指令或指令中任何一个微操作的执行都是事先确定的，并且都是受 <strong>统一基准时标的时序信号</strong> 所控制的方式。如果机器内的存储器存取周期不统一，那么只有把 <strong>最长的存取周期作为机器周期</strong>，才能采用同步控制，否则取指令和取数时间不同，无法用统一的基准。又如有些不访存的指令，执行周期的微操作较少，无须那么多节拍。因此，为了提高 CPU 的效率，在同步控制中又有三种方案</p><ol type="1"><li><p>采用定长的机器周期</p><p>一律以最长的微操作序列和最繁的微操作作为标准，采取完全统一的、具有相同时间隔和相同数目的节拍作为机器周期来运行各种不同的指令。显然，这种方案对于微操作序列较短的指令来说，会造成时间上的浪费。</p></li><li><p>采用不定长的机器周期</p><p>每个机器周期内的节拍数可以不等。这种控制方式可解决微操作执行时间不统一的问题。通常把大多数微操作安排在一个较短的机器周期内完成，而对某些复杂的微操作，采用 <strong>延长机器周期</strong> 或 <strong>增加节拍</strong> 的办法来解决。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F.png" alt="image-20220829220707428" style="zoom:80%;" / loading="lazy"></p></li><li><p>采用中央控制和局部控制相结合的方法</p><p>这种方案将机器的大部分指令安排在统一的、较短的机器周期内完成，称为中央控制，而将少数操作复杂的指令中的某些操作（如乘除法和浮点运算等）采用局部控制方式来完成</p><p>在设计局部控制线路时需要注意两点：</p><ol type="1"><li>使局部控制的每一个节拍 <span class="math inline">\(T^*\)</span> 的宽度与中央控制的节拍宽度相同</li><li>将局部控制节拍作为中央控制中机器节拍的延续，插入到中央控制的执行周期内，使机器以同样的节奏工作，保证了局部控制和中央控制的同步。<span class="math inline">\(T^*\)</span> 的多少可根据情况而定</li></ol></li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%AD%E5%A4%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E5%B1%80%E9%83%A8%E6%8E%A7%E5%88%B6%E7%9B%B8%E6%9C%BA%E5%92%8C.png" alt="image-20220829222552838" style="zoom: 60%;" / loading="lazy"></p><h4 id="异步控制">异步控制</h4><p>异步控制方式不存在基准时标信号，没有固定的周期节拍和严格的时钟同步，执行每条指令和每个操作需要多少时间就占用多少时间。这种方式微操作的时序由 <strong>专门的应答线路控制</strong>，即当 <span class="math inline">\(CU\)</span> 发出执行某一微操作的控制信号后，等待执行部件完成了该操作后发回 <strong>回答信号</strong>，再开始新的微操作，使 CPU 没有空闲状态，但因需要采用各种应答电路，故其结构比同步控制方式复杂。</p><h4 id="联合控制方式">联合控制方式</h4><p>同步控制和异步控制相结合就是联合控制方式。这种方式对各种不同指令的微操作实行大部分统一、小部分区别对待的办法。例如，对每条指令都有的取指令操作，采用同步方式控制；对那些时间难以确定的微操作，如 I/O 操作，则采用异步控制，以执行部件送回的“回答”信号作为本次微操作的结束。</p><h4 id="人工控制方式">人工控制方式</h4><p>人工控制是为了调机和软件开发的需要，在机器面板或内部设置一些开关或按键，来达到人工控制的目的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;真不戳，住在郊区真不戳&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/asdasd.jpg&quot; alt=&quot;100819348_p0_master1200&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（八）</title>
    <link href="http://lapras.xyz/2022/08/28/be6f31dd.html"/>
    <id>http://lapras.xyz/2022/08/28/be6f31dd.html</id>
    <published>2022-08-28T08:37:25.238Z</published>
    <updated>2022-08-28T08:38:25.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>开学了！G！</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/chao.jpg" alt="100750654_p0_master1200" style="zoom:80%;" / loading="lazy"></p><span id="more"></span><h2 id="cpu-结构">CPU 结构</h2><h3 id="控制器的功能">控制器的功能</h3><p>对于冯诺依曼结构的计算机而言，一旦程序进入存储器后，就可由计算机自动完成取指令和执行指令的任务，<strong>控制器</strong> 就是专用于完成此项工作的，它负责协调并控制计算机各部件执行程序的指令序列，其基本功能是取指令、分析指令和执行指令。</p><ol type="1"><li><p>取指令</p><p>控制器必须具备能自动地从存储器中取出指令的功能。为此，要求控制器能自动形成指令的地址，并能发出取指令的命令，将对应此地址的指令取到控制器中。第一条指令的地址可以人为指定，也可由系统设定。</p></li><li><p>分析指令</p><p>分析指令包括两部分内容：其一，分析此指令要完成什么操作，即控制器需发出什么操作命令；其二，分析参与这次操作的操作数地址，即操作数的有效地址。</p></li><li><p>执行指令 执行指令就是根据分析指令产生的“操作命令”和“操作数地址”的要求，形成操作控制信号序列。</p></li><li><p>控制程序的输入和运算结果的输出，即控制主机与 I/0 设备交换信息</p></li><li><p>总线管理</p></li><li><p>处理机器运行过程中出现的异常情况和特殊请求</p></li></ol><blockquote><p>总之，CPU 必须具有控制程序的顺序执行（称指令控制）、产生完成每条指令所需的控制命令（称操作控制）、对各种操作加以时间上的控制（称时间控制）、对数据进行算术运算和逻辑运算（数据加工）以及处理中断等功能。</p></blockquote><h3 id="cpu-结构框图">CPU 结构框图</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/CPU%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.png" alt="image-20220822225230720" style="zoom:80%;" / loading="lazy"></p><ul><li>指令控制：<span class="math inline">\(PC\)</span>（指出了要取出的指令的地址）和 <span class="math inline">\(IR\)</span>（存放当前指令的地址）</li><li>操作控制 时间控制：<span class="math inline">\(CU\)</span>和时序电路</li><li>数据加工：<span class="math inline">\(ALU\)</span>和寄存器</li><li>处理中断：中断系统</li></ul><h3 id="cpu-的寄存器">CPU 的寄存器</h3><h4 id="用户可见寄存器">用户可见寄存器</h4><p>通常 CPU 执行机器语言访问的寄存器为用户可见寄存器，按其特征又可分为以下几类。</p><ol type="1"><li><p>通用寄存器：通用寄存器可由程序设计者指定许多功能，可用于存放操作数，也可作为满足某种寻址方式所需的寄存器。例如，基址寻址所需的基址寄存器、变址寻址所需的变址寄存器和堆栈寻址所需的栈指针，都可用通用寄存器代替。寄存器间接寻址时还可用通用寄存器存放有效地址的地址。</p></li><li><p>数据寄存器：数据寄存器用于存放操作数，其位数应满足多数数据类型的数值范围，有些机器允许使用两个连读的寄存器存放双倍字长的值。还有些机器的数据寄存器只能用于保存数据，不能用于操作数地址的计算。</p></li><li><p>地址寄存器：地址寄存器用于存放地址，其本身可以具有通用性，也可用于特殊的导址</p></li><li><p>条件码寄存器：这类寄存器中存放条件码，它们对用户来说是部分透明的。条件码是 CPU 根据运算结果由硬件设置的位，例如，算术运算会产生正、负、零或溢出等结果。条件码可被测试，作为分支运算的依据。</p></li></ol><h4 id="控制寄存器">控制寄存器</h4><p>CPU 中还有一类寄存器用于控制 CPU 的操作或运算。在一些机器里，大部分这类寄存器对用户是透明的。如以下四种寄存器在指令执行过程中起重要作用。</p><ol type="1"><li>MAR：存储器地址寄存器，用于存放将被访问的存储单元的地址</li><li>MDR：存储器数据寄存器，用于存放即将存入存储单元的数据，或者刚从存储单元中读出的数据</li><li>PC（不透明）：程序计数器，用于存放现行指令的地址，通常具备计数功能。且能被某些转移类指令修改</li><li>IR：指令寄存器，存放当前执行的指令</li></ol><h4 id="状态寄存器">状态寄存器</h4><ol type="1"><li>状态寄存器：存放指令执行结果，或者软硬件状态</li><li>PSW 寄存器：存放程序码</li></ol><h2 id="指令周期">指令周期</h2><h3 id="基本性质">基本性质</h3><p>指令周期：取出并执行一条指令的全部时间。一般来说，可以将其分为 <strong>取指周期</strong> 和 <strong>执行周期</strong>。</p><h4 id="指令周期类型">指令周期类型</h4><p>显然的，每条指令的指令周期因为指令类型不同而不一样：</p><ol type="1"><li><p>指令周期只有取值周期：NOP，JMP</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F1.png" alt="image-20220823100920627" style="zoom:80%;" / loading="lazy"></p></li><li><p>指令周期有取值周期和执行周期，且两者长度基本相等：ADD</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F2.png" alt="image-20220823101051004" style="zoom: 80%;" / loading="lazy"></p></li><li><p>指令周期有取值周期和执行周期，且后者长于前者：MUL</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F3.png" alt="image-20220823101206461" style="zoom:80%;" / loading="lazy"></p></li><li><p>具有间接寻址的指令周期</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F4.png" alt="image-20220823101326600" style="zoom:80%;" / loading="lazy"></p></li><li><p>具有中断周期的指令周期</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F5.png" alt="image-20220823101413059" style="zoom:80%;" / loading="lazy"></p></li></ol><h4 id="指令周期流程">指令周期流程</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B.png" alt="image-20220823101935137" style="zoom:80%;" / loading="lazy"></p><h4 id="cpu-工作周期的标志">CPU 工作周期的标志</h4><p>总之，上述 4 个周期都有 CPU 访存操作，只是访存的目的不同。<strong>取指周期</strong> 是为了取指令，<strong>间址周期</strong> 是为了取有效地址，<strong>执行周期</strong> 是为了取操作数（当指令为访存指令时）, <strong>中断周期</strong> 是为了保存程序断点。这 4 个周期又可称为 CPU 的工作周期，为了区别它们，在 CPU 内设置了 4 个 <strong>标志触发器</strong></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/CPU%E5%B7%A5%E4%BD%9C%E5%91%A8%E6%9C%9F%E7%9A%84%E6%A0%87%E8%AF%86.png" alt="image-20220823102943386" style="zoom:80%;" / loading="lazy"></p><p>FE、IND、EX 和 INT 分别对应取指、间址、执行和中断 4 个周期，并以“1”状态表示有效，它们分别由 1 → FE、1 → IND、1 → EX 和 1 → INT 这 4 个信号控制。</p><h3 id="数据流">数据流</h3><h4 id="取值周期的数据流">取值周期的数据流</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8F%96%E5%80%BC%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%811.png" alt="image-20220823110159861" style="zoom:80%;" / loading="lazy"></p><ol type="1"><li>$(PC)MAR $：当前指令的内存地址送至存储器地址寄存器</li><li><span class="math inline">\(1\to R\)</span>：<span class="math inline">\(CU\)</span> 发出 <strong>读控制信号</strong>，经控制总线传送到主存</li><li><span class="math inline">\(M(MAR) \to MDR\)</span>：将 <span class="math inline">\(MAR\)</span> 所指的主存中的指令地址的内容，经过数据总线送入 <span class="math inline">\(MDR\)</span></li><li><span class="math inline">\(MDR \to IR\)</span>：将指令内容送入 <span class="math inline">\(IR\)</span></li><li>$(PC) +1 PC <span class="math inline">\(：\)</span>CU$ 发出控制信号，让 <span class="math inline">\(PC\)</span> 的值加一，形成下一条指令地址</li></ol><h4 id="间址周期的数据流">间址周期的数据流</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%AE%80%E7%9B%B4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="image-20220823112246582" style="zoom:80%;" / loading="lazy"></p><ol type="1"><li><span class="math inline">\(Ad(IR) \to MAR\)</span> 或者 <span class="math inline">\(Ad(MDR)\to MAR\)</span>：将指令的地址码送入 <span class="math inline">\(MAR\)</span></li><li><span class="math inline">\(1 \to R\)</span>：<span class="math inline">\(CU\)</span> 发出读控制信号</li><li><span class="math inline">\(M(MAR) \to MDR\)</span>：将 <span class="math inline">\(MAR\)</span> 所指的主存中的指令地址的内容，即有效地址 <span class="math inline">\(EA\)</span>，经过数据总线送入 <span class="math inline">\(MDR\)</span></li><li><span class="math inline">\(MDR \to Ad(IR)\)</span>：将 <span class="math inline">\(EA\)</span> 送到指令字的地址码字段</li></ol><h4 id="执行周期的数据流">执行周期的数据流</h4><p>由于不同的指令在执行周期的操作不同，因此执行周期的数据流是多种多样的，可能涉及 CPU 内部寄存器间的数据传送、对存储器（或 I/O）进行读写操作或对 ALU 的操作，因此，无法用统一的数据流图表示。</p><h4 id="中断周期的数据流">中断周期的数据流</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="image-20220823120003697" style="zoom:80%;" / loading="lazy"></p><p>这里用堆栈保存断点，用 <span class="math inline">\(SP\)</span> 表示栈顶地址</p><ol type="1"><li><span class="math inline">\((SP) -1 \to SP,(SP) \to MAR\)</span>：<span class="math inline">\(CU\)</span> 控制将 <span class="math inline">\(SP\)</span> 减一后的地址送入 <span class="math inline">\(MAR\)</span>，即本次断点要存储的目标地址</li><li><span class="math inline">\((MAR) \to M\)</span>：<span class="math inline">\(MAR\)</span> 会将地址经过地址总线送入存储器</li><li><span class="math inline">\(1 \to W\)</span>：<span class="math inline">\(CU\)</span> 发出控制信号，启动主存做写操作</li><li><span class="math inline">\((PC)\to MDR\)</span>：断点的内容（即恢复断点时要执行的下一条指令地址）由 <span class="math inline">\(PC\)</span> 传送给 <span class="math inline">\(MDR\)</span></li><li><span class="math inline">\((MDR) \to M\)</span>：<span class="math inline">\(MDR\)</span> 经数据总线，将内容写入 <span class="math inline">\(MAR\)</span> 送入存储器的地址中</li><li><span class="math inline">\(\text{向量地址}\to PC\)</span>：<span class="math inline">\(CU\)</span> 控制将中断服务程序的 <strong>入口地址</strong>（由向量地址形成部件产生）送入 <span class="math inline">\(PC\)</span>，开始执行中断程序的内容</li></ol><h2 id="指令流水">指令流水</h2><h3 id="指令流水原理">指令流水原理</h3><p>完成一条指令实际上也可分为许多阶段。为简单起见，把指令的处理过程分为取指令和执行指令两个阶段，在不采用流水技术的计算机里，取指令和执行指令是周而复始地重复出现，各条指令按顺序串行执行的。这种顺序执行虽然控制简单，但执行中各部件的利用率不高，如指令部件工作时，执行部件基本空闲，而执行部件工作时，指令部件基本空闲。如果指令执行阶段不访问主存，则完全可以利用这段时间取下一条指令，这样就使取下一条指令的操作和执行当前指令的操作同时进行，这就是指令流水的基本原理，其基本示意图如下</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="未命名绘图.drawio" style="zoom:80%;" / loading="lazy"></p><ul><li>图中展示的称为 <strong>二级流水（一次重叠）</strong>。由指令部件取出一条指令，并将它暂存起来，如果执行部件空闲，就将暂存的指令传给执行部件执行。与此同时，指令部件又可取出下一条指令并暂存起来，这称为 <strong>指令预取</strong>。显然，这种工作方式能加速指令的执行。如果取指和执行阶段在时间上完全重叠，相当于将指令周期减半。</li></ul><p>然而进一步分析流水线，就会发现存在两个原因使得上述理想情况不会发生</p><ol type="1"><li><strong>指令的执行时间一般大于取指时间</strong>，因此，取指阶段可能要等待一段时间，也即存放在指令部件缓冲区的指令还不能立即传给执行部件，缓冲区不能空出。</li><li>当遇到 <strong>条件转移指令</strong> 时，下一条指令是不可知的，因为必须等到执行阶段结束后，才能获知条件是否成立，从而决定下条指令的地址，造成时间损失。通常为了减少时间损失，采用 <strong>猜测法</strong>，即当条件转移指令从取指阶段进入执行阶段时，指令部件仍按顺序预取下一条指令。这样，如果条件不成立，转移没有发生，则没有时间损失；若条件成立，转移发生，则所取的指令必须丢掉，并再取新的指令。</li></ol><p>尽管这些因素降低了两级流水线的潜在效率，但还是可以获得一定程度的加速。为了进一步提高处理速度，可将指令的处理过程分解为更细的几个阶段，形成六级流水（五次重叠）</p><ol type="1"><li>取指（FI）：从存储器取出一条指令并暂时存入指令部件的缓冲区</li><li>指令译码（DI）：确定操作性质和操作数地址的形成方式</li><li>计算操作数地址（CO）：计算操作数的有效地址，涉及寄存器间接寻址、间接寻址、变址、基址、相对寻址等各种地址计算方式</li><li>取操作数（FO）：从存储器中取操作数（若操作数在寄存器中，则无须此阶段）</li><li>执行指令（EI）：执行指令所需的操作，并将结果存于目的位置（寄存器中）</li><li>写操作数（WO）：将结果存入存储器</li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%85%AD%E7%BA%A7%E6%B5%81%E6%B0%B4.png" alt="image-20220824160353262" style="zoom:80%;" / loading="lazy"></p><h3 id="影响指令流水性能的因素">影响指令流水性能的因素</h3><h4 id="结构相关">结构相关</h4><p>结构相关是当指令在重叠执行过程中，不同指令争用同一功能部件产生资源冲突时产生的，故又有资源相关之称。解决方法有三种：</p><ol type="1"><li>停顿（加入气泡）：即让冲突的两条指令中的后一条，暂停一个时间周期再运行</li><li>设置两个独立的存储器分别存放操作数和指令，以免取指令和取操作数同时进行时互相冲突，使取某条指令和取另一条指令的操作数实现时间上的重叠。</li><li>指令预取技术，指令预取技术的实现基于访存周期很短的情况。例如，在执行指令阶段，取数时间很短，因此在执行指令时，主存会有空闲，此时，只要指令队列空出，就可取下一条指令，并放至空出的指令队列中，从而保证在执行第 K 条指令的同时对第 K+1 条指令进行译码，实现“执行 K”与“分析 K+1”的重叠。</li></ol><h4 id="数据相关">数据相关</h4><p>数据相关是流水线中的各条指令因重叠操作，可能改变对操作数的读写访问顺序，从而导致了数据相关冲突。根据指令间对同一寄存器读和写操作的先后次序关系，数据相关冲突可分为 <strong>写后读相关</strong>、<strong>读后写相关</strong> 和 <strong>写后写相关</strong>。解决办法有：</p><ol type="1"><li>后推法：采用后推法，即将相关指令延迟到所需操作数被写回到寄存器后再执行的方式</li><li>定向技术：又称为旁路技术或相关专用通路技术。其主要思想是不必待某条指令的执行结果送回到寄存器后，再从寄存器中取出该结果，作为下一条指令的源操作数，而是直接将执行结果送到其他指令所需要的地方</li></ol><h4 id="控制相关">控制相关</h4><p>控制相关主要是由转移指令引起的。统计表明，转移指令约占总指令的 1/4 左右，比起数据相关来，它会使流水线丧失更多的性能。执行转移指令时，根据是否发生转移，它可能将程序计数器 <span class="math inline">\(PC\)</span> 内容改变成转移目标地址，也可能只是使 <span class="math inline">\(PC\)</span> 加上一个增量，指向下一条指令的地址。这就意味着，必须等待转移指令完成时才能判断，否则可能进行无效的操作。</p><p>为了解决控制相关，可以采用尽早判别转移是否发生，尽早生成转移目标地址；预取转移成功或不成功两个控制流方向上的目标指令；加快和提前形成条件码；提高转移方向的猜准率等方法。</p><h3 id="流水线性能指标">流水线性能指标</h3><h4 id="吞吐率">吞吐率</h4><p>吞吐率是指在单位时间内流水线 <strong>所完成的指令的数量</strong>，或是 <strong>输出结果的数量</strong>，有 <strong>最大吞吐率</strong> 和 <strong>实际吞吐率</strong> 之分。流水线仅在连续流动（满负荷，无相关因素影响）时才可达到最大吞吐率。实际上由于流水线在开始时有一段建立时间（第一条指令输入后到其完成的时间），结束时有一段排空时间（最后一条指令输入后到其完成的时间），以及由于各种相关因素使流水线无法连续流动。因此，实际吞吐率总是小于最大吞吐率。</p><p>设任务数（指令数）为 <span class="math inline">\(n\)</span>，各指令分为 <span class="math inline">\(k\)</span> 段，<span class="math inline">\(k\)</span> 段流水线各段时间为 <span class="math inline">\(\Delta t\)</span>，花费的总时间为 <span class="math inline">\(T_k\)</span></p><p>则吞吐率 <span class="math inline">\(T_p = \frac{n}{T_k}\)</span></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%90%9E%E5%90%90%E7%8E%871.png" alt="image-20220824172449420" style="zoom:80%;" / loading="lazy"></p><p>观察上图，不难发现：第一条指令耗费的时间（装入时间）为 <span class="math inline">\(k\Delta t\)</span>，而后每经过 <span class="math inline">\(\Delta t\)</span>，都有一条指令完成</p><p>所以总时间 <span class="math inline">\(T_k = (k+n-1)\Delta t\)</span>，就可以得到</p><p>实际吞吐率 <span class="math inline">\(T_p = \frac{n}{ (k+n-1)\Delta t}\)</span></p><p>最大吞吐率 <span class="math inline">\(T_{pmax} = \lim_{n \to \infty} T_p = \frac{1}{\Delta t}\)</span></p><h4 id="加速比">加速比</h4><p>流水线的加速比是指 <span class="math inline">\(k\)</span> 段流水线的速度与等功能的非流水线的速度之比</p><p>设 <span class="math inline">\(T_0\)</span> 表示不使用流水线时的执行时间，即顺序执行所用的时间；<span class="math inline">\(T_k\)</span> 表示使用流水线时的执行时间。则计算流水线加速比的基本公式为 <span class="math inline">\(S_p = \frac{T_0}{T_k}\)</span> <span class="math display">\[S_p =\frac{n k \Delta t}{(k+n-1) \Delta t}=\frac{k n}{k+n-1}\]</span> 同样的，最大加速比 <span class="math inline">\(S_{pmax} = \lim_{n \to \infty} S_p = k\)</span>，即流水线的段数</p><h4 id="效率">效率</h4><p>指流水线的设备利用率，由于流水线有建立时间和排空时间，因此各功能段的设备不可能一直处于工作状态，总有一段空闲时间。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%95%88%E7%8E%87%E5%9B%BE.png" alt="image-20220824173826613" style="zoom:80%;" / loading="lazy"></p><p>在时空图上，流水线的效率定义为完成 <span class="math inline">\(n\)</span> 个任务占用的时空区有效面积与 <span class="math inline">\(n\)</span> 个任务所用的时间与 <span class="math inline">\(k\)</span> 个流水段所围成的时空区总面积之比，则效率 <span class="math inline">\(E = \frac{T_0}{k T_k }\)</span> <span class="math display">\[E =\frac{n k \Delta t}{k(k+n-1) \Delta t}=\frac{n}{k+n-1}\]</span></p><p>同样的，最大效率 <span class="math inline">\(E_{max} = \lim_{n \to \infty}E = 1\)</span>，即满效率</p><h3 id="流水线的多发技术">流水线的多发技术</h3><h4 id="超标量技术">超标量技术</h4><p>它是指在每个时钟周期内可同时并发多条独立指令，即以并行操作方式将两条或两条以上指令编译并执行。要实现超标量技术，要求处理机中配置多个功能部件和指令译码电路，以及多个寄存器端口和总线，以便能实现同时执行多个操作，此外还要编译程序决定哪几条相邻指令可并行执行。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%B6%85%E6%A0%87%E9%87%8F%E6%8A%80%E6%9C%AF.png" alt="image-20220824175701402" style="zoom:80%;" / loading="lazy"></p><h4 id="超流水线技术">超流水线技术</h4><p>将一些流水线寄存器插入到流水线段中，好比将流水线再分段。图中将原来的一个时钟周期又分成 3 段，使超流水线的处理器周期比普通流水线的处理器周期短，这样，在原来的时钟周期内，功能部件被使用 3 次，使流水线以 3 倍于原来时钟频率的速度运行。与超标量计算机一样，硬件不能调整指令的执行顺序，靠编译程序解决优化问题。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%B6%85%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF6.png" alt="image-20220824175826030" style="zoom:80%;" / loading="lazy"></p><h4 id="超长指令字技术">超长指令字技术</h4><p>超长指令字（VLIW）技术和超标量技术都是采用多条指令在多个处理部件中并行处理的体系结构，在一个时钟周期内能流出多条指令。但超标量的指令来自同一标准的指令流，VLIW 则是由编译程序在编译时挖掘出指令间潜在的并行性后，把多条能并行操作的指令组合成一条具有多个操作码字段的超长指令（指令字长可达几百位），由这条超长指令控制 VLIW 机中多个独立工作的功能部件，由每一个操作码字段控制一个功能部件，相当于同时执行多条指令。VLIW 较超标量具有更高的并行处理能力，但对优化编译器的要求更高，对 Cache 的容量要求更大。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97%E6%8A%80%E6%9C%AF.png" alt="image-20220824175943831" style="zoom:80%;" / loading="lazy"></p><h2 id="中断系统">中断系统</h2><h3 id="概述">概述</h3><p>从前面分析可知，采用中断方式实现主机与 I/O 交换信息可使 CPU 和 I/O 并行工作，提高 CPU 的效率。其实，计算机在运行过程中，除了会遇到 I/O 中断外，还有许多意外事件发生，如电源突然掉电，机器硬件突然出现故障，人们在机器运行过程中想随机抽查计算的中间结果，实现人机联系等。此外，在实时处理系统中，必须及时处理某个事件或现象，例如，在过程控制系统中，当突然出现温度过高、电压过大等情况时，必须及时将这些信息送至计算机；由计算机暂时中断现行程序，转去执行中断服务程序，以解决这种异常情况。再如，计算机实现多道程序运行时， 可以通过分配给每道程序一个固定时间片，利用时钟定时发中断进行程序切换。在多处理机系统中，各处理器之间的信息交流和任务切换也可通过中断来实现。总之，为了提高计算机的效率，为了处理一些异常情况以及实时控制、多道程序和多处理机的需要，提出了中断的概念。</p><h4 id="引起中断的因素">引起中断的因素</h4><ol type="1"><li><p>人为设置的中断</p><p>这种中断一般称为 <strong>自愿中断</strong>，因为它是在程序中人为设置的，故一旦机器执行这种人为中断，便自愿停止现行程序而转入中断处理。比如 <strong>转管指令</strong>，是转至从 I/O 设备调入一批信息到主存的管理程序，也可能是转至将一批数据送往打印机打印的管理程序。显然，当用户程序执行了“转管指令”后，便中断现行程序，转入管理程序，这种转移完全是自愿的。</p></li><li><p><strong>转管指令</strong></p></li><li><p>程序性事故：溢出、操作码不能识别、除法非法</p></li><li><p>硬件故障：存储器故障、硬盘坏道、掉电</p></li><li><p>I/O 设备</p></li><li><p>外部事件：键盘中断键</p></li></ol><h3 id="中断请求标记和中断判优逻辑">中断请求标记和中断判优逻辑</h3><h4 id="中断请求标记">中断请求标记</h4><p>为了判断是哪个中断源提出请求，在中断系统中必须设置中断请求标记触发器，简称 <strong>中断请求触发器</strong>，记作 INTR。当其状态为“1”时，表示中断源有请求。这种触发器可集中设在 CPU 内， 组成一个中断请求标记寄存器。这些触发器既可以集中在 CPU 的中断系统内，也可以分散到各个中断源中（链式排队器）。</p><h4 id="中断判优逻辑">中断判优逻辑</h4><p>任何一个中断系统，在任一时刻，只能响应一个中断源的请求。但许多中断源提出请求都是随机的，当某一时刻有多个中断源提出中断请求时，中断系统必须按其优先顺序予以响应，这称为中断判优。其可以用 <strong>硬件实现</strong>，也可用 <strong>软件实现</strong></p><p>硬件实现</p><ol type="1"><li><p>分散在各个中断源中的接口电路 <strong>链式排队器</strong></p></li><li><p>集中在 CPU 中</p></li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/CPU%E4%B8%AD%E6%96%AD%E5%88%A4%E4%BC%98.png" alt="image-20220828143507273" style="zoom:80%;" / loading="lazy"></p><p>软件实现</p><ol type="1"><li><p>程序查询</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%AD.png" alt="image-20220828143727207" style="zoom:67%;" / loading="lazy"></p></li></ol><h3 id="中断服务程序地址的寻找">中断服务程序地址的寻找</h3><ol type="1"><li><p>硬件向量法</p><p>硬件向量法就是利用硬件产生 <strong>向量地址</strong>，再由向量地址找到中断服务程序的入口地址。向量地址由 <strong>中断向量地址形成部件</strong> 产生，这个电路可分散设置在各个接口电路中）, 也可设置在 CPU 内。由向量地址寻找中断服务程序的入口地址通常采用两种办法。一种在向量地址内存放一条 <strong>无条件转移指令</strong>，CPU 响应中断时，只要将向量地址送至 PC, 执行这条指令，便可无条件转向服务程序的入口地址。另一种是设置 <strong>向量地址表</strong>，该表设在存储器内，<strong>存储单元的地址为向量地址，存储单元的内容为入口地址</strong>，只要访问向量地址所指示的存储单元，便可获得入口地址。</p></li><li><p>软件查询法</p><p>用软件寻找中断服务程序入口地址的方法称为软件查询法。当查到某一中断源有中断请求时，接着安排一条 <strong>转移指令</strong>，直接指向此中断源的中断服务程序入口地址，机器便能自动进入中断处理。至于各中断源对应的人口地址，则由程序员（或系统）事先确定。这种方法不涉及硬设备，但查询时间较长。计算机可具备软、硬件两种方法寻找入口地址，使用户使用更方便、灵活。</p></li></ol><h3 id="中断响应">中断响应</h3><h4 id="响应中断的条件">响应中断的条件</h4><p>允许中断触发器 <span class="math inline">\(EINT =1\)</span></p><h4 id="响应中断的时间">响应中断的时间</h4><p>CPU 总是在指令执行周期结束后，响应任何中断源的请求。在指令执行周期结束后，CPU 向所有中断源发中断查询信号，CPU 获知哪个中断源有请求。若有中断，CPU 则进入中断周期；若无中断，则进入下一条指令的取指周期。在某些计算机中，有些指令执行时间很长，若 CPU 的查询信号一律安排在执行周期结束时刻，有可能因 CPU 发现中断请求过迟而出差错。为此，可在指令执行过程中设置若干个查询断点，CPU 在每个“查询断点”时刻均发中断查询信号，以便发现有中断请求便可及时响应。</p><h4 id="中断隐指令">中断隐指令</h4><p>CPU 中断后，进入中断周期。在该周期内，CPU 会完成一系列的工作</p><ol type="1"><li><p>保护程序断点</p><p>将当前程序计数器 <span class="math inline">\(PC\)</span> 的内容保存到存储器中的特定单元(0 号地址)内，也可以存入堆栈</p></li><li><p>寻找中断服务程序的入口地址</p><p>可以使用 <strong>硬件向量法</strong> 或者 <strong>程序查询法</strong> 得到入口地址，将入口地址送至 <span class="math inline">\(PC\)</span>。然后硬件向量法使用无条件转移指令，程序查询法 CPU 执行中断识别程序</p></li><li><p>关中断</p><p>CPU 进入中断周期，意味着 CPU 响应了某个中断源的请求，为了确保 CPU 响应后所需做的一系列操作不至于又受到新的中断请求的干扰，在中断周期内必须自动关中断，以禁止 CPU 再次响应新的中断请求。</p></li></ol><h3 id="中断屏蔽技术">中断屏蔽技术</h3><p>当 CPU 正在执行某个中断服务程序时，另一个中断源又提出了新的中断请求，而 CPU 又应了这个新的请求，暂时停止正在运行的服务程序，转去执行新的中断服务程序，这称为多重中断，又称中断嵌套，如果 CPU 对新的请求不予响应，待执行完当前的服务程后再响应，即为单重中断。中断系统若要具有处理多重中断的功能，必须具备各项条件。</p><h4 id="实现多重中断的条件">实现多重中断的条件</h4><ol type="1"><li>提前设置开中断指令</li><li>优先级高的中断源有权中断优先级别低的中断源</li></ol><h4 id="屏蔽技术">屏蔽技术</h4><ol type="1"><li>屏蔽触发器与屏蔽字</li><li>屏蔽技术可改变优先等级 严格地说，优先级包含响应优先级和处理优先级。响应优先级是指 CPU 响应各中断源请求的优先次序，这种次序往往是硬件线路已设置好的，不便于改动。处理优先级是指 CPU 实际对各中断源请求的处理优先次序。如果不采用屏蔽技术，响应的优先次序就是处理的优先次序。采用了屏蔽技术后，可以改变 CPU 处理各中断源的优先等级，从而改变 CPU 执行程序的轨迹。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;开学了！G！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/chao.jpg&quot; alt=&quot;100750654_p0_master1200&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（七）</title>
    <link href="http://lapras.xyz/2022/08/21/4904199e.html"/>
    <id>http://lapras.xyz/2022/08/21/4904199e.html</id>
    <published>2022-08-21T07:24:16.820Z</published>
    <updated>2022-08-21T07:24:34.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本章主要介绍机器指令系统的分类、常见的寻址方式、指令格式以及设计指令系统时应考虑的各种因素。黑神话新实机演示真不错</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%BB%91%E8%9B%87%E9%98%BF%E6%96%AF%E9%A1%BF%E9%98%BF%E4%B8%89.jpeg" alt="20220820204111" style="zoom: 40%;" / loading="lazy"></p><span id="more"></span><h2 id="机器指令">机器指令</h2><p>指令是指示计算机执行某种操作的命令，<strong>是计算机运行的最小功能单位</strong>。一台计算机的所有指令的集合构成该机的指令系统，也称为 <strong>指令集</strong>。</p><h3 id="指令的一般格式">指令的一般格式</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="image-20220813150549742" style="zoom:80%;" / loading="lazy"></p><p>操作码：用来指明该指令所要完成的操作，如加法、减法、传送、移位、转移等。其位数往往反映了机器的操作种类，即机器允许的指令条数，如操作码占 7 位，则该机器最多包含 <span class="math inline">\(2^7 = 128\)</span> 条指令。</p><p>操作码的长度 <strong>可以是固定的，也可以是变化的</strong>。前者将 <strong>操作码集中放在指令字的一个字段内</strong>，这种格式便于硬件设计，指令译码时间短。对于操作码长度不固定的指令，其 <strong>操作码分散在指令字的不同字段</strong> 中。这种格式可有效地压缩操作码的平均长度。但会增加指令译码和分析的难度，使控制器的设计复杂。通常采用 <strong>扩展操作码技术</strong>，使操作码的长度随地址数的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。</p><h3 id="按地址码数目分类">按地址码数目分类</h3><h4 id="零地址指令">零地址指令</h4><p>顾名思义，只有操作码而无地址码的指令</p><ol type="1"><li>不需要操作数，如空操伤、停机、关中断等指令</li><li>堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶（类似后缀表达式）</li></ol><h4 id="一地址指令">一地址指令</h4><ol type="1"><li><p>只需要单操作数，如加 1、减 1、取反、求补等</p><p>指令含义： <span class="math inline">\(OP(A_1)\to A_1\)</span> ,</p></li><li><p>需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在 <strong>ACC</strong> )</p><p>指令含义： <span class="math inline">\((ACC)OP(A_1)\to ACC\)</span></p><p>注： <span class="math inline">\(A_1\)</span> 指某个主存地址， <span class="math inline">\((A_1)\)</span> 表示 <span class="math inline">\(A_1\)</span> 所指向的地址中的内容</p></li></ol><h4 id="二地址指令">二地址指令</h4><ol type="1"><li><p>需要两个操作数的算术运算、逻辑运算相关指令</p><p>指令含义： <span class="math inline">\((A_1)OP(A_2)\to A_1\)</span> 或 <span class="math inline">\((A_1)OP(A_2)\to A_2\)</span></p></li></ol><h4 id="三地址指令">三地址指令</h4><ol type="1"><li><p>需要三个操作数的算术运算、逻辑运算相关指令</p><p>指令含义： <span class="math inline">\((A_1)OP(A_2)\to A_3\)</span></p></li></ol><h4 id="四地址指令">四地址指令</h4><ol type="1"><li><p>需要三个操作数的算术运算、逻辑运算相关指令，且指定下一个要执行的指令</p><p>指令含义： <span class="math inline">\((A_1)OP(A_2)\to A_3\)</span> ， <span class="math inline">\(A_4\)</span> 为下一条将要执行指令的地址 正常情况下：取指令之后程序计数器 <span class="math inline">\(PC+1\)</span> ，指向下一条指令 四地址指令：执行指令后，将 <strong>PC</strong> 的值修改为 <span class="math inline">\(A_4\)</span> 所指地址</p></li></ol><blockquote><p>地址码的位数决定了该指令的 <strong>直接寻址范围</strong>，比如 <span class="math inline">\(n\)</span> 位地址码的直接寻址范围为 <span class="math inline">\(2^n\)</span> 。</p><p>若指令总长度固定不变，则地址码数目越多，每个地址码的位数就越少，寻址能力越差</p></blockquote><p>假设给定指令字长为 32 位，操作码为定长操作码 8 位。则不同地址码数目区别如下：</p><table><thead><tr class="header"><th>地址码</th><th>访存次数</th><th>寻址范围</th></tr></thead><tbody><tr class="odd"><td>零地址</td><td>1</td><td>无地址码</td></tr><tr class="even"><td>一地址</td><td>3（结果存于 ACC 则为 2）</td><td><span class="math inline">\(2^{24}\)</span></td></tr><tr class="odd"><td>二地址</td><td>4（结果存于 ACC 则为 3）</td><td><span class="math inline">\(2^{12}\)</span></td></tr><tr class="even"><td>三地址</td><td>4</td><td><span class="math inline">\(2^8\)</span></td></tr><tr class="odd"><td>四地址</td><td>4</td><td><span class="math inline">\(2^6\)</span></td></tr></tbody></table><h3 id="按指令长度分类">按指令长度分类</h3><blockquote><p>指令字长：一条指令的总长度（可能会变）</p><p>机器字长：CPU 进行一次整数运算所能处理的二进制数据的位数（通常和 ALU 直接相关）</p><p>存储字长：一个存储单元中的二进制代码位数（通常和 MDR 位数相同）</p></blockquote><p>显然指令字长取决于：</p><ol type="1"><li>操作码的长度</li><li>操作数地址个数</li><li>操作数地址长度</li></ol><ul><li>定长指令字结构：指令系统中所有指令的长度都相等，即 <strong>指令字长等于存储字长</strong></li><li>变长指令字结构：指令系统中各种指令的长度不等，指令长度是机器字长的若干倍：半字长指令、单字长指令、双字长指令</li></ul><h3 id="按操作码长度分类">按操作码长度分类</h3><ul><li><p>定长操作码：指令系统中所有指令的操作码长度都相同</p><p>如果操作码固定为 <span class="math inline">\(n\)</span> 位，则该系统最多支持 <span class="math inline">\(2^n\)</span> 条指令</p></li><li><p>可变长操作码：指令系统中各指令的操作码长度可变</p><p>通过扩展操作码指令格式实现</p></li></ul><h3 id="扩展操作码技术">扩展操作码技术</h3><p><strong>定长指令字结构+可变长操作码</strong>。对于不同地址数量的指令使用长度不同的操作码</p><h4 id="保留码点法">保留码点法</h4><p>先假设指令字长为 16 位，每个地址码占 4 位。前 4 位为基础操作码 <span class="math inline">\(OP\)</span> ，令有 3 个四位长的地址字段 <span class="math inline">\(A_1\quad A_2 \quad A_3\)</span></p><p>若 4 位基本操作码若全部用于三地址指令，则有 16 条。但至少须将 1111 留作扩展操作码之用，即三地址指令为 15 条；同理，将 1111 1111 留作扩展操作码只用，即二地址指令为 15 条；同理，一地址指令和零地址指令也为 15 条</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%BF%9D%E7%95%99%E9%A9%AC%E5%BA%97.png" alt="image-20220813153608821" style="zoom:80%;" / loading="lazy"></p><p>在设计扩展操作码时，要注意以下两点：</p><ol type="1"><li>不允许短码是长码的前缀（对比哈夫曼编码），即不允许短操作码与长操作码的前面部分相同</li><li>各指令的操作码不能重复</li></ol><p>通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。</p><ul><li>不难发现，对于地址码长度为 <span class="math inline">\(n\)</span> 的指令来说，上一层留出 <span class="math inline">\(m\)</span> 种状态，下一层可以扩展出至多 <span class="math inline">\(m \times 2^n\)</span> 种状态</li></ul><h2 id="操作数类型和操作类型">操作数类型和操作类型</h2><h3 id="操作数类型">操作数类型</h3><p>机器中常见的操作数类型有地址、数字、字符、逻辑数据等</p><ol type="1"><li>地址：地址实际上也可看做是一种数据，在许多情况下要计算操作数的地址。如果是绝对地址，则可被认为 是一个无符号整数；如果是相对地址，则可被认为是一个有符号整数</li><li>数字：定点数，浮点数和十进制数</li><li>字符：ASCII，BCD</li><li>逻辑数：逻辑运算</li></ol><h3 id="数据在存储器中的存放方式">数据在存储器中的存放方式</h3><h4 id="存放次序">存放次序</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF.png" alt="image-20220816172411987" style="zoom:80%;" / loading="lazy"></p><p>这两种字节次序分别为：高字节为大端方式，低字节为小端方式</p><h4 id="存放方式">存放方式</h4><p>以下图所示的存储器存储字长为 64 位，可按字节、半字、字、双字访问。由于不同的机器数据字长不同，每台机器处理的数据字长也不统一，例如奔腾处理器可处理 8（字节）、16（字）、32（双字）、64（四字）；PowerPC 可处理 8（字节）、16（半字）、32（字）、64（双字）。</p><ol type="1"><li><p>从任意位置开始</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E5%AD%98%E6%94%BE.png" alt="image-20220816230817830" style="zoom:80%;" / loading="lazy"></p><p>优点：不浪费存储资源 缺点：除了访问一个字节之外，访问其它任何类型的数据，都可能花费两个存储周期的时间。读写控制比较复杂。</p></li><li><p>从一个存储字的起始位置开始</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E5%AD%97%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%BD%AE%E5%BC%80%E5%A7%8B8.png" alt="image-20220816230928672" style="zoom:80%;" / loading="lazy"></p><p>优点：无论访问何种类型的数据，在一个周期内均可完成，读写控制简单。 缺点：浪费了宝贵的存储资源</p></li><li><p><strong>边界对准方式</strong>：从地址的整数倍位置开始访问</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%BE%B9%E7%95%8C%E5%AF%B9%E5%87%86%E6%96%B9%E5%BC%8F.png" alt="image-20220816231046351" style="zoom:80%;" / loading="lazy"></p><p>在对准边界的 64 位字长的计算机中，半字地址是 2 的整数倍，字地址是 4 的整数倍，双字地址是 8 的整数倍。当所存数据不能满足此要求时，可填充一个至多个空白字节。</p><p>本方案是前两个方案的折衷，在一个周期内可以完成存储访问，空间浪费也不太严重。</p></li></ol><h3 id="操作类型">操作类型</h3><ol type="1"><li><p>数据传送</p><p>LOAD：把存储器中的数据放到寄存器中 STORE：把寄存器中的数据放到存储器中</p></li><li><p>算逻操作</p><p>算术：加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算 逻辑：与、或、非、异或、位操作、位测试、位清除、位求反</p></li><li><p>移位操作</p></li></ol><p>算术移位、逻辑移位、循环移位（带进位和不带进位）</p><ol start="4" type="1"><li><p>转移操作 无条件转移、条件转移、调用和返回 、陷阱与陷阱指令</p></li><li><p>输入输出操作</p><p>CPU 寄存器与 IO 端口支间的数据传送（端口即 IO 接口中的寄存器）</p></li></ol><h2 id="寻址方式">寻址方式</h2><p>寻址方式是指确定本条指令的数据地址以及下一条将要执行的指令地址的方法，它与硬件结构紧密相关，而且直接影响指令格式和指令功能。寻址方式分为指令寻址和数据寻址两大类。</p><h3 id="指令寻址">指令寻址</h3><p>顺序寻址：取完一条指令后，顺序地读取下一条指令。而指令的地址保存在 <span class="math inline">\(PC\)</span> 当中。</p><p><span class="math inline">\((PC)+1 \to PC\)</span></p><ul><li>这里的 1 并非是数字 1 ，而是根据编址方式调整的，表示一个指令字长。</li></ul><p>跳跃寻址：跳跃寻址通过转移类指令实现，比如 JMP</p><h3 id="数据寻址">数据寻址</h3><p>数据寻址方式种类较多，在指令字中必须设一字段来 <strong>指明属于哪一种寻址方式</strong>。指令的地址码字段通常都不代表操作数的真实地址，把它称为 <strong>形式地址</strong>，记作 A 。操作数的真实地址称为 <strong>有效地址</strong>，记作 EA , 它是由寻址方式和形式地址共同来确定的。由此可得指令的格式应如：</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%A0%BC%E5%BC%8F.png" alt="image-20220818215214674" style="zoom:80%;" / loading="lazy"></p><p>以下寻址方式介绍，基于 <strong>指令字长 = 存储字长 = 机器字长</strong> 的假设前提</p><h3 id="立即寻址">立即寻址</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80.png" alt="image-20220818220734432" style="zoom:80%;" / loading="lazy"></p><ul><li>形式地址 A 存放的不是地址，而是操作数本身，被称为 <strong>立即数</strong>，采用 <strong>补码形式存放</strong></li><li><span class="math inline">\(\#\)</span> 是立即寻址的特征标记</li><li>优点：只要取出指令，便可立即获得操作数，这种指令在执行阶段 <strong>不必再访问存储器</strong></li><li>缺点：显然 A 的位数限制了这类指令所能表述的立即数的范围</li></ul><h3 id="直接寻址">直接寻址</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818222404551" style="zoom:80%;" / loading="lazy"></p><ul><li>有效地址 EA = 形式地址 A，有效地址由形式地址给出</li><li>优点：寻找操作数比较简单，也不需要专门计算操作数的地址，在指令执行阶段 <strong>对主存只访问一次</strong></li><li>缺点：A 的位数限制了操作数的寻址范围，而且必须修改 A 的值，才能修改操作数的地址。</li></ul><h3 id="隐含寻址">隐含寻址</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818223757476" style="zoom:80%;" / loading="lazy"></p><ul><li>指令字中不直接地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中</li><li>优点：由于隐含寻址在指令字中少了一个地址。因此，这种寻址方式的指令有利于缩短指令字长</li></ul><h3 id="间接寻址">间接寻址</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818225251882" style="zoom:80%;" / loading="lazy"></p><ul><li>指令字中的形式地址不直接指出操作数的地址，而是指出操作数有效地址所在的存储单元地址</li><li>间接寻址，可以进行若干次。</li><li>优点：可扩大寻址范围（比如用存储字的首位表示是否要继续间址）；便于编写程序</li><li>缺点：程序执行阶段进行最少两次（一次间址）的访存，运行较慢</li></ul><h3 id="寄存器直接寻址">寄存器（直接）寻址</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818230609269" style="zoom:80%;" / loading="lazy"></p><ul><li>指令字中，地址码字段直接指出了寄存器的编号，即 <span class="math inline">\(EA = R_i\)</span></li><li>优点：操作数不在主存中，而在寄存器中。所以访存次数为 0；地址字段只需指明寄存器的编号（寄存器个数非常有限），故指令字长度较短。</li></ul><h3 id="寄存器间接寻址">寄存器间接寻址</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818231120511" style="zoom:80%;" / loading="lazy"></p><ul><li>有效地址保存在寄存器当中，操作数保存在存储器中。即 <span class="math inline">\(EA = (R_i)\)</span></li><li>优点：便于循环程序的编写</li><li>缺点：需要访问一次主存，但比间接寻址少访问一次</li></ul><h3 id="基址寻址">基址寻址</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="image-20220818231546155" style="zoom:80%;" / loading="lazy"></p><ul><li><strong>隐式基址寻址</strong> 需设有基址寄存器 <span class="math inline">\(BR\)</span> ，使用时用户无需特意指出。</li></ul><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9F%BA%E5%80%BC%E5%AF%BB%E5%9D%80%E9%99%90%E6%97%B6.png" alt="image-20220818232654260" style="zoom:80%;" / loading="lazy"></p><ul><li><p><strong>显式基址寻址</strong> 是在一组通用寄存器里，由用户明确指出哪个寄存器用做基址寄存器 <span class="math inline">\(R_0\)</span> ，存放基地址。</p></li><li><p>其操作数的有效地址 <span class="math inline">\(EA\)</span> 等于指令字中的形式地址与基址寄存器中的内容（称为基地址）相加，即 <span class="math inline">\(EA = (BR) +A\)</span></p></li><li><p>优点：扩大寻址范围；有利于多道程序设计，因为用户可不必考虑自己的程序存于主存的哪一空间区域，完全可由操作系统或管理程序根据主存的使用状况，赋予基址寄存器内一个初始值（即基地址）, 便可将用户程序的逻辑地址转化为主存的物理地址（实际地址）。</p></li><li><p>注意：指令执行过程中，<strong>BR</strong> 的内容不允许修改，只能修改 <span class="math inline">\(A\)</span> 的内容</p></li></ul><h3 id="变址寻址">变址寻址</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="image-20220818232957427" style="zoom:80%;" / loading="lazy"></p><ul><li>变址寻址与基址寻址极为相似。 <span class="math inline">\(IX\)</span> 为变址寄存器（专用），通用寄存器也可以作为变址寄存器。其有效地址 <span class="math inline">\(EA = (IX)+A\)</span></li><li>优点：扩大寻址范围；有利于处理数组问题，可设定 <span class="math inline">\(A\)</span> 为数组的首地址，不断改变变址寄存器 <span class="math inline">\(IX\)</span> 的内 容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。</li><li>注意：指令执行过程中，<strong>A</strong> 的内容不允许修改，只能修改 <span class="math inline">\(IX\)</span> 的内容</li></ul><h3 id="相对寻址">相对寻址</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.png" alt="image-20220819170029022" style="zoom:80%;" / loading="lazy"></p><ul><li>相对寻址的有效地址是将程序计数器 <span class="math inline">\(PC\)</span> 的内容（即当前指令的地址）与指令字中的形式地址 <span class="math inline">\(A\)</span> 相加而成，即 <span class="math inline">\(EA = (PC)+A\)</span></li><li><span class="math inline">\(A\)</span> 是相对于当前指令的位移量，可正可负，用补码表示。又称位移量</li><li>倘若位移量为 8 位，则指令的寻址范围在 <span class="math inline">\([(PC)-128, (PC)+127]\)</span> 之间。相对寻址的最大特点是转移地址不固定，它可随 <span class="math inline">\(PC\)</span> 值的变化而变，因此，无论程序在主存的哪段区域，都可正确运行，对于编写浮动程序特别有利。</li></ul><h3 id="堆栈寻址">堆栈寻址</h3><p>堆栈寻址要求计算机中设有 <strong>堆栈</strong>。堆栈既可用寄存器组（称为 <strong>硬堆栈</strong>）来实现，也可利用主存的一部分空间作堆栈（称为 <strong>软堆栈</strong>）。先进后出型堆栈的操作数只能从一个口进行读或写。以软堆栈为例，可用堆栈指针 SP（Stack Point）指出栈顶地址，也可用 CPU 中一个或两个寄存器作为 <span class="math inline">\(SP\)</span> 。操作数只能从栈顶地址指示的存储单元存或取。可见堆栈寻址也可视为一种隐含寻址，其操作数的地址总被隐含在 <span class="math inline">\(SP\)</span> 中。堆栈寻址其本质也可视为寄存器间接寻址，因 <span class="math inline">\(SP\)</span> 可视为寄存器，它存放着操作数的有效地址。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80.png" alt="image-20220819171018635" style="zoom:80%;" / loading="lazy"></p><ul><li>同样的，这里的 1 要根据编址方式确定，若按照字编址，则为 1。若按照字节编址，则根据存储字长决定，比如 32 位为 4 个字节</li></ul><h2 id="cisc-和-risc">CISC 和 RISC</h2><h3 id="cisc">CISC</h3><p>Complex Instruction Set Computer</p><p>设计思路：一条指令完成一个复杂的操作</p><p>代表：x86 架构</p><h3 id="risc">RISC</h3><p>Reduced Instruction Set Computer</p><p>设计思路：一条指令完成一个基本操作，多条指令组合完成一个复杂操作</p><p>代表：ARM 架构</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/RISCandCise.png" alt="image-20220820202440113" style="zoom:80%;" / loading="lazy"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本章主要介绍机器指令系统的分类、常见的寻址方式、指令格式以及设计指令系统时应考虑的各种因素。黑神话新实机演示真不错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%BB%91%E8%9B%87%E9%98%BF%E6%96%AF%E9%A1%BF%E9%98%BF%E4%B8%89.jpeg&quot; alt=&quot;20220820204111&quot; style=&quot;zoom: 40%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（六）</title>
    <link href="http://lapras.xyz/2022/08/08/9b046e01.html"/>
    <id>http://lapras.xyz/2022/08/08/9b046e01.html</id>
    <published>2022-08-08T15:53:07.000Z</published>
    <updated>2022-08-21T07:25:30.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>绝区零好潮。。。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220808231206.jpeg" alt="img" style="zoom:80%;" / loading="lazy"></p><span id="more"></span><h2 id="无符号数和有符号数">无符号数和有符号数</h2><h3 id="无符号数">无符号数</h3><p>计算机中的数均放在 <strong>寄存器</strong> 中，通常称寄存器的位数为 <strong>机器字长</strong>。<strong>所谓无符号数，即没有符号的数</strong>，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的。比如用一个八位的寄存器保存无符号数，则可以表示 0~255。</p><h3 id="有符号数">有符号数</h3><h4 id="机器数与真值">机器数与真值</h4><p>因为计算机没有办法直接识别正负号，所以需要将正负号转化为数字来存储。保存在计算机中将正负号“数字化”之后的数称为 <strong>机器数</strong>，而 <strong>真值</strong> 是我们日常生活中包含了正负号的数值。注意：以下内容默认都为 2 进制数</p><h4 id="原码表示法">原码表示法</h4><p>原码是机器数中最简单的一种表示形式，符号位为 0 表示正数，符号位为 1 表示负数，<strong>数值位即真值的绝对值</strong>，故原码表示又称为带符号的绝对值表示。为了书写方便以及区别整数和小数，约定整数的符号位与数值位之间用逗号隔开；小数的符号位与数值位之间用小数点隔开。由此可得原码的定义： <span class="math display">\[[x]_{\text {原}}=\left\{\begin{array}{cc}0, \ x &amp; 2^{n}&gt; x \geqslant 0 \\2^{n}-x &amp; 0 \geqslant x &gt; -2^{n}\end{array}\right.\]</span> 例如，当 <span class="math inline">\(x = -1110\)</span> 时， <span class="math inline">\([x]_{\text {原}} = 2^4 - (-1110) = 1,1110\)</span></p><p>对于小数部分： <span class="math display">\[[x]_{\text {原 }}=\left\{\begin{array}{cc}x &amp; 1 &gt; x \geqslant 0 \\1-x &amp; 0 \geqslant x &gt;-1\end{array}\right.\]</span> 例如，当 <span class="math inline">\(x = +0.1101\)</span> 时， <span class="math inline">\([x]_{\text {原}} = 0.1101\)</span> ，注意这里两个 <span class="math inline">\(0.\)</span> 的含义不同，后者表示正数+区分符</p><ul><li><p>不难发现，对于 <span class="math inline">\(0\)</span> 而言， <span class="math inline">\([+0000] _{\text {原}} = 0,0000 ;\ [-0000]_{\text {原}} = 1,0000\)</span> ，两者并不相同</p></li><li><p>原码特点：简单且直观，但运算复杂。当两个操作数符号不同且要作加法运算时，先要判断两数绝对值大小，然后将绝对值大的数减去绝对值小的数，结果的符号以绝对值大的数为准。而且用到的是减法器实现。</p></li></ul><h4 id="补码表示法">补码表示法</h4><p>为了解决原码在计算中的问题，即用一个与负数等价的正数表示负数，使得运算中只需要加法器。</p><p>所谓补数，就是其本身加上 <strong>模</strong>。正数的补数是其自身，负数的补数是其本身加上模，当一个正数和一个负数互为补数的时候，其绝对值之和为模数。那么对于 2 进制数而言，模就是 <span class="math inline">\(2^n\)</span> ，但是为了能表示正负，即负数的首位为 1，选择将模设置为 <span class="math inline">\(2^{n+1}\)</span> 。 <span class="math display">\[[x]_{\text {补 }}= \begin{cases}0,\ x &amp; 2^{n}&gt; x \geqslant 0 \\ 2^{n+1}+x &amp; 0 &gt; x \geqslant-2^{n} \quad\left(\bmod 2^{n+1}\right)\end{cases}\]</span> 例如， <span class="math inline">\(x = -1011000\)</span> ，则 <span class="math inline">\([x]_{\text{补}} = 2^{7+1} + (-1011000) = 1,0101000\)</span></p><p>小数： <span class="math display">\[[x]_{\text {补 }}= \begin{cases}x &amp; 1 &gt; x \geqslant 0 \\ 2+x &amp; 0 &gt; x \geqslant-1 \quad(\bmod 2)\end{cases}\]</span></p><p>例如， <span class="math inline">\(x = -0.1100000\)</span> ，则 <span class="math inline">\([x]_{\text{补}} = 2+(-0.1100000) = 1.0100000\)</span></p><ul><li>我们也可以通过口诀“<strong>原码取反（变为反码）再加 1</strong>”快速计算一个数的补码</li><li>不难发现，对于 <span class="math inline">\(0\)</span> 而言， <span class="math inline">\([+0000] _{\text {补}} = 0,0000 ;\ [-0000]_{\text {补}} = 2^{4+1} - 0000 = 100000 -0000 = 0,0000\)</span> ，最高位溢出舍去，所以补码的 0 表现形式是一致的</li></ul><h4 id="反码表示法">反码表示法</h4><p>反码通常用来作为由原码求补码或者由补码求原码的中间过渡。反码的定义如下： <span class="math display">\[[x]_{\text {反 }}=\left\{\begin{array}{ll}0,\  x &amp; 2^{n}&gt; x \geqslant 0 \\\left(2^{n+1}-1\right)+x &amp; 0 \geqslant x &gt;-2^{n}\left(\bmod 2^{n+1}-1\right)\end{array}\right.\]</span> 小数： <span class="math display">\[[x]_{\text {反 }}= \begin{cases}x &amp; 1 &gt; x \geqslant 0 \\ \left(2-2^{-n}\right)+x &amp; 0 \geqslant x &gt;-1 \quad\left(\bmod \left(2-2^{-n}\right)\right)\end{cases}\]</span> 例如， <span class="math inline">\(x = -0.1010\)</span> ，则 <span class="math display">\[\begin{align*}[x]_{\text{反}} &amp;= (2 - 2 ^{-4}) + (-0.1010)) \\&amp;= (10 - 0.0001) -0.1010 \\&amp;= 1.1111 - 0.1010 \\&amp;= 1.0101 \end{align*}\]</span></p><ul><li>简而言之为，符号位不变，正数不变，负数取反</li><li>不难发现，对于 <span class="math inline">\(0\)</span> 而言， <span class="math inline">\([+0000] _{\text {反}} = 0,0000 ;\ [-0000]_{\text {反}} = 2^{4+1}-1 - 0000 = 11111 - 0000 = 1,1111\)</span> ，两者并不一致。</li></ul><h4 id="小结">小结</h4><ol type="1"><li>最高位为符号位，书写上用“,”或“.”将数值部分与符号位分隔开</li><li>对于正数，原码 = 反码 = 补码</li><li>对于负数，符号位为 1。其数值部分原码取反得反码，反码加 1 得补码</li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8E%9F%E5%8F%8D%E8%A1%A5%E5%B0%8F%E7%BB%93.png" alt="image-20220726222748948" style="zoom:80%;" / loading="lazy"></p><h4 id="移码表示法">移码表示法</h4><p>补码虽然计算机计算方便，但是人类和机器并不能直观地判断大小。所以选择加上 <span class="math inline">\(2^n\)</span> ，（这里的 <span class="math inline">\(n\)</span> 同样是不包含符号位的）。因此得到移码的定义 <span class="math display">\[[x]_{\text {移 }}= 2^{n}+x\left(2^{n}&gt; x \geqslant-2^{n}\right)\]</span> 例如， <span class="math display">\[\begin{aligned}&amp;{[+0]_{\text {移 }}= 2^{5}+0 = 1,00000} \\&amp;{[-0]_{\text {移 }}= 2^{5}-0 = 1,00000}\end{aligned}\]</span></p><ul><li>可见在移码中 0 的表示唯一。</li><li>移码只有整数形式的定义，而无小数定义。因为移码在数据表示中负责浮点数的 <strong>阶码</strong> 部分，其只有整数。</li><li>最小值为全 0，最大值为全 1，非常直观</li><li><strong>同一真值的移码和补码只有符号位不同</strong></li></ul><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A7%BB%E7%A0%81%E6%AF%94%E8%BE%83.png" alt="image-20220726224410850" style="zoom:80%;" / loading="lazy"></p><h2 id="数的定点表示和浮点表示">数的定点表示和浮点表示</h2><p>在计算机中，小数点 <strong>不用专门的器件表示，而是按约定的方式标出</strong>，共有两种方法表示小数点的存在，即 <strong>定点表示</strong> 和 <strong>浮点表示</strong>。定点表示的数称为定点数，浮点表示的数称为浮点数。</p><h3 id="定点表示">定点表示</h3><p>所谓定点表示，即小数点固定在某一位置。其有两种形式，分别是小数点在数符（正负号）后，和小数点在数值后。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA.png" alt="image-20220727145024898" style="zoom:80%;" / loading="lazy"></p><ul><li>根据机器选择的小数点位置的不同，分为 <strong>小数定点机</strong> 和 <strong>整数定点机</strong></li></ul><table><thead><tr class="header"><th>定点机</th><th>小数定点机</th><th>整数定点机</th></tr></thead><tbody><tr class="odd"><td>原码</td><td><span class="math inline">\([-(1-2^{-n}),+(1-2^{-n})]\)</span></td><td><span class="math inline">\([-(2^n-1),+(2^n-1)]\)</span></td></tr><tr class="even"><td>补码</td><td><span class="math inline">\([-1,+(1-2^{-n})]\)</span></td><td><span class="math inline">\([-2^n,+(2^n-1)]\)</span></td></tr><tr class="odd"><td>反码</td><td><span class="math inline">\([-(1-2^{-n}),+(1-2^{-n})]\)</span></td><td><span class="math inline">\([-(2^n-1),+(2^n-1)]\)</span></td></tr></tbody></table><ul><li>不难发现，原码的范围与反码表示的范围一致，这也与上一篇的结论相符合。而补码的最小值会发生改变，也与上篇相符。</li></ul><h3 id="浮点表示">浮点表示</h3><p>实际上计算机中处理的数不一定是纯小数或纯整数（如圆周率），而且有些数据的数值范围相差很大，它们都不能直接用定点小数或定点整数表示，除非疯狂加长机器字长，这显然是不现实的。但其均可用浮点数表示。<strong>浮点数即小数点的位置可以浮动的数</strong>，比如： <span class="math display">\[\begin{aligned}352.47 &amp;= 3.5247 \times 10^{2} \\&amp;= 3524.7 \times 10^{-1} \\&amp;= 0.35247 \times 10^{3}\end{aligned}\]</span> 其实就类似我们学过的科学计数法，其一般形式为 <span class="math inline">\(N = S \times r^j\)</span> ，其中 <span class="math inline">\(S\)</span> 称为 <strong>尾数</strong>， <span class="math inline">\(j\)</span> 称为 <strong>阶码</strong>， <span class="math inline">\(r\)</span> 称为 <strong>基值</strong>。</p><ul><li>尾数 <span class="math inline">\(S\)</span> 的绝对值小于等于 1，为小数</li><li>阶码 <span class="math inline">\(j\)</span> 为整数</li><li>基值 <span class="math inline">\(r\)</span> 在计算机中一般取 2 的次幂</li></ul><p>当 <span class="math inline">\(r = 2\)</span> 时，举个例子： <span class="math display">\[\begin{aligned}N &amp;= 11.0101 \\&amp;= 0.110101 \times 2^{10} \\&amp;= 1.10101 \times 2^{1} \\&amp;= 1101.01 \times 2^{-10} \\&amp;= 0.00110101 \times 2^{100}\end{aligned}\]</span></p><ul><li>注意，这里的阶码同样为 2 进制。</li><li>注意，尾数的绝对值限制</li><li>将尾数最高位为 1 的数称为 <strong>规格化数</strong>，此时精度最高</li></ul><h4 id="浮点数的表现形式">浮点数的表现形式</h4><p>在设计计算机的过程中，如果事先约定好了基值 <span class="math inline">\(r\)</span> ，那么存储浮点数只需要记录另外两个数值即可：</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BD%A2%E5%BC%8F.png" alt="image-20220727152107973" style="zoom:80%;" / loading="lazy"></p><ul><li><span class="math inline">\(j_f\)</span> 和 <span class="math inline">\(S_f\)</span> 表示正负</li><li><span class="math inline">\(n\)</span> ，尾数位数，即反映浮点数精度</li><li><span class="math inline">\(m\)</span> ，阶码位数，即反映浮点数范围</li></ul><h4 id="浮点数的表示范围">浮点数的表示范围</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E8%8C%83%E5%9B%B41.png" alt="image-20220727153145219" style="zoom:80%;" / loading="lazy"></p><ul><li>上溢：阶码大于最大阶码，则报错进行中断溢出处理</li><li>下溢：阶码小于最小阶码，则按照机器 0 处理</li></ul><h4 id="浮点数的规格化">浮点数的规格化</h4><p>规格化形式与 <span class="math inline">\(r\)</span> 的取值有直接联系，当 <span class="math inline">\(r = 2\)</span> 时，要求首位为 1，当 <span class="math inline">\(r = 4\)</span> 时，要求首两位不全为 0。</p><p><strong>事实上，可以总结出当 <span class="math inline">\(r = 2^i\)</span> 时，要求首 <span class="math inline">\(i\)</span> 位不全为 0</strong>，推广到其他码制：</p><table><thead><tr class="header"><th>码制</th><th>S &gt; 0 规格化形式</th><th>S &lt; 0 规格化形式</th></tr></thead><tbody><tr class="odd"><td>真值</td><td>0.1XXX</td><td>-0.1XXX</td></tr><tr class="even"><td>原码</td><td>0.1XXX</td><td>1.1XXX</td></tr><tr class="odd"><td>补码</td><td>1.0XXX</td><td>1.0XXX</td></tr><tr class="even"><td>反码</td><td>0.1XXX</td><td>1.0XXX</td></tr></tbody></table><ul><li><strong>原码：无论正负首位都为 1</strong></li><li><strong>补码：符号位与首位不同</strong>，有特例 <span class="math inline">\([-\frac{1}{2}] _\text{补}= 1.100\)</span> 不是规格化数， <span class="math inline">\([-1]_\text{补} = 1.000\)</span> 是规格化数</li></ul><p>很容易想到，通过左移右移就可以使得浮点数规格化。这被称为 <strong>左规右规</strong>，但是要注意基值 <span class="math inline">\(r\)</span> 对于阶码的影响。</p><p>比如 <span class="math inline">\(r = 4\)</span> ，左规 2 位，尾数左移 2 位，阶码减 1。此时就不能左规 3 位，因为要保证阶码为整数。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E4%BE%8B%E5%AD%90.png" alt="image-20220727160349750" style="zoom:80%;" / loading="lazy"></p><ul><li>值得注意的是，当一个浮点数尾数为 0 时，不论其阶码为何值；或阶码等于或小于它所能表 示的最小数时，不管其尾数为何值，机器都把该浮点数作为零看待，并称之为“机器零”。</li></ul><h3 id="定点数和浮点数的比较">定点数和浮点数的比较</h3><ol type="1"><li><p>当浮点机和定点机中，数的位数相同时，浮点数的表示范围比定点数的大得多。</p></li><li><p>当浮点数为规格化数时，其相对精度远比定点数高。</p></li><li><p>浮点数运算要分阶码部分和尾数部分，而且运算结果都要求规格化，故浮点运算步骤比定点运算步骤多，运算速度比定点运算的低，运算线路比定点运算的复杂。</p></li><li><p>在溢出的判断方法上，浮点数是对规格化数的阶码进行判断，而定点数是对数值本身进行判断。</p></li><li><p>总之，浮点数在数的表示范围、数的精度、溢出处理和程序编程方面（不取比例因子）均优于定点数。但在运算规则、运算速度及硬件成本方面又不如定点数。因此，究竟选用定点数还是浮点数，应根据具体应用综合考虑。一般来说，通用的大型计算机大多采用浮点数，或同时采用定、浮点数；小型、微型及某些专用机、控制机则大多采用定点数。当需要作浮点运算时，可通过软件实现，也可外加浮点扩展硬件（如协处理器）来实现。</p></li></ol><h3 id="ieee-754-标准">IEEE 754 标准</h3><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/IEEE.png" alt="image-20220727161122768" / loading="lazy"><figcaption aria-hidden="true">image-20220727161122768</figcaption></figure><ul><li>尾数必须规格化，非 0 的有效位最高位为 1（隐含）。所以尾数有一个最高位为隐藏位，其值恒为 1</li><li>在实际应用中分为短实数（float）和长实数（double）以及临时实数（不采用隐藏位）</li></ul><table><thead><tr class="header"><th>类型</th><th>符号位 S</th><th>阶码</th><th>尾数</th><th>总位数</th></tr></thead><tbody><tr class="odd"><td>短实数</td><td>1</td><td>8</td><td>23</td><td>32</td></tr><tr class="even"><td>长实数</td><td>1</td><td>11</td><td>52</td><td>64</td></tr><tr class="odd"><td>临时实数</td><td>1</td><td>15</td><td>64</td><td>80</td></tr></tbody></table><h2 id="定点运算">定点运算</h2><h3 id="移位运算">移位运算</h3><p>移位运算指 <strong>小数点不动，数据左移或者右移</strong>，其中左移绝对值变大，右移绝对值减小。对计算机来说，左移一位意味着数据变为原先的两倍，右移则为二分之一。移位运算有很大的实用价值。例如，当某计算机没有乘（除） 法运算线路时，可以采用移位和加法相结合，实现乘（除）运算。</p><h4 id="算术移位">算术移位</h4><blockquote><p>计算机中机器数的字长往往是固定的，当机器数左移 n 位或右移 n 位时，必然会使其 n 位低位或 n 位高位出现空位。那么，对空出的空位应该添补 0 还是 1 呢？这 <strong>与机器数采用有符号数还是无符号数有关</strong>。对有符号数的移位称为算术移位。</p></blockquote><table><thead><tr class="header"><th>真值</th><th>码制</th><th>填补代码</th></tr></thead><tbody><tr class="odd"><td>正数</td><td>原码、反码、补码</td><td>0</td></tr><tr class="even"><td>负数</td><td>原码</td><td>0</td></tr><tr class="odd"><td>负数</td><td>反码</td><td>1</td></tr><tr class="even"><td>负数</td><td>补码</td><td>左移为 0，右移为 1</td></tr></tbody></table><ul><li>算术移位保证 <strong>符号位不变</strong>，约定数值部分移位后能够存储的下</li><li>机器数为正时，不论是左移还是右移，添补代码均为 0。</li><li>由于负数的 <strong>原码数值部分与真值相同</strong>，故在移位时只要使符号位不变，其空位均添 0 即可。</li><li>由于负数的 <strong>反码各位除符号位外与负数的原码正好相反</strong>，故移位后所添的代码应与原码相反，即全部添 1。</li><li>分析任意负数的补码可发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。故负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添 0；右移时因空位出现在高位，则添补的代码应与反码相同，即添 1。</li><li>对于负数，三种机器数算术移位后符号位均不变。负数的原码左移时，高位丢 1，结果出错；右移时，低位丢 1，影响精度。负数的补码左移时，高位丢 0，结果出错；右移时，低位丢 1,，影响精度。负数的反码左移时，高位丢 0，结果出错；右移时，低位丢 0，影响精度。</li></ul><h4 id="逻辑移位">逻辑移位</h4><p>有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。换言之，算术移位不会移动符号位，而逻辑移位会。逻辑移位的规则是：逻辑左移时，高位移丢，低位添 0；逻辑右移时，低位移丢，高位添 0。</p><h3 id="加减运算">加减运算</h3><p>之所以引进补码，就是因为其可以将减法运算转换为加法运算。而现代计算机也确实采用补码做加减法运算</p><h4 id="补码加减法">补码加减法</h4><p>整数加法： <span class="math inline">\([A] _{\text {补 }}+[B]_{\text {补 }}= [A+B]_{\text {补 }}\left(\bmod 2^{n+1}\right)\)</span></p><p>小数加法： <span class="math inline">\([A] _{\text {补 }}+[B]_{\text {补 }}= [A+B]_{\text {补 }}(\bmod 2)\)</span></p><p>整数减法： <span class="math inline">\([A-B] _{\text {补 }}= [A+(-B)]_{\text {补 }}= [A] _{\text {补 }}+[-B]_{\text {补 }}\left(\bmod 2^{n+1}\right)\)</span></p><p>小数减法： <span class="math inline">\([A-B] _{\text {补 }}= [A+(-B)]_{\text {补 }}= [A] _{\text {补 }}+[-B]_{\text {补 }}(\bmod 2)\)</span></p><ul><li>注意 <strong>符号位需要参与计算</strong>，丢弃符号位的进位</li></ul><h4 id="溢出判断">溢出判断</h4><ol type="1"><li><p>一位符号位判断：参加操作的两个数（减法时即为被减数和“求补” 以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出。换言之，数值部分最高位的进位 <span class="math inline">\(\oplus\)</span> 符号位的进位 = 1 即为溢出。</p></li><li><p>两位符号位判溢出：首先使用变形补码，其公式如下。简而言之，对于正数其变形补码（符号位）为 <span class="math inline">\(00\)</span> ，对于负数其变形补码（符号位）为 <span class="math inline">\(11\)</span> 。数值部分可以用原本的取反加一计算。 <span class="math display">\[[x]_\text{补}= \begin{cases}x &amp; 1 &gt; x \geq 0 \\ 4+x &amp; 0 &gt; x \geq-1(\bmod 4)\end{cases}\]</span></p></li></ol><p><span class="math display">\[[x]_{\text {补 }}= \begin{cases}0,\ x &amp; 2^{n}&gt; x \geqslant 0 \\ 2^{n+2}+x &amp; 0 &gt; x \geqslant-2^{n} \quad\left(\bmod 2^{n+2}\right)\end{cases}\]</span></p><ul><li>在用变形补码作加法时，2 位符号位要连同数值部分一起参加运算，而且 <strong>高位符号位产生的进位自动丢失</strong>，便可得正 确结果。变形补码判断溢出的原则是：<strong>当 2 位符号位不同时，表示溢出</strong>，否则，无溢出。不论是否发生溢出，高位符号位永远代表其结果真正的符号。</li></ul><h3 id="乘法运算">乘法运算</h3><p>先来看一个乘法的改进算法，其计算 <span class="math inline">\(0.1101 \times 0.1011\)</span> 的值，具体过程 <a href="https://www.bilibili.com/video/BV1t4411e7LH?p=85">哈工大计组 p85</a>。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B9%98%E6%B3%95%E6%94%B9%E8%BF%9B.png" alt="image-20220730234454703" style="zoom:80%;" / loading="lazy"></p><p>再通过异或电路判断正负，结果为 <span class="math inline">\(0.10001111\)</span></p><p>通过乘法运算的改进算法可归纳如下：</p><ol type="1"><li><strong>符号位单独判断。</strong></li><li><strong>乘法运算可用逻辑移位和加法来实现</strong>，比如两个 4 位数相乘，总共需要进行 4 次加法运算和 4 次 <strong>逻辑移位</strong>。</li><li>由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积；同时，乘数也右移一位，<strong>空出高位存放部分积的低位。</strong></li><li>每次做加法时，被乘数仅仅与原部分积的高位（被乘数的位数）相加，<strong>其低位被移至乘数所空出的高位位置</strong>。</li></ol><p>计算机很容易实现这种运算规则。用一个 <strong>X 寄存器</strong> 存放被乘数，一个 <strong>ACC 寄存器</strong> 存放乘积的高位，另一个 <strong>MQ 寄存器</strong> 存放乘数及乘积的低位，再配上加法器及其他相应电路，就可组成乘法器。又因加法只在部分积的高位进行，故不但节省了器材，而且还缩短了运算时间。</p><blockquote><ul><li><p>ACC：累加器，用于存放操作数，或运算结果。</p></li><li><p>MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。</p></li><li><p>X：通用的操作数寄存器，用于存放操作数</p></li><li><p>ALU：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</p></li></ul></blockquote><h4 id="原码一位乘法">原码一位乘法</h4><ol type="1"><li><p>符号位用异或单独判断</p></li><li><p>数值部分按照绝对值相乘（先加再 <strong>逻辑右移</strong>）</p></li><li><p>每次加法根据 <strong>MQ 寄存器</strong>（存放乘数及乘积低位）的末位确定：</p><ul><li><p>1： <span class="math inline">\(ACC+[\lvert {x}\rvert]_\text{原}\)</span></p></li><li><p>0： $ACC + 0 $</p></li></ul></li><li><p>用右移的次数（等于乘数的位数，或者机器字长）判断是否结束</p></li></ol><h4 id="补码一位乘法">补码一位乘法</h4><ol type="1"><li>符号位参与运算</li><li>先加再 <strong>补码的算术右移</strong>，最后再加</li><li>辅助位：指 <strong>MQ 寄存器</strong> 扩展的一位末位，其初始值为 0。每次右移时其值被更新为末位的值</li><li><strong>ACC 寄存器</strong> 和 <strong>X 寄存器</strong> 存放的乘积高位和被乘数，都是用 <strong>双符号位记录</strong></li><li>每次加法根据 <strong>MQ 寄存器</strong> 的末位和 <strong>辅助位</strong> 确定，使用辅助位 - MQ 最低位的值判断：<ul><li>1： <span class="math inline">\(ACC+[x]_\text{补}\to ACC\)</span></li><li>0： <span class="math inline">\(ACC+0\to ACC\)</span></li><li>-1： <span class="math inline">\(ACC+[-x]_\text{补}\to ACC\)</span></li></ul></li></ol><h3 id="除法运算">除法运算</h3><p>回忆一下手算除法，不难总结出二进制手算除法的规律：使用数值部分进行计算，根据除数和余数的大小确定一位商，进行一次减法操作并得到余数。再余数后补零，重复计算直到满足精度或者整除。那么如何在计算机中实现上述过程呢？</p><p>为了方便说明，定义被除数 <span class="math inline">\(x\)</span> ，除数 <span class="math inline">\(y\)</span> ，当前的余数 <span class="math inline">\(R\)</span></p><h4 id="原码恢复余数法">原码恢复余数法</h4><ol type="1"><li>符号位用异或单独判断</li><li>数值部分按照 <strong>绝对值</strong> 进行计算，还需要计算除数的绝对值补码和除数相反数的绝对值补码。即 <span class="math inline">\([\lvert{y}\rvert] _\text{补}\)</span> 和 <span class="math inline">\([\lvert{-y}\rvert]_\text{补}\)</span></li><li>使用 <strong>ACC</strong> 存储被除数（当前的余数 <span class="math inline">\(R\)</span> ），使用 <strong>X</strong> 存储除数 <span class="math inline">\(y\)</span> ，使用 <strong>MQ</strong> 存储商</li><li>这个方法的精髓就在于：计算机不会直接比较 <span class="math inline">\(R\)</span> 和 <span class="math inline">\(y\)</span> 的大小，而是直接 <strong>商 1</strong>（在 MQ 的末位写入）。然后计算 $ R - y = R + []_ ACC$ ，将结果写入 <strong>ACC</strong> 后，通过电路判断符号位是否为 0（正数）。如果为 1，则进行 $ R + y ACC$ 恢复余数，再改成 <strong>商 0</strong>。</li><li>对 <strong>ACC</strong> 和 <strong>MQ</strong> 进行 <strong>逻辑左移</strong>，<strong>MQ</strong> 的最高位填充到 <span class="math inline">\(ACC\)</span> 的末位，末位补零。<strong>最后一次上商后无需左移</strong></li><li>重复 4-5 步，直到商的位数达到机器字长长度。假设得到余数为 00111，则真值为 <span class="math inline">\(0.0111 \times 2^{-n} = 0.0111 \times 2^{-4}\)</span> 。商为 <span class="math inline">\(01101\)</span> ，则商为 <span class="math inline">\(0.1101\)</span> 。再用符号位异或确定商的符号位（余数一定是正数）。</li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9B%9E%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95.png" alt="image-20220803184738585" style="zoom:80%;" / loading="lazy"></p><h4 id="原码加减交替法">原码加减交替法</h4><p>对恢复余数法进行总结可以发现：</p><ul><li>上商 1 后： <span class="math inline">\(2 \times R -y\)</span></li><li>上商 0 后： <span class="math inline">\(2 \times (R+y) -y = 2 \times R +y\)</span></li></ul><p>通过这样的化简，我们可以精简恢复余数法上商 0 的操作，即 <strong>省略恢复余数的步骤</strong>。故又称不恢复余数法。同样也是移位 n 次，上商 n+1 次。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95.png" alt="image-20220803191510289" style="zoom:80%;" / loading="lazy"></p><h4 id="补码除法">补码除法</h4><ol type="1"><li>使用双符号位表示正负，符号位参与运算</li><li>被除数 <span class="math inline">\(x\)</span> 和除数 <span class="math inline">\(y\)</span> 同号，则 <span class="math inline">\(R = x -y = x+[-y] _\text{补}\)</span> ，否则 <span class="math inline">\(R = x+y = x+ [y]_\text{补}\)</span></li><li>若余数 <span class="math inline">\(R\)</span> 与除数 <span class="math inline">\(y\)</span> 同好，则商 1，余数左移一位减去除数 <span class="math inline">\(2 \times R - y = 2 \times R +[-y] _\text{补}\)</span> ，否则商 0，余数左移一位加上除数 <span class="math inline">\(2 \times R + y = 2 \times R +[y]_\text{补}\)</span> 。重复 n 次</li><li>如果对商的精度没有特殊要求，一般可采用“末位恒置 1”法，这种方法操作简单，易于实现，而且最大误差仅为 <span class="math inline">\(2^{-n}\)</span></li></ol><h2 id="浮点四则运算">浮点四则运算</h2><h3 id="浮点加减运算">浮点加减运算</h3><blockquote><p>由于浮点数尾数的小数点均固定在第一数值位前，所以尾数的加减运算规则与定点数的完全相同。但由于其阶码的大小又直接反映尾数有效值小数点的实际位置，因此当两浮点数阶码不等时，因两尾数小数点的实际位置不一样，尾数部分无法直接进行加减运算。为此，浮点数加减运算必须按以下几步进行。</p></blockquote><ol type="1"><li>对阶：使两数的小数点对齐</li><li>尾数求和：将对阶后的两尾数按定点加减运算规则求和（差）。</li><li>规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。</li><li>舍入，为提高精度，要考虑尾数右移时丢失的数值位。</li><li>溢出判断，即判断结果是否溢出。</li></ol><p>例子： <span class="math inline">\(x = 0.1101 \times 2^{01} \quad y =(-0.1010) \times 2^{11}\)</span> ，计算 <span class="math inline">\(x+y\)</span></p><h4 id="对阶">对阶</h4><p>对阶的目的是使两操作数的小数点位置对齐，即使两数的阶码相等。为此，首先要求出 <strong>阶差</strong>，再按 <strong>小阶向大阶看齐</strong> 的原则，使阶小的尾数向右移位，每右移一位，阶码加 1，直到两数的阶码相等为止。<strong>右移的次数正好等于阶差</strong>。尾数右移时可能会发生数码丢失，影响精度。（如果选择大阶向小阶看齐，则需要让尾数变大左移，这可能导致最高位丢失造成数据错误）</p><p>首先将数据用浮点数补码表示： <span class="math display">\[[x]_\text{补} = 00,01;\ 00.1101\\[y]_\text{补} = 00,11;\ 11.0110\]</span></p><ul><li>四位阶码（两位阶符），六位尾数（两位尾符）</li></ul><p>求阶差： <span class="math display">\[[\Delta j] _\text{补} = [j_x]_\text{补} - [j_y]_\text{补} = 00,01 + 11,01 = 11,10 &lt; 0\]</span></p><ul><li>阶差为 <span class="math inline">\(11,10 = -2\)</span> ，所以 <span class="math inline">\(j_x+2\quad S_x \to 2\)</span></li></ul><p>对阶： <span class="math inline">\([x] _\text{补&#39;} = 00,11; 00.0011 \quad [y]_\text{补} = 00,11;\ 11.0110\)</span></p><h4 id="尾数求和">尾数求和</h4><p>将对阶后的两个尾数按定点加（减）运算规则进行运算 <span class="math display">\[[S_x +S_y] _\text{补} = [S_x]_\text{补&#39;}+[S_y]_\text{补} = 00.0011 + 11.0110 = 11.1001\]</span></p><ul><li><span class="math inline">\([x+y]_\text{补} = 00,11; 11.1001\)</span></li></ul><h4 id="规格化">规格化</h4><p>当前基值 <span class="math inline">\(r\)</span> 为 2，那么要求前 1 位即首位不为 0。通过 <strong>左规和右规</strong> 进行规格化，直到尾符和首位不同为止（机器数为补码，且考虑特例 <span class="math inline">\(-1 \ and\  -\frac{1}{2}\)</span> ）</p><p>左规：尾数左移，阶码减一 <span class="math display">\[[x+y]_\text{补} = 00,10; 11.0011\]</span> 右规：尾数右移，阶码加一。只有当尾数的符号位溢出，俩符号位数值不等，即形如 <span class="math inline">\(10.XXX \quad 01.XXX\)</span> 时才进行右规</p><h4 id="舍入">舍入</h4><p>在 <strong>对阶和右规</strong> 的过程中，可能会将尾数的低位丢失，引起误差，影响精度。为此可用舍入法来提高尾数的精度。常用的舍入方法有以下两种。</p><ol type="1"><li>“0 舍 1 人”法：类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为 0，则舍去；被移去的最高数值位为 1，则在尾数的末位加 1。这样做可能使尾数又溢出，此时需再做一次右规。</li><li>“恒置 1”法：尾数右移时，不论丢掉的最高数值位是“1”或“0”，都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;绝区零好潮。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220808231206.jpeg&quot; alt=&quot;img&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（五）</title>
    <link href="http://lapras.xyz/2022/07/26/fe0a25d8.html"/>
    <id>http://lapras.xyz/2022/07/26/fe0a25d8.html</id>
    <published>2022-07-26T07:53:07.000Z</published>
    <updated>2022-08-21T07:21:56.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>难起来了，光看哈工大的 mooc 感觉已经听不懂了，准备去啃啃 CSAPP 或者 Nand2Tetris 。</p><span id="more"></span><h2 id="概述">概述</h2><h3 id="输入输出系统的发展概况">输入输出系统的发展概况</h3><p>早期的计算机数目较少，应用少，外设也少。所以早期使用 <strong>分散连接</strong> 的方式，即每一个设备都有专门的控制电路，甚至与 CPU 的控制电路高度耦合。所以对外设增删都非常麻烦。外部设备与主机的连接主要采用 <strong>程序查询方式</strong>，即 CPU 和 I/O 设备 <strong>串行工作</strong>。</p><p>随着计算机发展，分散连接逐步被淘汰。出现了 <strong>I/O 接口</strong> 与 <strong>DMA 控制器</strong>，采用 <strong>总线</strong> 方式进行连接，一条总线连接多个设备，总线与 I/O 设备的传输方式也变成了 <strong>并行工作</strong>。</p><p>为了进一步使得 I/O 操作独立于 CPU 之外，又出现了具有 <strong>通道结构</strong> 的 I/O，可以看成 <strong>小型的 DMA 控制器</strong>，具有自己的指令系统，可以控制连接在通道上的 I/O 设备直接与主机交互。</p><p>现代的超级计算机可以使用专门的处理器作为 I/O 处理机，甚至能帮助 CPU 进行运算。</p><h3 id="输入输出系统的组成">输入输出系统的组成</h3><p><strong>I/O 软件</strong></p><ol type="1"><li>I/O 指令：CPU 指令集的一部分，其格式为操作码+命令码+设备码</li><li>通道指令：通道能够指令由通道指令构成的程序，指出数组的首地址、传送字数、操作命令</li></ol><p><strong>I/O 硬件</strong></p><ol type="1"><li>设备–I/O 接口–总线–主机</li><li>设备–设备控制器–子通道–通道–主机</li></ol><h3 id="io-设备与主机的联系方式">I/O 设备与主机的联系方式</h3><p>I/O 设备是有地址的，主机必须要给出其地址才能操作。所以要对 I/O 设备编址，其编址方式有：</p><p><strong>统一编址</strong>：将 I/O 设备地址编写在内存区域，用取数和读数到对应区域则为 I/O 操作。显然会节省命令集，但是对于寻址空间的要求较高。</p><p><strong>单独编址</strong>：在内存地址之外，专门设置一个地址空间给外部设备。为了区分指令是对内存还是对 I/O 设备，此时需要有专门的 I/O 指令进行操作。</p><p>编址之后，需要选址。采用 <strong>设备选择电路</strong> 识别是否被选中，只要把 CPU 给出的地址和设备中保存的地址进行比较，相同则为选中。然后就可以开始数据传送：</p><p><strong>串行</strong>：数据一位一位进行传输，传输速度慢，适合远程上传输</p><p><strong>并行</strong>：同时有多位数据进行传输，通常情况下为 8 的倍数。</p><p>联络方式：外设接受或发送数据的响应情况</p><p><strong>立即响应</strong>：直接发生响应</p><p><strong>异步工作</strong>：一般采用应答信号的方式，分为并行传输和串行传输。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%80%E8%88%AC%E9%87%87%E7%94%A8%E5%BA%94%E7%AD%94%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%96%B9%E5%BC%8F.png" alt="image-20220724133812663" style="zoom:80%;" / loading="lazy"></p><p><strong>同步工作</strong>：采用同步时标</p><h3 id="io-设备与主机信息传送的控制方式">I/O 设备与主机信息传送的控制方式</h3><p>程序查询方式：CPU 和外设串行工作</p><p>程序中断方式：CPU 和外设做到部分并行</p><p>DMA 方式：使得外部设备和内存之间建立直接连接，无需 CPU 额外处理</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="image-20220724135731680" style="zoom:80%;" / loading="lazy"></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD.png" alt="image-20220724140401331" style="zoom:80%;" / loading="lazy"></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD2.png" alt="image-20220724140459014" style="zoom:80%;" / loading="lazy"></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/DMAa.png" alt="image-20220724141208316" style="zoom:80%;" / loading="lazy"></p><h2 id="外部设备">外部设备</h2><h3 id="概述-1">概述</h3><p>外部设备（I/O 设备）通过 I/O 接口与主机相连，其主要包含两个部分：设备控制器与物理部分。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87.png" alt="image-20220725101402068" style="zoom:80%;" / loading="lazy"></p><h3 id="外部设备的分类">外部设备的分类</h3><ol type="1"><li>人机交互设备：键盘、鼠标、打印机、显示器</li><li>计算机信息存储设备：磁盘、光盘、磁带</li><li>机-机通信设备：调制解调器</li></ol><h2 id="io-接口">I/O 接口</h2><h3 id="接口的功能">接口的功能</h3><ol type="1"><li>实现设备的选择</li><li>实现数据的缓冲平衡不同外部设备速度匹配</li><li>实现数据串-并格式转换</li><li>实现电平转换</li><li>传送控制命令</li><li>反映设备的工作状态。</li></ol><h3 id="接口的组成">接口的组成</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E6%88%90.png" alt="image-20220725103240038" style="zoom:80%;" / loading="lazy"></p><ul><li>设备选择线（单向）：传送本次参与信息传输的设备码（设备地址）或端口地址给 I/O 接口进行匹配</li><li>数据线（双向）：完成数据的输入输出</li><li>命令线（单向）：主机发送命令进过缓冲和译码之后，控制设备操作</li><li>状态线（单向）：从 I/O 接口发送给主机，告知设备的状态</li></ul><h3 id="接口的功能和组成">接口的功能和组成</h3><table><thead><tr class="header"><th>功能</th><th>组成</th></tr></thead><tbody><tr class="odd"><td>选址功能</td><td>设备选择电路</td></tr><tr class="even"><td>传送命令</td><td>命令寄存器、命令译码器</td></tr><tr class="odd"><td>传送数据</td><td>数据缓冲寄存器</td></tr><tr class="even"><td>反映设备状态</td><td>设备状态标记</td></tr></tbody></table><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/I/O%E6%8E%A5%E5%8F%A3%E7%BB%84%E6%88%90.png" alt="image-20220725104935351" style="zoom:80%;" / loading="lazy"></p><h3 id="接口分类">接口分类</h3><ol type="1"><li>数据传送方式分类：并行接口、串行接口</li><li>选择的灵活性分类：可编程接口、不可编程接口</li><li>通用性分类：通用接口、专用接口</li><li>数据传送的控制方式：中断方式接口、DMA 接口</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;难起来了，光看哈工大的 mooc 感觉已经听不懂了，准备去啃啃 CSAPP 或者 Nand2Tetris 。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（四）</title>
    <link href="http://lapras.xyz/2022/07/23/9194e09f.html"/>
    <id>http://lapras.xyz/2022/07/23/9194e09f.html</id>
    <published>2022-07-23T05:58:07.000Z</published>
    <updated>2022-08-21T07:21:56.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>摸了一周崛起，又回来上工了！</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220723135707.png" alt="image-20220723135707436" style="zoom:80%;" / loading="lazy"></p><span id="more"></span><h2 id="概述">概述</h2><h3 id="问题的提出">问题的提出</h3><p>CPU 的发展速度非常快，而存储器的速度则会成为瓶颈，则 CPU 存在 <strong>空等</strong> 现象。通过在 CPU 和主存之间增加一个 Cache 缓存，其由静态 RAM 组成，和主存相比容量小，速度快。</p><blockquote><p>Cache 之所以行之有效，就不得不提 <strong>程序访问的局部性原理</strong>，这个原理的内含分两部分，一是时间的局部性：当前访问到的指令和数据在不久的将来很有可能还会被访问到；二是空间的局部性：当前访问的指令和数据的附近的指令和数据在不久的将来很可能会被访问到。因此，如果我们把当前访问的指令、数据及其附近的指令和数据都缓存到 Cache，那么之后再访问时，CPU 就无需访存了，进而提升了系统的性能。</p></blockquote><h3 id="主存和缓存的编址">主存和缓存的编址</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Cache%E7%BB%93%E6%9E%84.png" alt="Cache结构" style="zoom:80%;" / loading="lazy"></p><ul><li>内存被分为 <span class="math inline">\(M\)</span> 块，缓存被分为 <span class="math inline">\(C\)</span> 块，其块的大小相同都为 <span class="math inline">\(B\)</span> 个字。通常 <span class="math inline">\(M \gg C\)</span> ，这意味着同一时间内，只有一小部分的主存会被缓存</li><li>主存中的数据都是按块被缓存的，当某块被缓存时，由硬件为 Cache 的每一块维护的标记会记录下被缓存的主存块的块号。之后 CPU 访问该块的数据时，在缓存的标记中可以找到该块的块号，且相应 <strong>缓存块有效</strong>，那么就不需要访存了，直接访问相应的缓存块即可</li></ul><h3 id="缓存的命中率">缓存的命中率</h3><p>所谓 Cache 的命中，就是指 CPU 访问某个指令或数据时，其对应的主存块已经被写入缓存（已建立了对应关系/标记），反之则为未命中，CPU 必须到主存中去获取对应指令。</p><blockquote><p>CPU 多次访问数据，其中缓存命中的比率称为 Cache 的 <strong>命中率</strong>。命中率与 Cahce 的容量和块的大小有关，一般来说容量越大，块越大，则命中率越高。当然，凡是不能极端，缓存过大会提升成本和功耗，而块过大会减少块的数量，进而降低同一时间能够被缓存的主存块的数量。</p></blockquote><p>总的来说，命中率 与 Cache 的 容量与块长有关。一般块长取一个存取周期内从主存调出的信息长度</p><h4 id="访问效率-e">访问效率 <span class="math inline">\(e\)</span></h4><p><span class="math display">\[\begin{align*}e &amp;= \frac{t}{\overline t}*100\% \\&amp;=\frac{t_c}{h *t_c+(1-h)* t_m}*100\% \end{align*}\]</span></p><ul><li><span class="math inline">\(t\)</span> 为访问 Cache 的时间， <span class="math inline">\(\overline t\)</span> 为平均访问时间</li><li>带入命中率 <span class="math inline">\(h\)</span> 后，t_c <span class="math inline">\(为访问 Cache 的时间，\)</span> t_m$为访问主存的时间</li></ul><h3 id="cache-的基本结构">Cache 的基本结构</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="image-20220721105528285" style="zoom:80%;" / loading="lazy"></p><h3 id="cache-读写操作">Cache 读写操作</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Cache%E8%AF%BB.png" alt="image-20220721110412863" style="zoom:80%;" / loading="lazy"></p><p>写操作主要有两种方式：</p><ul><li>写直达法：写操作时既写入 Cache 也写入主存，写操作时间即为访问主存的时间，Cache 块退出时，不需要对主存执行写操作，因此 Cache 块的更新策略比较容易实现。</li><li>写回法：写操作时只把数据写入 Cache 而不写入主存，写操作时间即为访问 Cache 的时间，当 Cache 数据被替换出去时需要写回主存，因此增加了 Cache 的复杂性。</li></ul><h3 id="cache-改进">Cache 改进</h3><ul><li>增加 Cache 的层次级数：Cache 本质上通常是 SRAM，不过不同的单元电路组成的 SRAM 是有区别的，有的速度快、功耗高、成本高，有的速度慢、功耗低、成本低、且易于集成(具体内容可搜索 LVT HVT 关键字)。因此，参照整个存储系统的层次结构，Cache 也可以细分出不同层次，比如 L1 Cache、L2 Cache 等，以此来获得性能、功耗、芯片面积、成本等方面的平衡。</li><li>参照哈佛架构分立缓存：采用独立的数据 Cache 和指令 Cache。现代处理器基本上都采用了流水线结构，如果单独为数据和指令设置 Cache，则在某条指令执行需要访问数据时，不会影响后面的指令的取指(一个是访问数据 Cache，一个是访问指令 Cache)，从而提高计算机的性能。</li></ul><h2 id="主存地址映射">主存地址映射</h2><h3 id="直接映射">直接映射</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.png" alt="image-20220721112338281" style="zoom:80%;" / loading="lazy"></p><p>首先要对主存按照缓存块的大小进行划分成不同的区，每个区的第一个字块都放置于 Cache 存储体中的第 0 块。CPU 给出的主存地址可以分成三个部分：区号（主存字块标记），块号（Cache 字块地址），偏移地址（字块内地址）。这种结构的优点是结构简单、速度快，缺点是在 Cache 有很多空闲的情况下仍出现 Cache 冲突，影响 Cache 利用率。</p><h3 id="全相联映射">全相联映射</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="全相联映射" style="zoom:80%;" / loading="lazy"></p><p>从全相联的结构可知，这种结构相较直接映射能够提高 Cache 的利用率，因为一个主存块可以被缓存到任一缓存块。但缺点也正是源于此，无法根据主存地址确定地址所在主存块会被缓存到哪个缓存块，因此在检查缓存是否命中时，需要多个比较器同时比较主存地址中主存块的块号和所有缓存标记，造成电路结构复杂，功耗也更高。</p><h3 id="组相联映射">组相联映射</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="image-20220721115852678" style="zoom:80%;" / loading="lazy"></p><p>直接映射中，一个主存块只可能被缓存到某个特定的缓存块；全相联映射正好相反，一个主存块可以被缓存到任一缓存块。可以说这两种方式走了两个极端，各有优缺点，而组相联映射是前两种映射方式的折中，实现了一个主存块可以被缓存到若干个缓存块(<strong>一组缓存块</strong>)中：</p><h2 id="替换算法">替换算法</h2><h3 id="fifo">FIFO</h3><p>先进先出置换算法。这个就是类似于队列，先装入的页面先被置换掉。易于实现但是有可能淘汰频繁使用的页面，效果不好。</p><h3 id="lru">LRU</h3><p>将近期内最久末被访问过的 Cache 块置换出去。</p><p>LRU 算法是指: 会为每一个 Cache 块设置一个“计数器”，用于记录每个 Cache 块究竟有多长时间没有被访问了。在替换时直接选取“计数器”最大的替换即可。</p><ul><li>命中时，所命中的行的计数器清零，比其低的计数器+1，其余不变</li><li>未命中且还有空闲行时，新装入的行的计数器置为 0，其余非空闲行全+1</li><li>未命中且没有空闲行时，计数器最大的行的信息块被淘汰，新装入行的计数器置为 0，其余全+1</li></ul><h3 id="lfu">LFU</h3><p>将一段时间内被访问次数最少的那块从 Cache 中置换出去</p><p>LFU 算法会为每一个 Cache 块设置一个计数器，用于记录每个 Cache 块被访问过几次，当 Cache 块满后会替换计数器最小的</p><ul><li>新调入的块计数器为 0，之后每访问一次计数器就+1。需要替换时，选择计数器最小的一行替换</li><li>若有多个计数器最小的行，可以按照行号递增或 FIFO 策略进行选择</li></ul><h3 id="随机替换">随机替换</h3><p>随机确定将哪块从 Cache 中替换出去。 ## 辅助存储器</p><p>其不能直接与 CPU 进行信息交换，最常用的辅助存储器是 <strong>磁表面辅助存储器</strong></p><h3 id="磁表面辅助存储器">磁表面辅助存储器</h3><h4 id="技术指标">技术指标</h4><ol type="1"><li>记录密度：<ol type="1"><li>道密度 <span class="math inline">\(D_t\)</span> ：沿磁盘半径方向单位长度上的磁道数，单位为道/英寸</li><li>位密度 <span class="math inline">\(D_b\)</span> ：磁道单位长度上能记录的二进制代码位数，单位为位/英寸</li></ol></li><li>存储容量：一个硬盘存储器所能存储的字节长度， <span class="math inline">\(C = n \times k \times s\)</span></li><li>平均存取时间：存取时间是指从发出读写命令后。磁头从某一起始位置移动至新的记录位置，到开始从盘片表而读出或写入信息所需要的时间。<strong>这段时间由两个数值决定，一个是将磁头定位至所要求的磁道所需的时间，称为定位时间或寻道时间：另一个是寻道完成后至磁道上需要访问的信息到达磁头下的时间，称为等待时间</strong>，这两个时间都是随机变化的，因此往往使用平均值来表示。平均存取时间等于平均寻道时间与平均等待时间之和。平均寻道时间是最大寻道时间与最小寻道时间的平均值。</li><li>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，叫数据传输率， 传输率与存储设备和主机接口逻辑有关。从存储设备考虑，假设磁盘旋转速度为 <span class="math inline">\(n\)</span> 转/秒，每条磁道容量为 <span class="math inline">\(N\)</span> 个字节，则数据传输率 <span class="math inline">\(D_r = D_b \times V(Bps)\)</span> , 其中 <span class="math inline">\(D_b\)</span> 为位密度， <span class="math inline">\(V\)</span> 为磁盘旋转的线速度。</li><li>误码率：出错的信息位数与读出信息位总数之比</li></ol><h4 id="磁记录原理">磁记录原理</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A3%81%E7%9B%98%E5%86%99.png" alt="image-20220723131552620" style="zoom:80%;" / loading="lazy"></p><p>通过写线圈通入方向不一样的电流来写入改变局部磁化单元的朝向，从而记录 0 与 1</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A3%81%E7%9B%98%E8%AF%BB.png" alt="image-20220723131807182" style="zoom:80%;" / loading="lazy"></p><p>读写头在磁场中运动，切割磁力线，产生不同方向的电流，磁通与电势都发生变化，从而读取 0 和 1。</p><h3 id="硬磁盘存储器">硬磁盘存储器</h3><p>硬磁盘存储器的类型：</p><ol type="1"><li>固定磁头和移动磁头</li><li>可换盘和固定盘</li></ol><p>硬磁盘存储器的结构：</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A1%AC%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png" alt="image-20220723132957919" style="zoom:80%;" / loading="lazy"></p><ul><li>磁盘控制器接受来自主机的指令，转换为磁盘驱动器的控制命令。实现主机与驱动器之间的数据格式转换</li><li>盘片由硬质铝合金材料制成</li></ul><h3 id="软磁盘存储器">软磁盘存储器</h3><p>时代的眼泪，就速度而言不如硬盘，磁头来说软盘的磁头都是活动的，盘片为可更换，价格低廉但是容易损坏。</p><h3 id="光盘存储器">光盘存储器</h3><p>采用光存储技术，利用激光进行读写，第一代技术采用非磁性介质，不可擦写。第二代技术采用磁性介质后可以擦写。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;摸了一周崛起，又回来上工了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220723135707.png&quot; alt=&quot;image-20220723135707436&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>提高爬虫效率</title>
    <link href="http://lapras.xyz/2022/07/10/ee385c19.html"/>
    <id>http://lapras.xyz/2022/07/10/ee385c19.html</id>
    <published>2022-07-10T12:54:00.000Z</published>
    <updated>2022-09-01T03:27:08.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>爬都可以爬</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/xigua.png" alt="99586772_p0" style="zoom: 50%;" / loading="lazy"></p><span id="more"></span><h2 id="线程进程">线程？进程？</h2><p>简单地来说，<strong>进程</strong> 是 <strong>系统进行资源调度和分配的的基本单位</strong>，是 <strong>资源单位</strong>。比如任务管理器里面管理的就是一堆进程。而 <strong>线程</strong> 则是进程的子任务，<strong>是 CPU 调度和分派的基本单位</strong>，是 <strong>执行单位</strong>。显然一个进程可以有多个线程。</p><h3 id="线程与进程的小栗子">线程与进程的小栗子</h3><p><code>Python</code> 中最简单的一个多线程例子：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread<span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello new World"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  t <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>func<span class="token punctuation">)</span>  <span class="token comment"># 创建新线程并安排任务</span>  t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 标记线程为可以启动状态，但具体启动时间由系统决定</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Main thread"</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>或者也可以像 <code>Java</code> 中常做的那样，重写一下 <code>run</code> 方法</p><p><code>Python</code> 中最简单的一个多线程例子：</p><pre class="language-none"><code class="language-none">from multiprocessing import Processdef func():  for i in range(500):    print(&quot;Hello new World&quot;)def main():  p &#x3D; Process(target&#x3D;func)  p.start()  for i in range(500):    print(&quot;Main process&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:  main()</code></pre><ul><li>不难发现，API 长得几乎一样</li><li>如果想要对函数传参的话，需要使用 <code>p = Process(target=func,args=(tuple))</code> 的形式，线程同理</li></ul><h3 id="线程池和进程池">线程池和进程池</h3><p>一次性开辟若干个线程（进程），用户只需要给线程池（进程池）提交任务即可。对于具体的线程调度不需要关心</p><p><code>Python</code> 的线程池</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> concurrent<span class="token punctuation">.</span>futures <span class="token keyword">import</span> ThreadPoolExecutor<span class="token punctuation">,</span> ProcessPoolExecutor<span class="token keyword">def</span> <span class="token function">fn</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  <span class="token comment"># 创建线程池</span>  <span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      t<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token string">"Thread-"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 等待所有线程结束，才继续执行守护</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ThreadPoolExecutor done"</span><span class="token punctuation">)</span></code></pre><ul><li>进程池的话，就换成 <code>ProcessPoolExecutor</code> 即可</li></ul><h3 id="使用线程池进行爬取">使用线程池进行爬取</h3><p>对 <a href="http://xinfadi.com.cn/priceDetail.html">北京新发地的菜价</a> 进行一个爬取。首先要分析一下网页，发现他的数据来源是通过更改 <code>id="current"</code> 标签的 <code>value</code> 值实现的，然后使用网络工具抓包，发现其数据是请求另一个 URL 后进行渲染的。所以我们请求数据页后将数据记录于 csv 文件中。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> csv<span class="token keyword">import</span> timef <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'xinfadi.csv'</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'w'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>csvw <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">get_one_page</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>  proxy <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'http'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7890'</span><span class="token punctuation">,</span>           <span class="token string">'https'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7890'</span><span class="token punctuation">&#125;</span>  url <span class="token operator">=</span> <span class="token string">"http://xinfadi.com.cn/getPriceData.html"</span>  headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36'</span><span class="token punctuation">,</span>    <span class="token string">'referer'</span><span class="token punctuation">:</span> <span class="token string">"http://xinfadi.com.cn/priceDetail.html"</span><span class="token punctuation">&#125;</span>  data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'current'</span><span class="token punctuation">:</span> value<span class="token punctuation">&#125;</span>  resp <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span> proxies<span class="token operator">=</span>proxy<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>  resp<span class="token punctuation">.</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span>  res <span class="token operator">=</span> resp<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'list'</span><span class="token punctuation">]</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> res<span class="token punctuation">:</span>    <span class="token comment"># 写入csv</span>    csvw<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span>i<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'the </span><span class="token interpolation"><span class="token punctuation">&#123;</span>value<span class="token punctuation">&#125;</span></span><span class="token string"> page done'</span></span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  <span class="token comment"># 计算时间</span>  start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    get_one_page<span class="token punctuation">(</span>i<span class="token punctuation">)</span>  end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'总共用时</span><span class="token interpolation"><span class="token punctuation">&#123;</span>end <span class="token operator">-</span> start<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span></code></pre><p>试着爬取 100 页的数据，发现耗时为 68.33s，而数据库有 16000 页。这显然太慢了。所以使用线程池的方式进行一个改写。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> concurrent<span class="token punctuation">.</span>futures <span class="token keyword">import</span> ThreadPoolExecutor<span class="token punctuation">,</span> ProcessPoolExecutor<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  <span class="token comment"># 计算时间</span>  start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 使用线程池</span>  <span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      t<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>get_one_page<span class="token punctuation">,</span> i<span class="token punctuation">)</span>  end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'总共用时</span><span class="token interpolation"><span class="token punctuation">&#123;</span>end <span class="token operator">-</span> start<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span></code></pre><p>使用了 50 个线程的表现为 12s，显然有质的提升</p><h2 id="协程">协程？</h2><p>众所周知，当程序处于 I/O 操作时，线程往往会处于堵塞状态。比如用 requests 发请求，或者读写数据库。如果我们能在堵塞状态时也能执行别的事情，那么效率就会提高。协程就是可以当线程堵塞时，选择性地切换到别的任务，提高 CPU 的利用率。所以即使在 <strong>单线程</strong> 的条件下，我们也能看到多个任务 "同时" 进行的现象。</p><blockquote><p>协程，英文叫作 coroutine，又称微线程、纤程，它是一种用户态的轻量级线程。</p><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态，即所有局部状态的一个特定组合，每次过程重入时，就相当于进入上一次调用的状态。</p><p>协程本质上是个单进程，它相对于多进程来说，无须线程上下文切换的开销，无须原子操作锁定及同步的开销，编程模型也非常简单。</p><p>我们可以使用协程来实现异步操作，比如在网络爬虫场景下，我们发出一个请求之后，需要等待一定时间才能得到响应，但其实在这个等待过程中，程序可以干许多其他事情，等到响应得到之后才切换回来继续处理，这样可以充分利用 CPU 和其他资源，这就是协程的优势。</p></blockquote><h3 id="多任务异步协程">多任务异步协程</h3><p>在<code>Python</code>中实现协程，我们需要用到 <code>asyncio</code>这个库。下面先介绍一下这个库的一些基本概念</p><ul><li><code>event_loop</code>：事件循环，相当于一个无限循环，我们可以把一些函数<strong>注册</strong>到这个事件循环上，当满足条件发生的时候，就会调用对应的处理方法</li><li><code>coroutine</code>：中文翻译叫协程，在 Python 中常指代<strong>协程对象类型</strong>，我们可以将协程对象注册到时间循环中，它会被事件循环调用。我们可以使用 <code>async</code> 关键字来定义一个方法，这个方法在调用时不会立即被执行，而是返回一个协程对象</li><li><code>task</code>：任务，它是对协程对象的进一步封装，包含了任务的各个状态，比如 <code>running</code>、<code>finished</code> 等，我们可以用这些状态来获取协程对象的执行情况</li><li><code>future</code>：代表将来执行或没有执行的任务的结果，实际上和 <code>task</code> 没有本质区别</li><li>另外，我们还需要了解 <code>async</code>/<code>await</code> 关键字，它是从 Python 3.5 才出现的，专门用于定义协程。其中，<code>async</code> 定义一个协程，<code>await</code> 用来挂起阻塞方法的执行</li></ul><p>下面举个经典例子来说明协程的含金量</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> time<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'func1'</span><span class="token punctuation">)</span>  <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'func1'</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'func2'</span><span class="token punctuation">)</span>  <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'func2'</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'func3'</span><span class="token punctuation">)</span>  <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'func3'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>  tasks <span class="token operator">=</span> <span class="token punctuation">[</span>func1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> func2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> func3<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span>  loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>  end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'总共用时</span><span class="token interpolation"><span class="token punctuation">&#123;</span>end <span class="token operator">-</span> start<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span></code></pre><ol type="1"><li>将任务声明为协程对象，即使用 <code>async def</code> 的方式定义函数。任何调用该函数的行为返回的都是一个 <code>coroutine object</code>，而非运行其中的代码。如果想要运行其中的函数，则需要满足进入 <code>async</code> 模式且 <code>coroutine</code> 变为 <code>task</code></li><li>正常的 Python 代码都是 <code>sync</code> 也就是同步模式，想要切换到 <code>async</code> 模式。我们通常使用 <code>asyncio.run()</code>（Python &gt;= 3.7），其参数为一个 <code>coroutine</code>，它会自动建立 <code>event loop</code> 并把参数 <code>coroutine</code> 变为其中的第一个 <code>task</code> 开始运行</li><li>能被 <code>await</code> 的对象有 3 种：<code>coroutine</code>、<code>task</code> 和 <code>future</code></li><li>当你 <code>await coroutine</code> 时， <span class="math inline">\(Don&#39;t \ do\  that\)</span> 。直接这样做就与同步别无二致。</li><li>所以我们需要直接 <code>await task</code>，<code>event loop</code> 就直接给出控制权，并在结束时记录返回值。这也就需要我们提前使用 <code>task = asyncio.create_task(coroutine obj)</code> 注册一个 <code>task</code></li><li>除了上述的<code>asyncio.run()</code>的方式，通常的流程应该如下<ol type="1"><li>使用<code>loop = asyncio.get_event_loop()</code>注册事件循环</li><li>使用<code>task = asyncio.create_task(coroutine obj)</code>注册任务</li><li>使用<code>loop.run_until_complete(task)</code>开始执行</li></ol></li><li>那么如果有很多 <code>task</code> 需要注册呢？<ol type="1"><li>如案例中的<code>asyncio.wait()</code>，其返回值是一个元组，包括两个集合，分别表示已完成和未完成的任务。wait第二个参数为一个超时值，达到这个超时时间后，未完成的任务状态变为pending</li><li>或者可以用 <code>asyncio.gather()</code>。其会返回一个 <code>future</code>，参数为若干个可 <code>await</code> 的对象的<code>list</code>。<code>task</code> 会被注册到 <code>event loop</code> 中，如果是 <code>coroutine</code> 则首先会被包装成 <code>task</code> 再注册到 <code>event loop</code> 中。然后返回的 <code>future</code> 其目的是告知 <code>event loop</code> 需要完成其中所有的 <code>task</code> 后才能继续执行。最后返回其中所有 <code>task</code> 的 <code>return</code> 值按照顺序返回到一个 <code>list</code> 中。其与<code>wait()</code>的主要区别就在于其任务无法取消，返回值是按照传入参数的顺序返回的结果列表</li></ol></li></ol><h4 id="绑定回调">绑定回调</h4><p>另外，我们也可以为某个 <code>task</code> 绑定一个回调方法</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> requests<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    url <span class="token operator">=</span> <span class="token string">'https://www.baidu.com'</span>    status <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token keyword">return</span> status<span class="token keyword">def</span> <span class="token function">callback</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Status:'</span><span class="token punctuation">,</span> task<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>coroutine <span class="token operator">=</span> request<span class="token punctuation">(</span><span class="token punctuation">)</span>task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>coroutine<span class="token punctuation">)</span>task<span class="token punctuation">.</span>add_done_callback<span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Task:'</span><span class="token punctuation">,</span> task<span class="token punctuation">)</span>loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Task:'</span><span class="token punctuation">,</span> task<span class="token punctuation">)</span></code></pre><blockquote><p>这里我们定义了一个 <code>request</code> 方法，请求了百度，获取其状态码，但是这个方法里面我们没有任何 <code>print</code> 语句。</p><p>随后我们定义了一个 <code>callback</code> 方法，这个方法接收一个参数，是 <code>task</code> 对象，然后调用 <code>print</code> 方法打印了 <code>task</code> 对象的结果。这样我们就定义好了一个 <code>coroutine</code> 对象和一个回调方法。我们现在希望的效果是，当 <code>coroutine</code> 对象执行完毕之后，就去执行声明的 <code>callback</code> 方法。</p><p>那么它们两者怎样关联起来呢？很简单，只需要调用 <code>add_done_callback</code> 方法即可。我们将 <code>callback</code> 方法传递给封装好的 <code>task</code> 对象，这样当 <code>task</code> 执行完毕之后，就可以调用 <code>callback</code> 方法了。同时 <code>task</code> 对象还会作为参数传递给 <code>callback</code> 方法，调用 <code>task</code> 对象的 <code>result</code> 方法就可以获取返回结果了。</p></blockquote><h3 id="aiohttp">aiohttp</h3><p>我们仅仅将涉及 IO 操作的代码封装到 <code>async</code> 修饰的方法里面是不可行的，必须使用支持异步操作的请求方式才可以实现真正的异步，所以需要使用 <code>aiohttp</code>，下面是稍加改动后的官网的例子</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> aiohttp<span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">fetch</span><span class="token punctuation">(</span>session<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">async</span> <span class="token keyword">with</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token keyword">as</span> response<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> response<span class="token punctuation">.</span>status<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">async</span> <span class="token keyword">with</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> session<span class="token punctuation">:</span>    text<span class="token punctuation">,</span> status_code <span class="token operator">=</span> <span class="token keyword">await</span> fetch<span class="token punctuation">(</span>session<span class="token punctuation">,</span> <span class="token string">"http://httpbin.org/get"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"text:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>text<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token format-spec">100]</span><span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"code:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>status_code<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>大体上与 <code>request.session</code> 的操作方式相同。首先用 <code>async with aiohttp.ClientSession() as session:</code> 注册一个支持异步的上下文客户端会话管理器 <code>session</code>，用 <code>session</code> 去异步地发送请求 <code>async with session.get(url) as response:</code> 此时可以添加 <code>params,headers,data,cookies</code>。最后使用 <code>await resp.json() or .text() or .read()</code> 来得到数据</p><p>下面给出一个常用框架：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> aiohttp<span class="token keyword">import</span> asyncio<span class="token keyword">def</span> <span class="token function">get_tasks</span><span class="token punctuation">(</span>session<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">"""  获取任务列表  :param 客户端会话  :return: 任务列表  """</span>  tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    tasks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>fetch<span class="token punctuation">(</span>session<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> tasks<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">fetch</span><span class="token punctuation">(</span>session<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">"""  异步获取网页的具体过程  :param 客户端会话  :return: 网页的数据  """</span>  <span class="token keyword">async</span> <span class="token keyword">with</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://httpbin.org/get'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> resp<span class="token punctuation">:</span>    <span class="token comment"># 断言，如果状态码不是 200，则抛出异常</span>    <span class="token keyword">assert</span> resp<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> resp<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token keyword">async</span> <span class="token keyword">with</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> session<span class="token punctuation">:</span>    tasks <span class="token operator">=</span> get_tasks<span class="token punctuation">(</span>session<span class="token punctuation">)</span>    responses <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token operator">*</span>tasks<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>responses<span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="参考">参考</h2><p>https://www.kingname.info/2020/03/23/insert-sprit/</p><p>https://www.bilibili.com/video/BV1oa411b7c9</p><p>https://cuiqingcai.com/202271.html</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;爬都可以爬&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/xigua.png&quot; alt=&quot;99586772_p0&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫学习" scheme="http://lapras.xyz/categories/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="爬虫" scheme="http://lapras.xyz/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Python" scheme="http://lapras.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 网页解析库小介绍</title>
    <link href="http://lapras.xyz/2022/07/09/f8dd4268.html"/>
    <id>http://lapras.xyz/2022/07/09/f8dd4268.html</id>
    <published>2022-07-09T02:57:00.000Z</published>
    <updated>2022-08-21T07:21:56.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在用 <code>Python</code> 进行网络爬虫，拿到 HTML 内容之后势必要对其进行一些内容上的解析。之前用过正则表达式 <code>re</code> 和 <code>BeautifulSoup</code>。前者速度挺快的，但是代码可读性较差。后者虽然简单，但是速度令人捉急。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220709111111.jpg" alt="92274729_p0_master1200" style="zoom:80%;" / loading="lazy"></p><span id="more"></span><p>先放个速度对比图，数据来源 <a href="https://zhuanlan.zhihu.com/p/25887452">知乎-拒绝撕逼，用数据来告诉你选择器到底哪家强</a></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220726005550.png" alt="img" style="zoom:80%;" / loading="lazy"></p><h2 id="xpath">XPath</h2><p><code>XPath</code> 是一门在 <code>XML</code> ⽂档中查找信息的语言.<code>XPath</code> 可用来在 <code>XML</code> 文档中对元素和属性进行遍历。而我们熟知的 <code>HTML</code> 恰巧属于 <code>XML</code>。 所以完全可以用其进行解析。</p><h3 id="xml-基本知识">XML 基本知识</h3><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>book</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>高等数学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>price</span><span class="token punctuation">></span></span>28.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>price</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>author</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nick</span><span class="token punctuation">></span></span>武钟祥<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nick</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nick</span><span class="token punctuation">></span></span>张宇<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nick</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>author</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>book</span><span class="token punctuation">></span></span></code></pre><ul><li>DOM 将 HTML 表示为标签的树形结构。</li><li>每一对标签都是一个节点</li><li><strong>标签中的属性及文本也可视为该节点的子节点</strong></li><li>节点之间有父子关系，同胞关系。以及先辈和后裔这种一代及以上的关系</li><li>利用缩进，可以很好的理解这些概念</li></ul><h3 id="安装导入">安装导入</h3><pre class="language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> lxml -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><p>有很多库都提供了 Xpath 解析的方法，这里选择 <code>lxml</code>。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> lxml <span class="token keyword">import</span> etree<span class="token comment"># 或者</span><span class="token keyword">from</span> lxml <span class="token keyword">import</span> htmletree <span class="token operator">=</span> html<span class="token punctuation">.</span>etree</code></pre><h3 id="解析过程">解析过程</h3><ol type="1"><li>准备源文件</li><li>得到解析对象 <code>et = etree.HTML(html)</code></li><li>使用 <code>xpath</code> 方法进行解析，视情况选择直接解析或者进一步 <code>for</code> 循环解析。</li></ol><h3 id="具体方法介绍">具体方法介绍</h3><ol type="1"><li><p>节点选取</p><ul><li>node：选取此节点的所有子节点</li><li><code>/</code>：从根节点选取</li><li><code>//</code>：从当前节点选择文档中后裔节点</li><li><code>.</code>：选取当前节点</li><li><code>..</code>：选取当前节点的父节点</li><li><code>@</code>：选取属性</li></ul></li><li><p>节点选取举例</p><table><thead><tr class="header"><th>表达式</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>bookstore</td><td>选取 bookstore 元素的所有子节点</td></tr><tr class="even"><td>/ bookstore</td><td>选取根元素 bookstore ，相当于绝对路径的写法</td></tr><tr class="odd"><td>bookstore/book</td><td>选取属于 bookstore 的子元素的所有 book 元素</td></tr><tr class="even"><td>//book</td><td>选取所有 book 子元素，而不管它们在文档中的位置</td></tr><tr class="odd"><td>bookstore//book</td><td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置</td></tr><tr class="even"><td>//<span class="citation" data-cites="lang">@lang</span></td><td>选取名为 lang 的所有属性</td></tr></tbody></table></li><li><p>值筛选</p><p>上述表达式都会返回一个 <code>Element</code> 类的列表，我们可以在 <strong>表达式中</strong> 使用 <code>[]</code> 进行进一步筛选节点。</p><p>用法为在任意节点后添加 <code>[]</code>，里面的表达式可以为：</p><ul><li><code>1</code>：选取该节点的第一个元素</li><li><code>last()</code>：选取该节点的最后一个元素</li><li><code>position()</code>：选取位置符合布尔表达式的元素。比如 <code>position()&gt;4</code>。</li><li><code>@lang</code>：选取拥有名为 lang 的属性的该节点元素。比如 <code>//title[@lang]</code> 表示选取所有拥有名为 lang 的属性的 title 元素</li><li><code>@lang='xx'</code>：选取拥有名为 lang 的属性且值为 xx 的该节点元素</li><li><code>contains(@属性,"值")</code>：选取属性包含有某个值的节点元素</li><li>可以搭配 <code>and or |</code> 使用</li></ul></li><li><p>通配符</p><ul><li><code>*</code>：匹配任何元素节点</li><li><code>@*</code>：匹配任何属性节点</li><li><code>node()</code>：匹配任何节点</li></ul></li><li><p>获取数据</p><ul><li><code>/text()</code>：获取节点文本内容</li><li><code>/@属性</code>：获取节点某个属性的内容</li></ul></li></ol><h3 id="浏览器工具">浏览器工具</h3><ol type="1"><li><p>首先当然是万能的 <code>F12</code>。可以通过右键元素选择检查，找到元素的相对位置</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220708154611.png" alt="F12 检查" / loading="lazy"><figcaption aria-hidden="true">F12 检查</figcaption></figure><p>同时，在开发者工具的 <code>Element</code> 中搜索时可以使用 <code>XPath</code> 表达式进行检索。也可以右键元素，选择复制 <code>XPath</code></p></li><li><p><code>selectorshub</code> 这个浏览器插件，可以直接生成 xpath, cssSelector, Playwright selectors , jQuery, JS Path 等路径</p></li></ol><h3 id="小栗子">小栗子</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> lxml <span class="token keyword">import</span> etree<span class="token keyword">import</span> requests<span class="token comment"># 爬取B站排行榜</span>url <span class="token operator">=</span> <span class="token string">'https://www.bilibili.com/v/popular/rank/all'</span>headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36'</span><span class="token punctuation">&#125;</span>proxy <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'http'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7890'</span><span class="token punctuation">,</span>         <span class="token string">'https'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7890'</span><span class="token punctuation">&#125;</span>resp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">,</span> proxies<span class="token operator">=</span>proxy<span class="token punctuation">)</span>resp<span class="token punctuation">.</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span><span class="token comment"># etree把网页内容转换成可以操作的对象</span>et <span class="token operator">=</span> etree<span class="token punctuation">.</span>HTML<span class="token punctuation">(</span>resp<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment"># 获取排行榜的标题</span>titles <span class="token operator">=</span> et<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span><span class="token string">"//div[@class='info']/a/text()"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>titles<span class="token punctuation">)</span></code></pre><h2 id="pyquery">Pyquery</h2><p>与 JS 中使用的 Jquery 基本相同，都是使用 CSS 选择器达到解析的目的。</p><h3 id="常用的-css-选择器">常用的 CSS 选择器</h3><ol type="1"><li>标签选择器 <code>Label</code>：选择器名和指定的 HTML 元素名的不区分大小写的匹配。这是选择所有指定类型的最简单方式</li><li>类选择器 <code>.Label</code>：类名是在 HTML class 文档元素属性中没有空格的任何值。类 Class 是可以重复且有多个的</li><li>ID 选择器 <code>#Label</code>： 任何元素都可以使用 id 属性设置唯一的 ID 名称。 这是选择单个元素的最有效的方式</li><li>通配选择器 <code>*</code>：选择在一个页面中的所有元素, 常常搭配使用</li><li>组合器分组 <code>Label1, Label2......</code>：选择所有出现的 Label</li><li>后代选择器 <code>Label1 Label2</code>：选择 <code>Label1</code> 中的所有 <code>Label2</code> 后裔</li><li>子选择器 <code>Label1 &gt; Label2</code>：选择 <code>Label1</code> 中的所有 <code>Label2</code> 直接后代</li><li>相邻兄弟选择器 <code>Label1+Label2</code>：选择 <code>Label2</code> 元素，它是 <code>Label1</code> 的下一个直接兄弟元素</li><li>通用兄弟选择器 <code>Label1~Label2</code>：选择 <code>Label2</code> 元素，它是 <code>Label1</code> 的兄弟元素</li><li>属性选择器 <code>Label[attr]</code> 表示选择包含 attr 属性的所有元素，<code>Label[attr]=val</code> 表示仅选择 attr 属性被赋值为 val 的所有元素，<code>[attr~=val]</code>：该选择器仅选择 attr 属性的值（以空格间隔出多个值）中有包含 val 值的所有元素</li><li>伪类选择器：内容繁多，功能丰富。详见 <a href="https://www.w3school.com.cn/css/css_pseudo_classes.asp">w3c</a></li></ol><h3 id="安装导入-1">安装导入</h3><pre class="language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> pyquery -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pyquery <span class="token keyword">import</span> PyQuery <span class="token keyword">as</span> pq</code></pre><h3 id="解析过程-1">解析过程</h3><ol type="1"><li>准备源文件</li><li>得到解析对象 <code>doc = pq(resp.text)</code></li><li>使用 <code>doc(CSS选择器表达式)</code> 的方式获取 <code>HTML</code> 内容</li><li>使用 <code>.text()</code> 获取文本，使用 <code>.attr('属性')</code> 获取属性值</li><li>使用 <code>.attr('属性', '值')</code> 来修改属性或者添加属性</li><li>使用 <code>.children(css)</code> 查找子节点，<code>.find(css)</code> 查找子孙节点</li><li>使用 <code>.parent(css)</code> 查找父节点，<code>.parents(css)</code> 查找祖先节点</li><li>使用 <code>.siblings(css)</code> 查找兄弟节点</li><li>如果选择的内容超过一条后想要获取他们的文本属性值，则需使用 <code>.items()</code>，返回一个迭代器后使用 <code>for</code> 迭代或者使用 <code>list comprehension</code></li></ol><h3 id="小例子">小例子</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pyquery <span class="token keyword">import</span> PyQuery <span class="token keyword">as</span> pq<span class="token keyword">import</span> requests<span class="token comment"># 爬取B站排行榜</span>url <span class="token operator">=</span> <span class="token string">'https://www.bilibili.com/v/popular/rank/all'</span>headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36'</span><span class="token punctuation">&#125;</span>proxy <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'http'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7890'</span><span class="token punctuation">,</span>         <span class="token string">'https'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7890'</span><span class="token punctuation">&#125;</span>resp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">,</span> proxies<span class="token operator">=</span>proxy<span class="token punctuation">)</span>resp<span class="token punctuation">.</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span><span class="token comment"># pyquery把网页内容转换成可以操作的对象</span>p <span class="token operator">=</span> pq<span class="token punctuation">(</span>resp<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment"># 获取排行榜的标题</span>items <span class="token operator">=</span> p<span class="token punctuation">(</span><span class="token string">'.rank-list .info>a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span>title <span class="token operator">=</span> <span class="token punctuation">[</span>item<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> items<span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span></code></pre><h2 id="parsel">Parsel</h2><p>Parsel 这个库可以解析 HTML 和 XML，同时支持 CSS 和 XPath 两种解析方式并融合了正则表达式的提取功能。<a href="https://scrapy.org/">scrapy</a> 选择器部分也是基于此二次封装的产物。</p><h3 id="安装导入-2">安装导入</h3><pre class="language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> parsel -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> parsel <span class="token keyword">import</span> Selector</code></pre><h3 id="解析过程-2">解析过程</h3><ol type="1"><li><p>首先创建一个 <code>Selector</code> 对象，传入 HTML 字符串。</p><pre class="language-python" data-language="python"><code class="language-python">selector <span class="token operator">=</span> Selector<span class="token punctuation">(</span>text <span class="token operator">=</span> HTML<span class="token punctuation">)</span></code></pre></li><li><p>使用 <code>.css()</code> 或者 <code>.xpath()</code> 进行解析，并通过 CSS 中的 <code>::text</code> 或者 <code>::attr(属性)</code>，通过 <code>XPath</code> 的 <code>/text()</code> 和 <code>/@属性</code> 获取内容，返回一个 <code>SelectorList</code> 迭代对象</p></li><li><p><code>SelectorList</code> 进行遍历用 <code>.get()</code> 获取内容文本，或者 <code>.getall()</code> 返回内容文本列表</p></li><li><p><code>SelectorList</code> 使用 <code>.re()</code> 可以使用正则表达式进一步提取内容并返回列表</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在用 &lt;code&gt;Python&lt;/code&gt; 进行网络爬虫，拿到 HTML 内容之后势必要对其进行一些内容上的解析。之前用过正则表达式 &lt;code&gt;re&lt;/code&gt; 和 &lt;code&gt;BeautifulSoup&lt;/code&gt;。前者速度挺快的，但是代码可读性较差。后者虽然简单，但是速度令人捉急。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220709111111.jpg&quot; alt=&quot;92274729_p0_master1200&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫学习" scheme="http://lapras.xyz/categories/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="爬虫" scheme="http://lapras.xyz/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Python" scheme="http://lapras.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（三）</title>
    <link href="http://lapras.xyz/2022/06/30/26b9f9fa.html"/>
    <id>http://lapras.xyz/2022/06/30/26b9f9fa.html</id>
    <published>2022-06-30T14:58:07.000Z</published>
    <updated>2022-08-21T07:21:56.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>市原大輔走了，但没完全走。崛起你真的好温柔。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220630231342.jpg" alt="91953835_p0_master1200" style="zoom:80%;" / loading="lazy"></p><span id="more"></span><h2 id="存储器分类">存储器分类</h2><h3 id="按存储介质分类">按存储介质分类</h3><ol type="1"><li>半导体存储器（易丢失）：TTL（集成度低，功耗高），MOS（集成度高，功耗低）</li><li>磁表面存储器：磁头(读/写)、载磁体(存储)</li><li>磁芯存储器：硬磁材料，环状元件</li><li>光盘存储器：激光(读/写)，磁光材料(存储)</li></ol><h3 id="按存取方式分类">按存取方式分类</h3><ol type="1"><li><p>存取时间与物理地址无关 (随机访问)</p><ul><li><p>随机存储器（<strong>在程序执行过程中</strong> 可读可写）</p></li><li><p>只读存储器（<strong>在程序执行过程中</strong> 只读）</p></li></ul></li><li><p>存取时间与物理地址有关(串行访问)</p><ul><li><p>顺序存取存储器，如磁带</p></li><li><p>直接存取存储器，如磁盘</p></li></ul></li></ol><h3 id="按在计算机中的作用分类">按在计算机中的作用分类</h3><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%89%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB.png" alt="按在计算机中的作用分类" / loading="lazy"><figcaption aria-hidden="true">按在计算机中的作用分类</figcaption></figure><ul><li><p>Cache：高速缓冲存储器，位于 CPU 和主存之间，用于缓存主存的数据。本质上是一块集成到 CPU 的 SRAM。</p></li><li><p>RAM：</p><ul><li><p>静态 RAM(SRAM)</p></li><li><p>动态 RAM(DRAM)</p></li></ul></li><li><p>ROM：</p><ul><li><p>MROM(掩膜 ROM)</p></li><li><p>PROM(可编程 ROM)</p></li><li><p>EPROM(电可编程 ROM)</p></li><li><p>EEPROM(电可编程可擦除 ROM)</p></li></ul></li><li><p>Flash Memory（闪存）：可用于固态硬盘</p></li></ul><h2 id="存储器的层次结构">存储器的层次结构</h2><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E5%99%A8%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="image-20220628201956665" / loading="lazy"><figcaption aria-hidden="true">image-20220628201956665</figcaption></figure><ul><li>速度：从快到慢</li><li>容量：从小到大</li><li>价格：从高到低</li><li>寄存器：集成在 CPU 当中，I/O 端口中也存在。<ul><li>从体系结构的角度，供给给机器语言程序员使用的称为体系结构寄存器。</li></ul></li><li>缓存：一部分集成在 CPU 当中。如果 CPU 需要读取或写入数据，缓存的速度更快</li></ul><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BC%93%E5%AD%98%20%E4%B8%BB%E5%AD%98%E5%B1%82%E6%AC%A1%E5%92%8C%E4%B8%BB%E5%AD%98%20%E8%BE%85%E5%AD%98%E5%B1%82%E6%AC%A1.png" alt="缓存 主存层次和主存 辅存层次" / loading="lazy"><figcaption aria-hidden="true">缓存 主存层次和主存 辅存层次</figcaption></figure><ul><li>缓存到辅存的管理由 CPU 提供的硬件来完成，通常软件开发者不需要了解其中的细节。</li><li>主存到辅存的管理由 CPU 提供的 <strong>MMU</strong> 以及操作系统提供的 <strong>内存管理模块</strong> 共同完成，不仅可以为每个进程提供 <strong>独立的地址空间</strong>，还可以借助辅存让那些比主存容量还要大的程序得以运行。</li></ul><h2 id="主存储器">主存储器</h2><h3 id="概述">概述</h3><ol type="1"><li>主存的基本结构</li></ol><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="主存的基本结构" / loading="lazy"><figcaption aria-hidden="true">主存的基本结构</figcaption></figure><ul><li>MAR：记录了我们要访问的存储单元地址</li><li>MDR：记录了我们要读出或者写入的数据</li><li>具体的读还是写，则是由控制电路控制读写电路实现</li></ul><ol start="2" type="1"><li>主存和 CPU 联系</li></ol><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E8%81%94%E7%B3%BB.png" alt="主存和 CPU 联系" / loading="lazy"><figcaption aria-hidden="true">主存和 CPU 联系</figcaption></figure><ul><li>MDR 和 MAR 都是集成在 CPU 上的，但属于主存</li><li>数据总线完成 CPU 和主存的信息传输</li><li>地址总线是单向的，CPU 给定要访问的内存单元地址</li><li>控制信号：读取或者写入</li></ul><ol start="3" type="1"><li><p>主存中存储单元地址的分配</p><p>假设当前使用的存储器字长为 32 位，要存储的数为 12345678H。首先根据 8 位一个字节，每个字节都要有一个 <strong>字地址</strong>，那么一个存储单元就可以分为 4 个字节。<strong>字地址的选择是当前字节的第一个地址</strong>，所以根据数据的存放顺序，可以分为两种方式。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png" alt="大端和小端方式" / loading="lazy"><figcaption aria-hidden="true">大端和小端方式</figcaption></figure><ul><li>如图，每一个格子都有八位（存储两个 16 进制数），一行就是一个存储单元（字长为 32）</li><li>字地址从 0 开始编号</li><li><strong>主存的寻址方式</strong>：按字节寻址（每个地址对应一个字节）和按字寻址（每个地址对应一个字）</li></ul></li><li><p>主存的技术指标</p><ul><li><p>存储容量：存放二进制数据的总位数或总字节数</p></li><li><p>存储速度：</p><ul><li>存取时间：存储器的访问(读/写)时间，即给出地址信号到访问完成所需的时间</li><li>存取周期：<strong>连续</strong> 两次 <strong>独立</strong> 的存储器访问操作所需的 <strong>最小</strong> 时间间隔，通常 <strong>大于</strong> 存取时间</li></ul></li><li><p>存储器的带宽：单位时间内写入的位数</p></li></ul></li></ol><h3 id="半导体芯片简述">半导体芯片简述</h3><ol type="1"><li><p>半导体芯片的存储结构</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%8A%E5%AF%BC%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="半导体芯片的存储结构" / loading="lazy"><figcaption aria-hidden="true">半导体芯片的存储结构</figcaption></figure><ul><li>地址线：单向，由 CPU 或 I/O 设备</li><li>数据线：双向，读取向外，写入向内</li><li><strong>芯片容量</strong>：假设地址线有 <span class="math inline">\(n\)</span> 条，数据线有 <span class="math inline">\(m\)</span> 条。则芯片容量为 <span class="math inline">\(m \times 2^n\)</span> 位，通常将 <span class="math inline">\(2^n\)</span> 表示为 <span class="math inline">\(K\)</span> 的形式，即 <span class="math inline">\(2^{10}\)</span> 为 <span class="math inline">\(1K\)</span> 。然后写为 <span class="math inline">\(\alpha K \times m\)</span> 位 ，其中 <span class="math inline">\(\alpha\)</span> 为系数</li><li>片选线：传输片选信号，用来选中具体的芯片（存储器可能由多个存储芯片构成）。表示为 <span class="math inline">\(\overline{CS},\overline{CE}\)</span></li><li>读写控制线： <span class="math inline">\(\overline {WE}\)</span> （低电平写，高电平读），或者用两根线表示： <span class="math inline">\(\overline{OE},\overline{WE}\)</span></li></ul></li><li><p>半导体存储芯片扩展</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E6%89%A9%E5%B1%95.png" alt="存储芯片扩展" / loading="lazy"><figcaption aria-hidden="true">存储芯片扩展</figcaption></figure><p>首先是位扩展：将 8 片一位的并为一组，则得到 <span class="math inline">\(16K \times 8\)</span> 位存储器</p><p>然后是字扩展：复制为 4 组即可得到 <span class="math inline">\(64K \times 8\)</span> 位存储器</p><p>所以一共使用了 32 片存储芯片，即其存储容量的倍数关系</p></li><li><p>半导体芯片的译码驱动方式</p><p>线选法</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BA%BF%E9%80%89%E6%B3%95.png" alt="线选法" / loading="lazy"><figcaption aria-hidden="true">线选法</figcaption></figure><p>线选法主要是通过地址译码器，走指定字线到目标的存储单元。并且根据读写控制电路选择数据的流通方向。显然这样做系统的结构非常清晰，但是内部字线的数量会随着地址增加而变得非常臃肿。</p><p>重合法</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%87%8D%E5%90%88%E6%B3%95.png" alt="重合法" / loading="lazy"><figcaption aria-hidden="true">重合法</figcaption></figure><p>重合法将所有的存储单元形成一个矩阵布局。通过行（X 地址）列（Y 地址）分别进行译码操作。</p></li></ol><h3 id="随机存取存储器ram">随机存取存储器（RAM）</h3><h4 id="静态-ramsram">静态 RAM（SRAM）</h4><p>SRAM 使用 <strong>触发器</strong> 来保存 0 和 1 这两个状态。具体的电路实现就省略了。下面开始举例：</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Intel%202114.png" alt="Intel 2114" / loading="lazy"><figcaption aria-hidden="true">Intel 2114</figcaption></figure><ul><li><span class="math inline">\(\overline {WE}\)</span> ：读写控制</li><li><span class="math inline">\(\overline {CS}\)</span> ：片选信号，只有当其为低电平时，该芯片被选中</li><li><span class="math inline">\(A\)</span> ：地址线，一共有 10 条，说明是地址位为 <span class="math inline">\(1K\)</span></li><li><span class="math inline">\(I/O\)</span> ：数据线，一共有 4 条，说明数据位为 4</li></ul><p>下面举个例子，将 2114 拼成一个 64X64 的存储阵列，通过重合法，一次 <strong>读取同一行的四列数据</strong></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/64X64%202114.png" alt="64X64 2114" / loading="lazy"><figcaption aria-hidden="true">64X64 2114</figcaption></figure><ul><li>不难发现，行地址全部正常编号。列地址只使用了 4 位，即编号 16 个地址。那么将列数 64 与 16 相除，得到四组。这样一来每次就能实现选取同一行的四列数据</li></ul><h4 id="动态-ramdram">动态 RAM（DRAM）</h4><p>DRAM 使 <strong>用电容存储电荷的方式来存储 1，0</strong>。读数据时，当电容是高电平的时候为 1，低电平的时候为 0。写数据时，写 1 就是为电容充电，写 0 则是电容放电。由于电容会通过电路漏电，时间一久电荷就会流失，导致信息丢失，因此需要周期性的刷新电容(为电容充电)。其具体电路实现分为 <strong>单管</strong> 和 <strong>三管</strong></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220629125609.png" alt="Intel1103-DRAM 三管读取数据" / loading="lazy"><figcaption aria-hidden="true">Intel1103-DRAM 三管读取数据</figcaption></figure><ul><li>由图易得，是 <span class="math inline">\(1K \times 1\)</span> 位的存储器。通过重合法进行译码</li><li>首先是行地址，注意这里除了 5 位行地址，还包括一位读取信号。列地址同理</li><li>得到数据后，通过读写控制电路向外界传输</li></ul><h4 id="动态-ram-的刷新">动态 RAM 的刷新</h4><p>回想动态 RAM 的操作过程，首先是行地址取出一整行的数据到某条选择线上。这时我们在选择线上加装一个刷新放大器，即可保存原本的数值。所以，<strong>刷新只与行地址有关，每次刷新一行</strong></p><ol type="1"><li>集中刷新：存在死区</li><li>分散刷新：无死区，但读写周期加长，性能变差</li><li>异步刷新：存在小死区，但是如果安排得当。比如放置在 CPU 进行指令译码时，则无死区。</li></ol><h4 id="动态-ram-和静态-ram-比较">动态 RAM 和静态 RAM 比较</h4><ol type="1"><li>存储原理：输出 DRAM 使用电容存储数据；SRAM 使用触发器存储数据</li><li>集成度：DRAM 的基本单元电路结构更简单，方便大规模集成，因此 DRAM 集成度更高</li><li>引脚数量：DRAM 通常将行列地址复用引脚，因此引脚数量少(进而芯片封装的体积较小)；而 SRAM 出于速度的考虑，一般不会这样做</li><li>功耗：DRAM 的功耗主要消耗在电容充放电，功耗较小；SRAM 的使用触发器存放数据，而构成触发器的管子有部分是一直导通的，也就一直消耗功率，因此功耗较大</li><li>价格：同样存储一个 bit，DRAM 的单元电路简单，价格低；SRAM 的单元电路复杂，用的管子多，因此价格高</li><li>速度：访问 DRAM 伴随着电容的充放电，因此速度较慢；而 SRAM 采用 chu'fa，访问速度快</li><li>刷新：DRAM 需要周期性的刷新其中的电容，才能保持数据；SRAM 则没有这个需要。</li></ol><h3 id="只读存储器rom">只读存储器（ROM）</h3><p>ROM 的发展历程</p><ol type="1"><li>早期的 ROM 在出厂时就会被厂家烧写好内容，且不支持用户再次对 ROM 进行编程</li><li>用户可以使用专门的擦写设备对芯片进行一次擦写，<strong>仅可擦写一次</strong></li><li>用户可以使用专门的擦写设备对芯片进行多次擦写，比如用紫外线擦写的 EPROM，这时候擦写还比较麻烦</li><li>EEPROM 的出现使得用户可以多次擦写 ROM，且无需使用专门的擦写设备</li></ol><h4 id="几种-rom-的简介">几种 ROM 的简介</h4><ul><li>MROM（掩模式只读存储器）：<strong>行列选择线交叉处有 MOS 管则表示 1，无 MOS 管则表示 0。</strong> 因为有无 MOS 管在芯片生产出来后就决定了，因此不可编程。</li><li>PROM（可编程只读存储器）：通常实现为在行列选择线之间 <strong>添加一根熔丝</strong>，编程时需要写 0 则加大电流让熔丝熔断，否则熔丝连通表示 1。由于熔丝熔断后不可在连接，因此 <strong>只可进行一次编程</strong>。</li><li>EPROM（可擦除可编程式只读存储器）：EPROM 可通过对芯片中的 <strong>N 型沟道浮动栅 MOS 管</strong> 的 D 端加电压，形成浮动栅，进而电路不导通表示 0，反之表示 1。浮动栅可由 <strong>紫外线照射后消除</strong>，因此可以利用紫外线实现芯片的全部擦写，从而实现芯片的多次编程。</li><li>EEPROM（电子式可擦除可编程只读存储器）：EEPROM 改进了芯片的擦写功能，实现了电可擦写，且既可局部擦写也可全局擦写。</li><li>Flash Memory（闪存）：，较 EEPROM 成本更低，单元电路更为简单，集成度高，访问速度也更快。不过寿命不如 EEPROM，因此闪存通常用于保存大量数据，而 EEPROM 则用于存放不需要经常改变的一些系统参数(数据量少)。只有少数支持片上执行(XIP)的闪存(如 NorFlash)才可以作为主存储器，存放程序(不可以随机写，因此无法存放程序运行时加工的数据)。而大部分闪存一般用作辅存。</li></ul><h3 id="存储器的扩展">存储器的扩展</h3><h4 id="位扩展">位扩展</h4><p>电路连接时，两块或多块芯片共用地址线，数据线则分别与 CPU 的不同数据线连接，片选和读写控制连接在一起，实现同时读，同时写。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="2 片 1Kx4 组成 1Kx8" / loading="lazy"><figcaption aria-hidden="true">2 片 1Kx4 组成 1Kx8</figcaption></figure><h4 id="字扩展">字扩展</h4><p>电路连接时，共用低位的地址线，片选信号则通过译码器连接 CPU 地址线的高位，芯片数量少时，也可以不用译码器，直接使用非门</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%97%E6%89%A9%E5%B1%95.png" alt="2 片 1Kx8 组成 2Kx8" / loading="lazy"><figcaption aria-hidden="true">2 片 1Kx8 组成 2Kx8</figcaption></figure><h4 id="字位扩展">字、位扩展</h4><p>先按位扩展将多个芯片组成一个位数更多的芯片组，各组之间再按照字扩展的连接方式与 CPU 连接</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/8%E7%89%871Kx4%E7%BB%84%E6%88%904Kx8.png" alt="8 片 1Kx4 组成 4Kx8" / loading="lazy"><figcaption aria-hidden="true">8 片 1Kx4 组成 4Kx8</figcaption></figure><h3 id="存储器与-cpu-的连接">存储器与 CPU 的连接</h3><ol type="1"><li>地址线的连接</li><li>数据线的连接</li><li>读/写命令线的连接</li><li>片选线的连接</li><li>合理选择存储芯片：系统配置和系统程序使用 ROM，用户程序选择 RAM。</li><li>其他 时序、负载</li></ol><h3 id="对存储器进行校验">对存储器进行校验</h3><p>复杂的电磁环境下，工作中的存储器受到干扰，可能导致其内部存储的 1、0 发生翻转，即 1 变成 0、0 变成 1，这样存储的信息就出错了。如果我们无法得知这一情况，而在程序中使用了错误的数据，那么就可能造成损失。</p><p>一个编码集合中，任意两个合法编码之间 <strong>二进制位数</strong> 的 <strong>最少差异</strong> 称为 <strong>编码的最小距离</strong>，编码的纠错和检错能力与其最小距离有关。具体关系如下： <span class="math display">\[L - 1 = D + C (D &gt;= C)\]</span></p><ul><li>L：编码的最小距离</li><li>D：能够检错的位数</li><li>C：能够纠错的位数</li></ul><p>常用的检验方法有奇偶校验，海明码，CRC 循环校验</p><h4 id="奇偶校验">奇偶校验</h4><p>奇校验：使待校验 bit 串和校验位共有 <strong>奇数</strong> 个 1</p><p>偶校验：使待校验 bit 串和校验位共有 <strong>偶数</strong> 个 1</p><h4 id="海明码汉明码">海明码（汉明码）</h4><p>是一种多重分组奇偶校验。将数据组织为 <span class="math inline">\(k\)</span> 个分组，每组进行奇偶校验。不仅能检验是否出错，也能定位错误，但定位代价较大，假设有 <span class="math inline">\(n\)</span> 位有效码，设置了 <span class="math inline">\(k\)</span> 位校验码，则 <span class="math inline">\(n\)</span> 与 <span class="math inline">\(k\)</span> 关系为 <span class="math display">\[2^k ≥ n + k + 1\]</span> + 假设有 <span class="math inline">\(k\)</span> 个校验位，一位有 0 或 1 两种情况， <span class="math inline">\(k\)</span> 位就有 <span class="math inline">\(2^k\)</span> 种排列情况，能表示 <span class="math inline">\(2^k\)</span> 种状态。其中一个状态用来表示正确（没有错误发生）的这种情况。其余的 <span class="math inline">\(2^k-1\)</span> 种状态来表示错误发生在哪一位。总共有 <span class="math inline">\(n+k\)</span> 位，所以 <span class="math inline">\(2^k-1\)</span> 要大等于 <span class="math inline">\(n+k\)</span> 。</p><ul><li><p>海明码的校验码总是放在 <span class="math inline">\(2^i, i = 0,1,2,3...\)</span></p></li><li><p>把海明码（有效码和校验码的结合）从左到右，从 <strong>1</strong> 开始编号 <span class="math inline">\(C_1C_2n_3C_4n_5n_6n_7C_8...\)</span></p></li><li><p>各检验码负责的部分： <span class="math inline">\(C_i\)</span> 负责检验第 <span class="math inline">\(i\)</span> 位为 1 的编号</p></li><li><p>校验码的数值 = 它所负责的有效码的异或（偶校验规则下）或者凑偶数个 1</p></li><li><p>海明码的纠错过程：</p><ol type="1"><li>接收方先根据数据长度确定 <span class="math inline">\(k\)</span></li><li>增设检验位 <span class="math inline">\(P_i\)</span> ，比如假设此时 <span class="math inline">\(k = 3\)</span> ，则新的检验码为 <span class="math inline">\(P_4P_2P_1\)</span></li><li>根据检验码的规则计算 <span class="math inline">\(P_i\)</span> ，比如偶规则下， <span class="math inline">\(P_1 = 1\oplus 3 \oplus 5\oplus7\)</span></li><li>得到二进制表示的检验码 <span class="math inline">\(P\)</span> ，换算成 10 进制即可得到哪一位出错了。如果是全 0 则表示无错误</li></ol></li><li><p>海明距离：是字符串相对于同样长度的零字符串的汉明距离，也就是说，它是字符串中非零的元素个数：对于二进制字符串来说，就是 1 的个数，所以 11101 的汉明重量是 4。</p></li></ul><h3 id="提高访存速度的措施">提高访存速度的措施</h3><blockquote><ol type="1"><li>采用高速组件</li><li>采用层次结构 Cache-主存</li><li>调整主存结构</li></ol></blockquote><p>下面介绍通过调整主存结构的方式：</p><ol type="1"><li><p>单体多字系统</p><p>将存储器的和 CPU 的存储控制器的位宽设置为 CPU 字长(寄存器宽度)的整数倍，一次性可以读出多条指令或数据，缺点是写的时候，如果仅写一个字的内容比较麻烦，需要相应的硬件配合。</p></li><li><p>多体并行系统 主要思想是采用多个存储器并行工作，CPU 访问第一个存储器后，在读到数据前，无需等待，直接访问下一个存储器。这样一轮下来，第一个存储器已经准备好了数据，并能够接收下一次访问(存取周期已到)，于是再来一轮。如此，CPU 和存储器都不会空闲。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;市原大輔走了，但没完全走。崛起你真的好温柔。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220630231342.jpg&quot; alt=&quot;91953835_p0_master1200&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Python 求解规划类问题</title>
    <link href="http://lapras.xyz/2022/06/29/d7cb7c5c.html"/>
    <id>http://lapras.xyz/2022/06/29/d7cb7c5c.html</id>
    <published>2022-06-29T15:08:00.000Z</published>
    <updated>2022-08-21T07:21:56.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>摸鱼，等崛起的神威太刀。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B3%A1%E5%A3%B6%E9%BE%99%E5%A4%AA%E5%88%80.jpg" alt="89249011_p1_master1200" style="zoom: 67%;" / loading="lazy"></p><span id="more"></span><h2 id="线性规划">线性规划</h2><p><strong>生产问题，投料问题</strong></p><p>线性规划求解需要确定目标函数（ <span class="math inline">\(max，min\)</span> ）和约束条件（ <span class="math inline">\(s.t.\)</span> ）</p><p>求解前应该转为标准形式，即不等式约束，等式约束以及范围约束： <span class="math display">\[\min \mathrm{c}^{T} x \\\begin{equation}\text { s.t. }\left\{\begin{array}{c}A x \leq b \\A e q * x = b e q \\l b \leq x \leq u b\end{array}\right.\end{equation}\]</span></p><ul><li><span class="math inline">\(c^T\)</span> 为目标函数系数 <strong>向量</strong></li><li><span class="math inline">\(A\)</span> 为不等式组系数 <strong>矩阵</strong>， <span class="math inline">\(b\)</span> 为不等式组常数 <strong>向量</strong></li><li><span class="math inline">\(Aeq\)</span> 为等式组系数 <strong>矩阵</strong>， <span class="math inline">\(beq\)</span> 为等式组系数 <strong>向量</strong></li><li><span class="math inline">\(lb, ub\)</span> 为下界和上界 <strong>向量</strong></li></ul><pre class="language-matlab" data-language="matlab"><code class="language-matlab"><span class="token punctuation">[</span>x<span class="token punctuation">,</span>fval<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">linprog</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> A<span class="token punctuation">,</span> b<span class="token punctuation">,</span> Aeq<span class="token punctuation">,</span> beq<span class="token punctuation">,</span> lb<span class="token punctuation">,</span> ub<span class="token punctuation">,</span> X0<span class="token punctuation">)</span></code></pre><ul><li><p>标准形式为求解最小值，如果求解最大值等价于求 <span class="math inline">\(-\min \mathrm{c}^{T} x\)</span> 的最小值，最后结果再给个相反数即可</p></li><li><p>标准形式的不等式为 <strong>小等于</strong></p></li><li><p><code>x</code> 为最小值的系数 <strong>向量</strong>，<code>fval</code> 为最小值</p></li><li><p><code>X0</code> 为迭代初值，可省略</p></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> scipy <span class="token keyword">import</span> optimize<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">LinearProgram</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> A<span class="token punctuation">,</span> b<span class="token punctuation">,</span> Aeq<span class="token punctuation">,</span> beq<span class="token punctuation">,</span> bounds<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 求解函数</span>  res <span class="token operator">=</span> optimize<span class="token punctuation">.</span>linprog<span class="token punctuation">(</span>c<span class="token punctuation">,</span> A<span class="token punctuation">,</span> b<span class="token punctuation">,</span> Aeq<span class="token punctuation">,</span> beq<span class="token punctuation">,</span> bounds<span class="token punctuation">)</span>  <span class="token comment"># 目标函数最小值</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token comment"># 最优解</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>x<span class="token punctuation">)</span></code></pre><ul><li>标准形式为求解最小值，如果求解最大值等价于求 <span class="math inline">\(-\min \mathrm{c}^{T} x\)</span> 的最小值，最后结果再给个相反数即可</li><li>标准形式的不等式为 <strong>小等于</strong></li><li>无上下界约束为默认值</li><li><code>bounds</code> 为二元组列表，每个二元组对应一个 <span class="math inline">\(x\)</span> 的下界和上界，无限制则为 <code>None</code></li></ul><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220421172003.png" alt="线性规划例子" / loading="lazy"><figcaption aria-hidden="true">线性规划例子</figcaption></figure><h2 id="整数规划">整数规划</h2><h3 id="线性整数规划">线性整数规划</h3><p><strong>钢管切割问题</strong></p><p>在线性规划的基础上，加入决策变量为整数的条件</p><p>整数规划求解的基本框架是 <strong>分支定界法</strong>（Branch and bound，BnB）</p><p>首先去除整数约束得到“<strong>松弛模型</strong>”，使用线性规划的方法求解。若有某个变量不是整数，在松弛模型上分别添加约束</p><p>但是 <code>python</code> 实现分支定界较为繁琐，所以选择使用 <code>Plup</code> 这个专门用来解线性规划问题的库</p><pre class="language-matlab" data-language="matlab"><code class="language-matlab"><span class="token punctuation">[</span>x<span class="token punctuation">,</span>fval<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">intlinprog</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> intcon<span class="token punctuation">,</span> A<span class="token punctuation">,</span> b<span class="token punctuation">,</span> Aeq<span class="token punctuation">,</span> beq<span class="token punctuation">,</span> lb<span class="token punctuation">,</span> ub<span class="token punctuation">)</span></code></pre><ul><li><code>intcon</code> 为一个 <strong>向量</strong>，指定那些决策变量是整数</li></ul><h3 id="规划">0-1 规划</h3><p><strong>背包问题，指派问题</strong></p><p>特殊的线性整数规划，即决策变量只取 0 或者 1</p><p>显然，只需要对线性整数规划的上下界进行约束即可</p><h3 id="plup">Plup</h3><blockquote><p>真好用啊，符合人类直觉的限制方式</p><p>Pulp 本质上是求解器的接口，具体的求解是依赖优化器实现的</p></blockquote><ol type="1"><li>定义一个规划问题类 <code>LpProblem</code></li></ol><pre class="language-python" data-language="python"><code class="language-python">myProb <span class="token operator">=</span> pulp<span class="token punctuation">.</span>LpProblem<span class="token punctuation">(</span><span class="token string">"ProblemName"</span><span class="token punctuation">,</span> sense<span class="token operator">=</span>pulp<span class="token punctuation">.</span>LpMaximize<span class="token punctuation">)</span></code></pre><ul><li><code>sense</code> 可为：<code>LpMinimize</code> <code>LpMaximize</code> 对最小值问题和最大值问题</li></ul><ol start="2" type="1"><li>定义决策变量 <code>LpVariable</code></li></ol><pre class="language-python" data-language="python"><code class="language-python">x1 <span class="token operator">=</span> pulp<span class="token punctuation">.</span>LpVariable<span class="token punctuation">(</span><span class="token string">'x1'</span><span class="token punctuation">,</span> lowBound<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> upBound<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">,</span> cat<span class="token operator">=</span>pulp<span class="token punctuation">.</span>LpConstraint<span class="token punctuation">)</span> x2 <span class="token operator">=</span> pulp<span class="token punctuation">.</span>LpVariable<span class="token punctuation">(</span><span class="token string">'x2'</span><span class="token punctuation">,</span> lowBound<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> cat<span class="token operator">=</span>pulp<span class="token punctuation">.</span>LpInteger<span class="token punctuation">)</span>x3 <span class="token operator">=</span> pulp<span class="token punctuation">.</span>LpVariable<span class="token punctuation">(</span><span class="token string">'x3'</span><span class="token punctuation">,</span> cat<span class="token operator">=</span>pulp<span class="token punctuation">.</span>LpBinary<span class="token punctuation">)</span> </code></pre><ul><li>上下界缺省为无穷</li><li><code>cat</code> 设定变量类型，用于解决小数、整数以及 0-1 规划</li></ul><ol start="3" type="1"><li>添加目标函数</li></ol><pre class="language-python" data-language="python"><code class="language-python">myProb <span class="token operator">+=</span> <span class="token number">2</span><span class="token operator">*</span>x1 <span class="token operator">+</span> <span class="token number">3</span><span class="token operator">*</span>x2 <span class="token operator">-</span> <span class="token number">5</span><span class="token operator">*</span>x3<span class="token comment"># 设置目标函数</span></code></pre><ul><li>添加目标函数使用 “之前定义的规划问题类 += 目标函数式” 格式。</li></ul><ol start="4" type="1"><li>添加约束条件</li></ol><pre class="language-python" data-language="python"><code class="language-python">myProb <span class="token operator">+=</span> <span class="token number">2</span><span class="token operator">*</span>x1 <span class="token operator">-</span> <span class="token number">5</span><span class="token operator">*</span>x2 <span class="token operator">+</span> x3 <span class="token operator">>=</span> <span class="token number">10</span>  <span class="token comment"># 不等式约束</span>myProb <span class="token operator">+=</span> x1 <span class="token operator">+</span> <span class="token number">3</span><span class="token operator">*</span>x2 <span class="token operator">+</span> x3 <span class="token operator">&lt;=</span> <span class="token number">12</span>  <span class="token comment"># 不等式约束</span>myProb <span class="token operator">+=</span> x1 <span class="token operator">+</span> x2 <span class="token operator">+</span> x3 <span class="token operator">==</span> <span class="token number">7</span>  <span class="token comment"># 等式约束</span></code></pre><ul><li>约束式只能为 <code>==</code> <code>&gt;=</code> <code>&lt;=</code></li></ul><ol start="5" type="1"><li>求解</li></ol><pre class="language-python" data-language="python"><code class="language-python">myProb<span class="token punctuation">.</span>solve<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># myProb.solve(pulp.GUROBI_CMD())</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"求解状态:"</span><span class="token punctuation">,</span> pulp<span class="token punctuation">.</span>LpStatus<span class="token punctuation">[</span>myProb<span class="token punctuation">.</span>status<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span> v <span class="token keyword">in</span> myProb<span class="token punctuation">.</span>variables<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"="</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>varValue<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"目标值="</span><span class="token punctuation">,</span> pulp<span class="token punctuation">.</span>value<span class="token punctuation">(</span>myProb<span class="token punctuation">.</span>objective<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ul><li>PuLP 默认采用 CBC 求解器来求解优化问题</li><li>可以调用其它的优化器来求解，如：GLPK，COIN CLP/CBC，CPLEX，和 GUROBI，但需要另外安装。</li></ul><h3 id="cvxpy">CvxPY</h3><blockquote><p>支持较多变量需要用到矩阵乘法的规划问题</p></blockquote><ol type="1"><li>定义系数矩阵</li></ol><pre class="language-python" data-language="python"><code class="language-python">C <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>A <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>B <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><ol start="2" type="1"><li>声明决策变量</li></ol><pre class="language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> cp<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span>n<span class="token punctuation">,</span>integer <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span></code></pre><ul><li><span class="math inline">\(n\)</span> 为变量长度</li><li>可以声明决策变量类型<ul><li><code>neg pos nonneg nonpos</code>：负数 正数 非负数 非正数</li><li><code>boolean</code>：布尔变量</li></ul></li></ul><ol start="3" type="1"><li>声明问题</li></ol><pre class="language-python" data-language="python"><code class="language-python">objective <span class="token operator">=</span> cp<span class="token punctuation">.</span>Minimize<span class="token punctuation">(</span>cp<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>C<span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ul><li><code>Minimize</code> 和 <code>Maximize</code></li></ul><ol start="4" type="1"><li>定义约束</li></ol><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 开始拼接约束方程</span><span class="token comment"># B是右边的常数项</span>B <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>B1<span class="token punctuation">,</span> B2<span class="token punctuation">,</span> B3<span class="token punctuation">,</span> B4<span class="token punctuation">,</span> B5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># print(B)</span><span class="token comment"># A是左边的约束项</span>A <span class="token operator">=</span> np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">[</span>A1<span class="token punctuation">,</span> A2<span class="token punctuation">,</span> A3<span class="token punctuation">,</span> A4<span class="token punctuation">,</span> A5<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># print(A)</span><span class="token comment"># Be是右边的等式约束项</span>Be <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>Be1<span class="token punctuation">,</span> Be2<span class="token punctuation">,</span>Be3<span class="token punctuation">,</span>Be4<span class="token punctuation">,</span>Be5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># print(Be)</span><span class="token comment"># Ae是左边的等式约束项</span>Ae <span class="token operator">=</span> np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">[</span>Ae1<span class="token punctuation">,</span> Ae2<span class="token punctuation">,</span>Ae3<span class="token punctuation">,</span>Ae4<span class="token punctuation">,</span>Ae5<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><ol start="5" type="1"><li>定义求解器</li></ol><pre class="language-python" data-language="python"><code class="language-python">constraints <span class="token operator">=</span> <span class="token punctuation">[</span>Ae @ x <span class="token operator">==</span> Be<span class="token punctuation">,</span> A @ x <span class="token operator">>=</span> B<span class="token punctuation">]</span>prob <span class="token operator">=</span> cp<span class="token punctuation">.</span>Problem<span class="token punctuation">(</span>objects<span class="token punctuation">,</span> constraints<span class="token punctuation">)</span>prob<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>solver<span class="token operator">=</span>cp<span class="token punctuation">.</span>GUROBI<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Status:"</span><span class="token punctuation">,</span> prob<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Optimal value"</span><span class="token punctuation">,</span> prob<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Optimal var\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span>value<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="非线性规划">非线性规划</h2><p>如果目标函数或者约束条件存在非线性函数，即为非线性规划情况 <span class="math display">\[\min \mathrm{c}^{T} x \\\begin{equation}\text { s.t. }\left\{\begin{array}{c}A x \leq b \\A e q * x = b e q \\C(x) \leq 0 \\Ceq(x) = 0 \\l b \leq x \leq u b\end{array}\right.\end{equation}\]</span></p><p>不难发现，比起线性规划的标准形式，非线性规划多了 <strong>非线性不等式约束</strong> <span class="math inline">\(C(x) \leq 0\)</span> 以及 <strong>非线性等式约束</strong> <span class="math inline">\(Ceq(x)= 0\)</span></p><ul><li><p><span class="math inline">\(c^T\)</span> 为目标函数系数 <strong>向量</strong></p></li><li><p><span class="math inline">\(C(x)\)</span> 为非线性函数 <strong>向量</strong></p></li><li><p><span class="math inline">\(Ceq\)</span> 为非线性函数向量</p></li></ul><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220422103411.png" alt="非线性规划例子" / loading="lazy"><figcaption aria-hidden="true">非线性规划例子</figcaption></figure><pre class="language-matlab" data-language="matlab"><code class="language-matlab"><span class="token punctuation">[</span>x<span class="token punctuation">,</span> fval<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fmincon</span><span class="token punctuation">(</span><span class="token operator">@</span>fun<span class="token punctuation">,</span> X0<span class="token punctuation">,</span> A<span class="token punctuation">,</span> b<span class="token punctuation">,</span> Aeq<span class="token punctuation">,</span> beq<span class="token punctuation">,</span> lb<span class="token punctuation">,</span> ub<span class="token punctuation">,</span> <span class="token operator">@</span>nonlfun<span class="token punctuation">,</span> OPTION<span class="token punctuation">)</span></code></pre><ul><li>算法本身求取的是局部最优，所以预期的初始值 <code>X0</code> 非常重要</li><li>如果要求全局最优：<ul><li>给定不同的初始值，得到“全局最优解”</li><li>先用蒙特卡罗模拟，将该解作为初始值来求取最优解（推荐）</li></ul></li><li><code>OPTION</code> 可以指定使用的求解算法，<strong>通过改变算法，可以体现你的模型稳定性</strong></li><li><code>@fun</code> 和 <code>@nonlfun</code> 需要用额外的 <code>.m</code> 文件定义</li></ul><p>非线性规划可以依据目标函数类型简单分为两种，凸函数和非凸函数</p><ul><li>凸函数可以使用 <code>cvxpy</code> 库</li><li>非凸函数没有特定的算法可以尝试寻找极值：<ul><li>纯数学</li><li>神经网络，深度学习</li><li><code>scipy.optimize.minimize</code></li><li><code>gekko</code></li></ul></li></ul><h3 id="scipy-optimize">SciPy optimize</h3><blockquote><p>与 matlab 一样，需要定义目标函数以及约束条件</p></blockquote><p>目标函数</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">objective</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">'''  args 为决策变量的系数向量  '''</span>  a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d <span class="token operator">=</span> args  <span class="token keyword">def</span> <span class="token function">v</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> a<span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> d<span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>a<span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> c<span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>  <span class="token keyword">return</span> v</code></pre><p>约束条件</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">constraints</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">'''  args 为约束条件的常数向量  '''</span>  eq1<span class="token punctuation">,</span> ineq1 <span class="token operator">=</span> args  cons <span class="token operator">=</span> <span class="token punctuation">(</span>      <span class="token punctuation">&#123;</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'ineq'</span><span class="token punctuation">,</span> <span class="token string">'fun'</span><span class="token punctuation">:</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span> ineq1<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'eq'</span><span class="token punctuation">,</span> <span class="token string">'fun'</span><span class="token punctuation">:</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span>       x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">-</span> eq1<span class="token punctuation">&#125;</span>  <span class="token punctuation">)</span>  <span class="token keyword">return</span> cons</code></pre><ul><li><code>type</code> 有 <code>ineq, eq</code> 分别表示不等式约束和等式约束类型</li><li>最后记得减去常数以保证形式都为 0</li><li>注意：在 <code>optimize.minimize</code> 中的 <strong>不等式约束标准形式为大等于</strong>，与 <code>optimize.linprog</code> 相反</li></ul><p>求解</p><pre class="language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">res &#x3D; minimize(objective(objargs), X0, method&#x3D;&#39;SLSQP&#39;,bounds&#x3D;bounds, constraints&#x3D;constraints(conargs))</code></pre><ul><li>算法本身求取的是局部最优，所以预期的初始值 <code>X0</code> 非常重要</li><li><code>method</code> 可选多种算法</li></ul><h3 id="gekko">Gekko</h3><blockquote><p>与 Pulp 语法比较接近，属于人类直觉型库</p></blockquote><ol type="1"><li>初始化</li></ol><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> gekko <span class="token keyword">import</span> GEKKOm <span class="token operator">=</span> GEKKO<span class="token punctuation">(</span>remote<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment"># 指定求解器</span>m<span class="token punctuation">.</span>options<span class="token punctuation">.</span>SOLVER <span class="token operator">=</span> <span class="token number">3</span></code></pre><ol start="2" type="1"><li>定义决策变量</li></ol><pre class="language-python" data-language="python"><code class="language-python">x1 <span class="token operator">=</span> m<span class="token punctuation">.</span>Var<span class="token punctuation">(</span>lb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> ub<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>x2 <span class="token operator">=</span> m<span class="token punctuation">.</span>Var<span class="token punctuation">(</span>lb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> ub<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>x3 <span class="token operator">=</span> m<span class="token punctuation">.</span>Var<span class="token punctuation">(</span>lb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> ub<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>x4 <span class="token operator">=</span> m<span class="token punctuation">.</span>Var<span class="token punctuation">(</span>lb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> ub<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span></code></pre><ol start="3" type="1"><li>定义约束条件</li></ol><pre class="language-python" data-language="python"><code class="language-python">m<span class="token punctuation">.</span>Equation<span class="token punctuation">(</span>x1 <span class="token operator">*</span> x2 <span class="token operator">*</span> x3 <span class="token operator">*</span> x4 <span class="token operator">>=</span> <span class="token number">25</span><span class="token punctuation">)</span>m<span class="token punctuation">.</span>Equation<span class="token punctuation">(</span>x1<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x2<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x3<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x4<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">40</span><span class="token punctuation">)</span></code></pre><ol start="4" type="1"><li>定义目标函数</li></ol><pre class="language-python" data-language="python"><code class="language-python">m<span class="token punctuation">.</span>Obj<span class="token punctuation">(</span>x1 <span class="token operator">*</span> x4 <span class="token operator">*</span> <span class="token punctuation">(</span>x1 <span class="token operator">+</span> x2 <span class="token operator">+</span> x3<span class="token punctuation">)</span> <span class="token operator">+</span> x3<span class="token punctuation">)</span></code></pre><ol start="5" type="1"><li>求解</li></ol><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 指定优化器</span>m<span class="token punctuation">.</span>options<span class="token punctuation">.</span>IMODE <span class="token operator">=</span> <span class="token number">3</span><span class="token comment"># 求解</span>m<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>disp<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment"># Solve</span><span class="token comment"># 输出结果</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'x1 = '</span><span class="token punctuation">,</span> x1<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'x2 = '</span><span class="token punctuation">,</span> x2<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'x3 = '</span><span class="token punctuation">,</span> x3<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'x4 = '</span><span class="token punctuation">,</span> x4<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Objective: '</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>options<span class="token punctuation">.</span>objfcnval<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;摸鱼，等崛起的神威太刀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B3%A1%E5%A3%B6%E9%BE%99%E5%A4%AA%E5%88%80.jpg&quot; alt=&quot;89249011_p1_master1200&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学建模" scheme="http://lapras.xyz/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python" scheme="http://lapras.xyz/tags/Python/"/>
    
    <category term="数学" scheme="http://lapras.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（二）</title>
    <link href="http://lapras.xyz/2022/06/25/6ba75aa8.html"/>
    <id>http://lapras.xyz/2022/06/25/6ba75aa8.html</id>
    <published>2022-06-25T14:01:07.000Z</published>
    <updated>2022-08-21T07:21:56.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>今日 KEEP <del> KFC </del></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%B1%B3%E5%B1%B1%E8%88%9E-eva.jpeg" alt="米山舞 eva" style="zoom:80%;" / loading="lazy"></p><span id="more"></span><h2 id="总线的基本概念">总线的基本概念</h2><blockquote><p><strong>总线</strong>（Bus）是指计算机组件间规范化的交换数据的方式，即以一种通用的方式为各组件提供数据传送和控制逻辑。从另一个角度来看，如果说 <a href="https://zh.wikipedia.org/wiki/主機板">主板</a>（Mother Board）是一座城市，那么总线就像是城市里的公共汽车（bus），能按照固定行车路线，传输来回不停运作的 <a href="https://zh.wikipedia.org/wiki/位元">比特</a>（bit）。这些线路在同一时间内都仅能负责传输一个比特。因此，必须同时采用多条线路才能发送更多资料，而总线可同时传输的资料数就称为宽度（width），以比特为单位，总线宽度愈大，传输性能就愈佳。总线的 <a href="https://zh.wikipedia.org/wiki/頻寬">带宽</a>（即单位时间内可以传输的总资料数）为：总线带宽 = 频率×宽度（Bytes/sec）</p></blockquote><h3 id="为什么使用总线">为什么使用总线</h3><table><thead><tr class="header"><th>连接方式</th><th>硬件资源</th><th>可扩展性</th></tr></thead><tbody><tr class="odd"><td>两两单独连接</td><td>占用引脚多，连线复杂</td><td>需要现有设备提供与新设备之间的接口，扩展起来麻烦</td></tr><tr class="even"><td>总线式连接</td><td>占用引脚少，连线简单</td><td>只需将新设备挂到总线，扩展方便</td></tr></tbody></table><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BA%BF.png" alt="为什么要使用总线" / loading="lazy"><figcaption aria-hidden="true">为什么要使用总线</figcaption></figure><h3 id="总线上信息的传输">总线上信息的传输</h3><p>首先，<strong>在任意时刻一条总线只能有一对部件进行信息传输</strong></p><p>总线信息传输方式可以分为 <strong>串行传输</strong> 和 <strong>并行传输</strong>，字面意思来看，串行就是数据是一位一位的发送 <strong>，</strong> 并行就是数据一组一组的发送。以直觉来看，并行应该是比串行传输速率高的，但事实上现在大部分的芯片都选择串行传输</p><blockquote><p><strong>并行总线由于是多个数据同时传输，需要考虑数据的协同性，这就导致了并行传输的频率不能做的很高</strong>。相对的，串行总线只有一条链路，就可以把频率做的很高，提高传输速度，速度提高了就能够弥补一次只能传输一个数据的缺陷。</p><p>此外，<strong>并行总线两根相邻的链路其数据是同时传输的</strong>，这就会导致它们彼此之间会产生 <strong>严重干扰</strong>，并行的链路越多，干扰越强。因此并行总线需要加强抗干扰的能力，否则传输过程中数据就可能被损坏。如果传输过程中数据故障了，就需要重新对齐数据再传输。而串行总线如果一个数据出错了，只需要重新传输一次就好了，由于串行总线频率高，很快就可以把错误数据重新传输过去。</p><p>再次，由于 <strong>并行总线是多链路一块传输数据</strong>，就需要很多线，接口需要很多针脚，老式计算机里的并行接口做得很大，接线比较宽，针脚非常多。这样一来装机也很麻烦，因为走线不方便、接口体积很大。</p></blockquote><h2 id="总线的分类">总线的分类</h2><h3 id="根据总线位置进行分类">根据总线位置进行分类</h3><ol type="1"><li>片内总线：芯片内部的总线</li><li>系统总线：计算机各部件的信息传输<ol type="1"><li>数据总线：双向，与机器字长、存储字长相关</li><li>地址总线：单向，与存储地址、I/O 地址相关</li><li>控制总线：<ul><li>有出：中断请求、总线请求</li><li>存储器读、存储器写、总线使用权许可、中断确认</li></ul></li></ol></li><li>通信总线：用于 计算机系统之间 或 计算机系统 与 其他系统。<ol type="1"><li>串行传输</li><li>并行传输</li></ol></li></ol><h2 id="总线特性及性能指标">总线特性及性能指标</h2><h3 id="总线特性">总线特性</h3><table><thead><tr class="header"><th>特性分类</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>机械特性</td><td>尺寸、形状、引脚数、引脚的排列顺序等</td></tr><tr class="even"><td>电气特性</td><td>传输方向、有效电平范围等</td></tr><tr class="odd"><td>功能特性</td><td>每根线的功能，如地址、数据、控制等</td></tr><tr class="even"><td>时间特性</td><td>时钟频率、信号的时序关系等</td></tr></tbody></table><h3 id="性能指标">性能指标</h3><ol type="1"><li>总线宽度：数据线的根数，根数越多，同时传输的位数就越多</li><li>标准传输率：每秒传输的最大字节数（MBps）</li><li>时钟类型：同步、不同步</li><li>总线复用：地址线和数据线 <strong>复用</strong>，以减少芯片的管脚数</li><li>信号线数：地址线、数据线和控制线的总和</li><li>总线控制方式：突发、自动、仲裁、逻辑、计数</li><li>其他指标：负载能力</li></ol><h3 id="总线标准">总线标准</h3><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86.png" alt="image-20220627192109975" / loading="lazy"><figcaption aria-hidden="true">image-20220627192109975</figcaption></figure><p>顺便一提，现代总线比如雷电 4 标准已经到 40 Gbps，所以总线标准也是计算机的性能瓶颈之一。</p><h2 id="总线结构">总线结构</h2><h3 id="单总线结构">单总线结构</h3><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="单总线结构" / loading="lazy"><figcaption aria-hidden="true">单总线结构</figcaption></figure><ul><li>存在主线争用问题</li><li>时间延迟高</li></ul><h3 id="多总线结构">多总线结构</h3><ol type="1"><li><p>面向 CPU 的双总线结构</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%9D%A2%E5%90%91CPU%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="面向 CPU 的双总线结构" / loading="lazy"><figcaption aria-hidden="true">面向 CPU 的双总线结构</figcaption></figure><ul><li>考虑到 <strong>指令</strong> 和 <strong>数据</strong> 都来自主存，所以用单独的 M 总线保证其交换速度</li><li>假设主存要与 I/O 设备信息传输，就不得不经过 CPU，会打乱 CPU 的信息交换任务</li></ul></li><li><p>面向存储器的双总线结构</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%9D%A2%E5%90%91%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="面向存储器的双总线结构" / loading="lazy"><figcaption aria-hidden="true">面向存储器的双总线结构</figcaption></figure><ul><li>从主存发出两条总线：存储总线和系统总线</li><li>CPU 和主存也保留了专用总线</li><li>CPU 也可以直接与 I/O 设备交互</li><li>目前还不能做到主存同时使用两根总线</li></ul></li><li><p>使用通道</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%80%9A%E9%81%93%E5%8F%8C%E4%B8%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="通道双主线" / loading="lazy"><figcaption aria-hidden="true">通道双主线</figcaption></figure><ul><li>一般来说通道有自己的控制器，指令等</li></ul></li><li><p>三总线结构</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="三总线结构" / loading="lazy"><figcaption aria-hidden="true">三总线结构</figcaption></figure><ul><li>在面向 CPU 的双总线结构上，将 I/O 设备分为高速和低速</li><li>将高速设备通过新的 DMA 总线与内存进行直接地信息交换</li></ul></li><li><p>三总线结构-2</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%842" alt="三总线结构 2" / loading="lazy"><figcaption aria-hidden="true">三总线结构 2</figcaption></figure><ul><li>由于内存的进步较于 CPU 缓慢，容易成为计算机的瓶颈点。所以使用 Cache 对内存中常用的指令预先读取，然后单独与 CPU 连接一条局部总线</li><li>系统总线通过一个扩展总线接口连接扩展总线，但这样会影响外部设备的传输速率</li></ul></li><li><p>四总线结构</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9B%9B%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="四总线结构" / loading="lazy"><figcaption aria-hidden="true">四总线结构</figcaption></figure><ul><li>在三总线-2 的基础上将外设分为高速和低速</li></ul></li></ol><h2 id="总线控制">总线控制</h2><p>总线控制主要解决两个问题：多设备同时申请使用总线的判定（总线判优控制/仲裁）和设备占用总线中保证通讯的正确性（总线通信控制）</p><h3 id="总线判优控制">总线判优控制</h3><p>根据组件在总线中的功能可以分为总设备（模块）和从设备（模块）</p><p>主设备：对总线有控制权，可以发出占用总线的申请</p><p>从设备：没有控制权，只能响应主设备发出的申请</p><p>集中式仲裁：把总线的判优逻辑放在一个部件中，根据查询方式不同，又可以分为：<strong>链式查询、计数器定时查询和独立请求方式</strong></p><p>分布式仲裁：总线的仲裁逻辑分散在与总线连接的各主设备上。典型的例子有 <strong>以太网</strong>，以太网上接入的各台计算机都可以发起通信，为避免无序竞争，它们都需要遵循以太网的仲裁逻辑，即 <strong>载波侦听/冲突检测</strong>。</p><h4 id="链式查询">链式查询</h4><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2.png" alt="链式查询" / loading="lazy"><figcaption aria-hidden="true">链式查询</figcaption></figure><ul><li><p>地址线：从设备查找</p></li><li><p>数据线：数据传输</p></li><li><p>BR 总线：各接口向总线控制部件提出占用请求</p></li><li><p>BG 总线：总线控制部件 <strong>链式地</strong> 查询哪个 I/O 接口提出了占用请求（碰到就停止查询）</p></li><li><p>BS 总线：获得总线使用权的接口利用 BR 总线向总线控制部件，发送一个总线忙碌状态以应答</p></li><li><p>链式查询的顺序就是设备的优先级顺序</p></li><li><p>优点：结构简单，算法简单，增删设备容易</p></li><li><p>缺点：BG 对电路故障特别敏感，速度较慢</p></li></ul><h4 id="计数器定时查询">计数器定时查询</h4><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2.png" alt="计时器定时查询" / loading="lazy"><figcaption aria-hidden="true">计时器定时查询</figcaption></figure><ul><li>设备地址线：由总线控制部件的 <strong>计数器</strong> 发出信号，通过这个地址来查找某个设备是否发出总线请求</li><li>计数器：各接口向总线控制部件通过 BR 提出占用请求。控制器接受到请求并成功通过后就会启动计数器（初值为 0 或者某个地址），计数器的值通过设备地址线向外输出，查询接口为初值的 I/O 接口。如果没有提出，则计数器++后重复查询，直到找到提出的 I/O 接口，并用 BR 进行应答。</li><li>优点：优先级是优先级较为灵活，比如通过软件的方式设定初值，那么优先级也就随之改变了</li></ul><h4 id="独立请求方式">独立请求方式</h4><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png" alt="独立请求方式" / loading="lazy"><figcaption aria-hidden="true">独立请求方式</figcaption></figure><ul><li>任何一个 I/O 接口都增加了两条线 BR BG</li><li>排队器：通过软件的方式在总线控制部件中动态地调整优先级</li><li>缺点：连接复杂</li></ul><h3 id="总线通信控制">总线通信控制</h3><p>总线传输周期：完成一次传输需要的时间</p><ul><li>申请分配：判优问题</li><li>寻址阶段：主设备向从设备给出地址和命令</li><li>传输阶段：主设备和从设备交换数据</li><li>结束阶段：主设备撤销相关信息</li></ul><p>方式：</p><table><thead><tr class="header"><th>通信方式</th><th>特点</th></tr></thead><tbody><tr class="odd"><td>同步通信</td><td>统一定宽定距的时标控制数据传输</td></tr><tr class="even"><td>异步通信</td><td>无统一时标，采用应答方式。主设备发出请求（命令），从设备应答，进而完成数据交换</td></tr><tr class="odd"><td>半同步通信</td><td>引入等待信号，解决不同速度的两个设备之间的通讯，同步异步结合</td></tr><tr class="even"><td>分离式通信</td><td>不在等待时占据总线，提高总线通信的效率</td></tr></tbody></table><h4 id="同步通信">同步通信</h4><ol type="1"><li>同步通信输入</li></ol><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1.png" alt="同步通信" / loading="lazy"><figcaption aria-hidden="true">同步通信</figcaption></figure><ul><li>假设一次数据传输使用了四个时钟周期</li><li><span class="math inline">\(T_1\)</span> 的上升沿之前：主设备发出地址信号并持续</li><li><span class="math inline">\(T_2\)</span> 的上升沿之前：给出读命令</li><li><span class="math inline">\(T_3\)</span> 的上升沿之前：从设备需要将需要数据发送到数据线上</li><li><span class="math inline">\(T_4\)</span> 的上升沿之前：撤销数据、撤销读命令</li><li><span class="math inline">\(T_4\)</span> 结束之前：撤销地址</li></ul><ol start="2" type="1"><li><p>同步通信输出</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E8%BE%93%E5%87%BA.png" alt="image-20220627210825638" / loading="lazy"><figcaption aria-hidden="true">image-20220627210825638</figcaption></figure><ul><li>假设一次数据传输使用了四个时钟周期</li><li><span class="math inline">\(T_1\)</span> 的上升沿之前：主设备发出地址信号并持续</li><li><span class="math inline">\(T_1\)</span> 的下降沿之前：给出数据到数据线上</li><li><span class="math inline">\(T_2\)</span> 的上升沿之前：给出写命令</li><li><span class="math inline">\(T_4\)</span> 的上升沿之前：撤销数据、撤销写命令</li><li><span class="math inline">\(T_4\)</span> 结束之前：撤销地址</li></ul></li></ol><p>同步通讯特点：需要选择最慢的设备（模块）作为统一通讯的时标，所以通常应用于总线长度短（长度越长频率越低）且各个模块存取时间较为一致。</p><h4 id="异步通讯">异步通讯</h4><p>异步通讯中根据应答信号是否互锁，即请求和回答信号的建立和撤消是否互相依赖，异步通讯可分为三种类型：非 <strong>互锁通讯、半互锁通讯和全互锁通讯</strong>。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF.png" alt="异步通讯" / loading="lazy"><figcaption aria-hidden="true">异步通讯</figcaption></figure><ul><li>锁：可以简单理解为状态锁，即保持发送请求这个状态。</li><li>不互锁：主设备发出请求信号，经过一段时间（主设备觉得从设备差不多收到）后，就撤销请求信号。从设备同理，接收到请求信号后，经过一段时间，撤销响应信号。<strong>即主设备主观、从设备主观</strong></li><li>半互锁：主设备发出请求信号，直到从设备发出应答信号后才能撤销。而从设备无需等待主设备发出撤销信号，经过一段时间后，撤销响应信号。<strong>即主设备客观、从设备主观</strong></li><li>全互锁：主设备发出请求信号，直到从设备发出应答信号后才能撤销。从设备发出响应信号，知道主设备发出撤销信号后才能撤销响应信号。<strong>即主设备客观、从设备客观</strong></li><li>显然互锁方式不同，传输的速率和可靠程度亦不同</li></ul><h4 id="半同步通信">半同步通信</h4><p>同步特点：发送方用系统时钟前沿 <strong>发信号</strong>，接收方用系统时钟后沿 <strong>判断、识别</strong></p><p>异步特点：允许不同速度的模块一同工作，增加了一条“等待”响应信号 <span class="math inline">\(\overline {WAIT}\)</span></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png" alt="半同步通信读取" / loading="lazy"><figcaption aria-hidden="true">半同步通信读取</figcaption></figure><ul><li><span class="math inline">\(T_1\)</span> 的上升沿之前：主设备发出地址信号并持续</li><li><span class="math inline">\(T_2\)</span> 的上升沿之前：给出读命令</li><li><span class="math inline">\(T_3\)</span> 的上升沿之前：如果从设备无法准备好数据，则给出 <span class="math inline">\(\overline {WAIT}\)</span> 告知 CPU 进行等待，CPU 会插入 <span class="math inline">\(T_w\)</span> 时钟周期。直到某次检测 <span class="math inline">\(WAIT\)</span> 信号为 1，则进入 <span class="math inline">\(T_3\)</span></li><li><span class="math inline">\(T_4\)</span> 的上升沿之前：撤销读命令、撤销数据</li><li><span class="math inline">\(T_4\)</span> 的上升沿之前：撤销地址</li></ul><h4 id="分离式通信">分离式通信</h4><p>上述三种通信控制方式，准备数据的时候总线都没有被占用，这就造成了浪费。于是乎，我们将一个完整的总线传输周期分为两个小周期，<strong>放弃等待数据这段时间的总线占用</strong>。那么这么判断何时从设备准备好数据了呢？所以在分离式通信中，<strong>每个设备都能作为主设备发出请求信号</strong>，这样从设备就能正常地提供数据以继续流程。</p><ol type="1"><li><p>主设备 发出地址和命令占用总线，使用完后主设备放弃总线，从设备进行准备。</p></li><li><p>如果 从设备 准备好数据，<strong>从设备会化身为主设备</strong> 向总线发出请求</p></li></ol><p>特点：</p><ol type="1"><li>各模块均有权有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li><strong>准备数据时不占用总线</strong></li><li>总线被占用时，无空闲</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;今日 KEEP &lt;del&gt; KFC &lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%B1%B3%E5%B1%B1%E8%88%9E-eva.jpeg&quot; alt=&quot;米山舞 eva&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（一）</title>
    <link href="http://lapras.xyz/2022/06/25/5bb1b670.html"/>
    <id>http://lapras.xyz/2022/06/25/5bb1b670.html</id>
    <published>2022-06-25T09:36:13.000Z</published>
    <updated>2022-08-21T07:21:56.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>暑假正式开始，开（huan）坑（zhai）计组。笔记会同步更新于 <a href="https://github.com/Anduin9527/CS-Professional-Notes-of-NJUPT">我的 Github 笔记仓库</a></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625173242.webp" alt="img" style="zoom:67%;" / loading="lazy"></p><span id="more"></span><h2 id="计算机系统简介">计算机系统简介</h2><h3 id="计算机软硬件概念">计算机软硬件概念</h3><p>计算机系统</p><ol type="1"><li>硬件：计算机的实体：如主机、外设</li><li>软件：具有各类特殊功能的信息（程序）组成<ol type="1"><li>系统软件：用来管理整个计算机系统<ol type="1"><li>语言处理程序（编译、链接）</li><li>操作系统</li><li>服务性程序</li><li>数据库管理系统</li><li>网络软件</li></ol></li><li>应用软件：按任务需要编写的程序</li></ol></li></ol><h3 id="计算机系统的层次结构">计算机系统的层次结构</h3><ol type="1"><li><p>物理结构抽象</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625092903.png" alt="image-20220625092855877" / loading="lazy"><figcaption aria-hidden="true">image-20220625092855877</figcaption></figure><p>自底向上地来看：</p><ol type="1"><li>Physics 物理抽象，电子设备依靠电子的移动进行工作。可以使用 量子 机制，和麦克斯韦方程进行描述。</li><li>Devices 电子元件，利用电子在不同物质中的移动特征来构建不同的电子元件，其具有不同的电压电流特征用以描述。</li><li>Analog Circuits 模拟电路，利用基本的电子元件构建放大器，滤波器等部件。</li><li>Digital Circuits 数字电路，利用模拟电路层进一步构建与非门等。</li><li>Logic 逻辑层，利用数字电路进行加法器和存储器的实现。</li><li>Microarchitecture 微体系(架构)结构层，具有执行单元和控制单元</li></ol></li><li><p>程序员角度</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625094958.png" alt="image-20220625094958199" / loading="lazy"><figcaption aria-hidden="true">image-20220625094958199</figcaption></figure></li></ol><h2 id="计算机的基本组成">计算机的基本组成</h2><h3 id="冯诺依曼计算机的特点">冯·诺依曼计算机的特点</h3><ol type="1"><li>计算机由五大部件（运算器、控制器、存储器、输入设备和输出设备）组成</li><li>指令和数据以同等地位 <strong>存于存储器</strong>，可按地址寻访</li><li>指令和数据用二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序（核心特征）</li><li>以运算器为中心</li></ol><h3 id="冯诺依曼计算机的硬件图">冯·诺依曼计算机的硬件图</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625101051.png" alt="image-20220625101051177" style="zoom:80%;" / loading="lazy"></p><ul><li>实线表示数据通路</li><li>虚线表示控制和状态反馈</li><li>运算器：核心，算术运算与逻辑运算</li><li>存储器：存放数据和程序</li><li>控制器：指挥控制程序的运行</li><li>输入设备：将信息转化为机器能识别的形式</li><li>输出设备：将结果转化为人能识别的形式</li></ul><h3 id="冯诺依曼计算机的结构改进">冯·诺依曼计算机的结构改进</h3><p>以存储器为中心的计算机硬件框图</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625101628.png" alt="image-20220625101628906" / loading="lazy"><figcaption aria-hidden="true">image-20220625101628906</figcaption></figure><p>其中，运算器（ALU）和控制器（CU）可以组成 CPU 。存储器可以进一步分为主存和辅存。主存和 CPU 可以进一步构成主机。输入设备和输出设备统称为 I/O 设备，主机和 I/O 设备统称为硬件。则给出</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625103446.png" alt="image-20220625103446906" style="zoom:80%;" / loading="lazy"></p><h3 id="系统复杂性管理的方法">系统复杂性管理的方法</h3><ol type="1"><li>层次化（Hierachy）：将被设计的系统划分为多个模块或子模块</li><li>模块化（Modularity）：有明确定义（well-defined）的功能和接口</li><li>规则性（regularity）：模块符合某些通用标准，使其更容易被重用</li></ol><h3 id="计算机的工作步骤">计算机的工作步骤</h3><ol type="1"><li>建立数学模型</li><li>确定计算方法</li><li>编写解题程序</li></ol><p>给例子：计算 <span class="math inline">\(a x^{2}+b x+c =(a x+b) x+c\)</span></p><ol type="1"><li><p>从问题来看需要 <strong>加法指令</strong> 和 <strong>乘法指令</strong></p></li><li><p>还需要取出数字并放置到累加器中的 <strong>取数指令</strong>，和读取结果并放置到存储器中的 <strong>读取指令</strong></p></li><li><p>最后是显示或者打印的 <strong>打印指令</strong>，以及停机指令</p></li><li><p>计算</p><p>取 x 至运算器中 乘以 a 在运算器中 加 b 在运算器中 乘以 x 在运算器中 加 c 在运算器中</p></li></ol><h3 id="指令格式">指令格式</h3><p>都使用 16 位长度的指令由 6 位操作码和 8 位地址码构成，[] 表示在寄存器中保存的内容</p><ol type="1"><li><p>取数指令</p><p>取数 a，[a] –&gt; ACC</p><p>000001 0000001000，前六位表示取数指令，后十位表示地址 8</p></li><li><p>存数指令</p><p>存数 b，[ACC] –&gt; b</p></li><li><p>加法指令</p><p>加数 c，[ACC] + [c] –&gt; [ACC]</p></li><li><p>乘法指令</p><p>乘数 d，[ACC] * [d] –&gt; [ACC]</p></li><li><p>打印指令</p></li></ol><p><span class="math inline">\(\sigma\)</span> ，[ <span class="math inline">\(\sigma\)</span> ] –&gt; 打印机</p><ol start="6" type="1"><li>停机指令</li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625110202.png" alt="image-20220625110202631" style="zoom:67%;" / loading="lazy"></p><h3 id="存储器的基本组成">存储器的基本组成</h3><p>上面我们知道，<strong>指令</strong> 和 <strong>数据</strong> 都保存在存储器当中。<strong>存储器</strong> 的主要部分是 <strong>存储体，MAR，MDR</strong></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625161002.png" alt="image-20220625161002215" style="zoom:67%;" / loading="lazy"></p><ul><li><p><strong>存储体</strong> 又有若干 <strong>存储单元</strong> 构成，<strong>存储单元</strong> 又由若干 <strong>存储元件</strong>（0/1）构成。</p></li><li><p>存储单元：存放一串二进制代码，即 <strong>存储字</strong></p></li><li><p>存储字长：存储字的长度（位数）</p></li><li><p>存储单元 <strong>按照地址寻址</strong></p></li><li><p>MAR：存储器 <strong>地址寄存器</strong>，<strong>保存了存储单元的地址</strong>，MAR 的位数反映了存储单元的个数。<strong>即存储单元个数是 <span class="math inline">\(2^{n_{MAR}}\)</span> </strong>。</p></li><li><p>MDR：存储器 <strong>数据寄存器</strong>，MDR 的位数表示该存储器的 <strong>存储字长</strong>，即 <strong>存储字长是</strong> <span class="math inline">\(n_{MDR}\)</span></p></li><li><p>MAR 就像存储器的入口，其接受某个地址作为寻找请求。存储器找到后将其地址中的 <strong>内容</strong> 交给存储器出口 MDR</p></li></ul><h3 id="运算器的基本组成">运算器的基本组成</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625162012.png" alt="image-20220625162012087" style="zoom:80%;" / loading="lazy"></p><p>ALU：Arithmetic Logic Unit，<strong>算术逻辑运算单元</strong>，运算器中完成算术逻辑运算的逻辑部件</p><p>ACC：Accumulator，<strong>累加器</strong>，运算器中运算前存放操作数、运算后存放运算结果的寄存器</p><p>MQ：Multiplier-Quotient Register，<strong>乘商寄存器</strong>，乘法运算时存放乘数、除法时存放商的寄存器</p><p>X：此字母没有专指的缩写含义，可以用作任一部件名，在此表示操作数寄存器，即运算器中工作寄存器之一，用来 <strong>存放操作数</strong></p><p>例：加法操作过程，设加法指令操作码为 000001，加数的地址为 M</p><ol type="1"><li>初态：ACC 中已经存放好了被加数</li><li>[M] –&gt; X</li><li>[ACC] + [X] –&gt; ACC</li></ol><p>例 2：减法操作过程，设减法指令操作码为 000010，减数的地址为 M</p><ol type="1"><li>初态：ACC 中已经存放好了被减数</li><li>[M] –&gt; X</li><li>[ACC] - [X] –&gt; ACC</li></ol><p>例 3：乘法操作过程，设乘法指令操作码为 000011，乘数的地址为 M</p><ol type="1"><li>初态：ACC 中已经存放好了被乘数</li><li>[M] –&gt; MQ</li><li>[ACC] –&gt; X</li><li>0 –&gt; ACC</li><li>[ACC] * [X] –&gt; ACC//MQ</li></ol><p>例 4：除法操作过程，设触发指令操作码为 000111，除数的地址为 M</p><ol type="1"><li>初态：ACC 中已经存放好了被除数</li><li>[M] –&gt; X</li><li>[ACC] / [X] –&gt; MQ，余数在 ACC 中</li></ol><h3 id="控制器的基本组成">控制器的基本组成</h3><p>控制器由 PC、IR 与 CU 组成</p><p>控制器用以解释指令并保证指令按照正确的次序执行，下面来看完成一条指令需要三个大步骤：</p><ol type="1"><li>取指令，<strong>PC（程序计数器）</strong> 存放当前欲执行指令的地址， 具有计数功能：（PC）+ 1 –&gt; PC</li><li>分析指令，<strong>IR（指令寄存器）</strong> 存放当前欲执行的指令</li><li>执行指令，<strong>CU</strong></li></ol><p>例：完成一条 <strong>取数指令</strong> 的过程</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625165601.png" alt="image-20220625165601107" style="zoom:80%;" / loading="lazy"></p><ol type="1"><li>取指令<ol type="1"><li>PC 把指令的地址给 MAR</li><li>MAR 在控制器的控制之下，根据地址寻找指定的存储单元</li><li>存储体把指定的存储单元中的指令取出送入 MDR</li><li>MDR 取出的指令送入 IR</li></ol></li><li>分析指令<ol type="1"><li>IR 中的操作码部分送给 CU，由 CU 根据指令开始执行操作</li></ol></li><li>执行指令<ol type="1"><li>IR 中的地址码部分送给 MAR</li><li>MAR 在控制器的控制之下，根据地址寻找指定的存储单元</li><li>存储体把指定的存储单元中的数据取出送入 MDR</li><li>MDR 取出的数据送入 ACC，取数完毕</li></ol></li></ol><h3 id="总结">总结</h3><ol type="1"><li>将程序通过输入设备送至计算机</li><li>程序首地址 –&gt; PC</li><li>启动程序运行</li><li>取指令 PC → MAR → M → MDR → IR，(PC)+1 → PC</li><li>分析指令 OP(IR)→ CU</li><li>执行指令 AD(IR)→ MAR → M → MDR → ACC</li><li>……</li><li>打印结果</li><li>停机</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;暑假正式开始，开（huan）坑（zhai）计组。笔记会同步更新于 &lt;a href=&quot;https://github.com/Anduin9527/CS-Professional-Notes-of-NJUPT&quot;&gt;我的 Github 笔记仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625173242.webp&quot; alt=&quot;img&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>SPSS 基础应用与聚类分析</title>
    <link href="http://lapras.xyz/2022/06/23/aef9302d.html"/>
    <id>http://lapras.xyz/2022/06/23/aef9302d.html</id>
    <published>2022-06-22T16:49:42.000Z</published>
    <updated>2022-08-21T07:21:56.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>6 月 23 日、『Honkai Impact 3』の新メインライン発売まで 10 時間、『Rise of SunBreak』の発売まで 7 日です。 もう我慢できない！ テレビゲームがしたい！</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220623010515.png" alt="image-20220623010515152" / loading="lazy"><figcaption aria-hidden="true">image-20220623010515152</figcaption></figure><span id="more"></span><h2 id="标准化数据">标准化数据</h2><blockquote><p>​ 大型数据分析项目中，数据来源不同，量纲及量纲单位不同，为了让它们具备可比性，需要采用标准化方法消除由此带来的偏差。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。这就是数据标准化。</p><p><strong>基本原理</strong>：z-score 标准化。数值减去平均值，再除以其标准差，得到 <strong>均值为 0，标准差为 1</strong> 的服从 <strong>标准正态分布</strong> 的数据。</p></blockquote><ol type="1"><li>分析 <span class="math inline">\(\rightarrow\)</span> 描述统计 <span class="math inline">\(\rightarrow\)</span> 描述</li><li>将标准化值另存为变量（Z）</li></ol><h2 id="归一化数据">归一化数据</h2><blockquote><p>主要是为了数据处理方便提出来的，把数据映射到 0～1 范围之内处理，把有量纲表达式变为无量纲表达式。</p></blockquote><ol type="1"><li><p>分析 <span class="math inline">\(\rightarrow\)</span> 描述统计 <span class="math inline">\(\rightarrow\)</span> 描述</p></li><li><p>选项 <span class="math inline">\(\rightarrow\)</span> 最小值、最大值</p></li><li><p>转换 <span class="math inline">\(\rightarrow\)</span> 计算变量 <span class="math display">\[x^* = \frac{x-min}{max-min}\]</span></p></li></ol><h2 id="聚类分析">聚类分析</h2><blockquote><p>聚类分析是一种探索性分析方法，与判别分析不同，<strong>聚类分析事先并不知道分类的标准，甚至不知道应该分成几类，</strong> 而是会根据样本数据的特征，自动进行分类。严格说来聚类分析并不是纯粹的统计技术，它不像其它多元分析法那样，需要从样本去推断总体。一般都涉及不到有关统计量的分布，也不需要进行显著性检验。假定研究对象均用所谓的“点”来表示。 在聚类分析中，一般的规则是将“距离”较 小的点归为同一类，将“距离”较大的点归为不同的类。 常见的是对个案分类，也可以对变量分类， 但对于变量分类此时一般使用相似系数作为 “距离”测量指标。</p><p>目的：使属于同一类别的数据间的 相似性尽可能大，不同类别中的数据间的相似性尽可能小</p><p><strong>注意：</strong> 聚类分析更像是一种建立假设的方法，而对于相关假设的检验还需要借助其他统计的方法，比如判别分析、T-检验、方差分析等，看聚类出来的几个类别是否存在差异</p></blockquote><ul><li><p>从统计学的观点看，聚类分析是通过数据建模简化数据的一种方法。</p></li><li><p>从机器学习的角度看，簇相当于隐藏模式。聚类是搜索簇的无监督学习过程。</p></li><li><p>从实际应用的角度看，聚类分析是数据预处理（降维）和信息挖掘的主要任务之一。</p></li></ul><p>常规步骤：</p><ol type="1"><li>选择聚类指标（经验、主成分分析、因子分析）</li><li>数据标准化处理（K-means 需要预处理，其余 SPSS 集成）</li><li>选择聚类方法：样本容量，变量类型</li><li>确定分类个数</li><li>进行结果解读</li></ol><h2 id="k-均值聚类k-means-cluster">K 均值聚类（K-means Cluster）</h2><ul><li><p>聚类对象：个案（Q 型聚类分析）</p></li><li><p>变量类型：连续变量</p></li><li><p>分类数：固定</p></li><li><p>样本容量：大样本</p></li></ul><h3 id="流程">流程</h3><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TB选择若干聚类中心 <span class="token arrow operator">----></span> 依据与聚类中心的距离划分出初始分类依据与聚类中心的距离划分出初始分类 <span class="token arrow operator">----></span> 计算出各个分类的中心位置计算出各个分类的中心位置 <span class="token arrow operator">----></span> A<span class="token text string">&#123;用计算出的中心位置重新进行聚类&#125;</span>A <span class="token arrow operator">----></span> 计算出各个分类的中心位置A <span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">聚类中心收敛</span><span class="token arrow operator">--></span></span> END</code></pre><p>整个 K-means 是一个自平衡的过程，其不断划分类别，然后用某些规则（比如重心）计算聚类中心，再重新根据聚类中心划分类别，如此不断迭代，直到某次循环结果与上次一致或者达到迭代上限。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622224606.gif" alt="img" / loading="lazy"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="优缺点">优缺点</h3><p>优点：</p><ol type="1"><li>原理比较简单，实现也很容易，<strong>收敛速度快</strong>。</li><li>在对大规模数据集进行聚类分析时，算法聚类较高效且聚类效果较好。</li><li>簇与簇之间区别明显时，它的聚类效果很好。</li></ol><p>缺点：</p><ol type="1"><li>分类数从 <strong>初始分类开始就确定不变</strong> 了，所以要求事先要对样本有足够的了解。</li><li>仅限于 <strong>个案间的聚类</strong>（Q 型聚类）, 不能对变量进行聚类。</li><li>个案间的距离的测量方法使用的是 <strong>欧式距离的平方</strong>，因此只能对连续变量进行聚类。</li></ol><h3 id="spss-过程">SPSS 过程</h3><ol type="1"><li>对变量进行标准化处理</li><li>分析 <span class="math inline">\(\rightarrow\)</span> 分类 <span class="math inline">\(\rightarrow\)</span> k 均值聚类</li><li>选择个案变量（比如 ID），其余变量放置于变量，设置聚类数。</li><li>迭代 <span class="math inline">\(\rightarrow\)</span> 默认迭代十次</li><li>保存 <span class="math inline">\(\rightarrow\)</span> 聚类成员</li><li>统计 <span class="math inline">\(\rightarrow\)</span> 初始聚类中心，ANOVA，每个个案的聚类信息</li><li>结果分析<ol type="1"><li>初始聚类中心、最终聚类中心和迭代历史记录（若不收敛调整迭代次数）</li><li>ANOVA：<strong>聚类均方</strong> 对应组间均方差，<strong>误差均方</strong> 对应组内均方差，显著性 p &lt; 0.05 且<strong>组间均方差大于组内均方差</strong>时说明此变量组别之间差异明显，分类可信度较高。</li><li>聚类成员明细</li></ol></li><li>由于可能经过标准化处理，最后的结果是标准化的数值。如果要查看聚类中心原本的数值<ol type="1"><li>分析 <span class="math inline">\(\rightarrow\)</span> 比较均值 <span class="math inline">\(\rightarrow\)</span> 均值</li><li>选择标准化前的变量作为因变量，案例的类别号作为自变量</li><li>选项 <span class="math inline">\(\rightarrow\)</span> 单元格统计量只要均值</li></ol></li></ol><h2 id="系统聚类分层聚类">系统聚类（分层聚类）</h2><ul><li><p>聚类对象：个案或变量</p></li><li><p>变量类型：连续变量或分类变量</p></li><li><p>分类数：固定或指定范围</p></li><li><p>样本容量：中小样本</p></li></ul><h3 id="流程-1">流程</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622233231.png" alt="image-20220622233231246" style="zoom:67%;" / loading="lazy"></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622233846.gif" alt="6-what-is-clustering" / loading="lazy"><figcaption aria-hidden="true">6-what-is-clustering</figcaption></figure><h3 id="优缺点-1">优缺点</h3><p>优点：</p><ol type="1"><li>距离和规则的相似度容易定义，限制少。</li><li>既可对分类变量聚类，也可对连续变量聚类。</li><li>事先不需要确定要分多少类，系统会自动确定最佳分类数。</li></ol><p>缺点：</p><ol type="1"><li>运行较慢，适合样本容量较少</li><li>系统聚类分析时，每个个案一旦归为某一类就不允许再改变，但最初的分类可能不是最优的选择。</li></ol><h3 id="spss-过程-1">SPSS 过程</h3><ol type="1"><li>分析 <span class="math inline">\(\rightarrow\)</span> 分类 <span class="math inline">\(\rightarrow\)</span> 系统聚类</li><li>聚类可以选择个案（标注个案变量）或者变量</li><li>统计 <span class="math inline">\(\rightarrow\)</span> 集中计划，近似值矩阵</li><li>图 <span class="math inline">\(\rightarrow\)</span> 谱系图，取消冰柱图</li><li>方法 <span class="math inline">\(\rightarrow\)</span> 标准化：Z 得分（按变量）；聚类方法：一般而言组间联接是最好的，ward 法聚类出来会比较平均；度量标准：个案一般用平方欧式距离，变量一般用皮尔逊相关系数</li><li>结果分析</li></ol><h2 id="二阶聚类twostep-cluster">二阶聚类（TwoStep Cluster）</h2><ul><li><p>聚类对象：个案或变量</p></li><li><p>变量类型：连续变量和分类变量</p></li><li><p>分类数：自动确定</p></li><li><p>样本容量：大样本</p></li></ul><h3 id="优缺点-2">优缺点</h3><p>优点：</p><ol type="1"><li>能够 <strong>同时处理分类变量和连续变量</strong></li><li>可自动选择最优的分类个数</li><li>适用于大样本数据</li></ol><p>缺点：</p><ol type="1"><li>聚类结果主要受所选择的变量影响。如果去掉一些变量，或者增加一些变量，结果会很不同</li><li>分类变量应服从 <strong>多项分布</strong>，连续变量应服从 <strong>正态分布</strong>（但其实会自动剔除异常值）</li></ol><h3 id="spss-过程-2">SPSS 过程</h3><ol type="1"><li><p>检验正态分布（分类变量多项分布一般都是满足的）</p></li><li><p>检验共线性，去除无关变量</p></li><li><p>分析 <span class="math inline">\(\rightarrow\)</span> 分类 <span class="math inline">\(\rightarrow\)</span> 两步聚类</p></li><li><p>按照变量类型分开为分类变量和连续变量，剩余一个为个案变量</p></li><li><p>选项 <span class="math inline">\(\rightarrow\)</span> 连续变量标准化</p></li><li><p>输出 <span class="math inline">\(\rightarrow\)</span> 选择透视表；将个案变量作为判断字段；创建聚类成员变量</p></li><li><p>结果分析：</p><ol type="1"><li><p>自动聚类表：</p><blockquote><p>根据施瓦茨贝叶斯准则（BIC)帮助 <strong>判断最佳分类数量</strong>，从统计上分析，该数值越小聚类效果越好。但是实际中还要考虑 BIC 变化量、BIC 变化比率和距离测试比率，可以通过他们进一步确定最佳分类数。 判断标准：</p><ol type="1"><li>BIC 准则数值越小，聚类效果越好；</li><li>BIC 变化量数值越小，聚类效果越好；</li><li>距离测量比率数值越大，聚类效果越好。</li></ol></blockquote></li><li><p>聚类分布，质心：不同类的总体情况</p></li><li><p>模型概要：聚类质量图反映聚类效果的好坏，双击可进入详细模式，然后左下角查看 <span class="math inline">\(\rightarrow\)</span> 聚类，接着可以点击某些属性来 <strong>查看变量重要性</strong>，或者多选某些属性来查看 <strong>各类别对比</strong>。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220623003719.png" alt="image-20220623003719854" style="zoom: 80%;" / loading="lazy"></p></li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;6 月 23 日、『Honkai Impact 3』の新メインライン発売まで 10 時間、『Rise of SunBreak』の発売まで 7 日です。 もう我慢できない！ テレビゲームがしたい！&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220623010515.png&quot; alt=&quot;image-20220623010515152&quot; /&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20220623010515152&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    <category term="数学建模" scheme="http://lapras.xyz/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="数学" scheme="http://lapras.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="聚类分析" scheme="http://lapras.xyz/tags/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
    
    <category term="统计" scheme="http://lapras.xyz/tags/%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>SPSS 基础应用与回归分析</title>
    <link href="http://lapras.xyz/2022/06/22/56984c70.html"/>
    <id>http://lapras.xyz/2022/06/22/56984c70.html</id>
    <published>2022-06-22T06:41:26.000Z</published>
    <updated>2022-08-21T07:21:56.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>福州好热，暑假又要开模了呜呜呜我的 CS 呜呜呜。趁着训练前终于把打了一年的 MHW 煌黑龙和黑龙通了，芜湖~~</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622143315.png" alt="image-20220622143314890" / loading="lazy"><figcaption aria-hidden="true">image-20220622143314890</figcaption></figure><span id="more"></span><h2 id="描述性分析">描述性分析</h2><blockquote><p>描述性分析主要是对所收集的数据进行分析，得出反映客观现象和数量特征的一种分析方法，它主要包括数据的集中趋势分析、数据离散程度分析、数据的频数分布分析等，描述性分析是对数据进一步分析的基础。</p><ul><li>分类变量：说明事物的类别，其数据是不连续（指数值上）、互不相容的（指不会同时满足复数个类别）。比如：性别</li><li>连续变量：其数据是连续的。比如：年龄</li></ul></blockquote><h3 id="对分类变量进行频率分析">对分类变量进行频率分析</h3><blockquote><h1 id="注意-spss-中不支持中文数据所以使用数值型添加标签值的方式">注意 SPSS 中不支持中文数据，所以使用数值型+添加标签值的方式</h1></blockquote><ol type="1"><li>分析 <span class="math inline">\(\rightarrow\)</span> 描述统计 <span class="math inline">\(\rightarrow\)</span> 频率</li><li>选择对应的分类变量</li><li>图表 <span class="math inline">\(\rightarrow\)</span> 条形图生成</li></ol><h3 id="对连续变量进行频率分析">对连续变量进行频率分析</h3><ol type="1"><li>分析 <span class="math inline">\(\rightarrow\)</span> 描述统计 <span class="math inline">\(\rightarrow\)</span> 频率</li><li>选择对应的连续变量</li><li>统计 <span class="math inline">\(\rightarrow\)</span> 选择一些条目<ul><li>四分位数：输出这组数据的四等分点</li><li>分割点：输出这组数据的 n 等分点</li><li>百分位数：输出这组数据的指定百分比点</li><li>中位数、平均值、标准差、最小值、最大值</li></ul></li><li>图表 <span class="math inline">\(\rightarrow\)</span> 直方图 <span class="math inline">\(\rightarrow\)</span> 显示正态曲线</li></ol><h3 id="交叉表分析统计频率">交叉表分析统计频率</h3><blockquote><p>交叉表分析是用于分析两个或两个以上变量之间的关联关系，以交叉表格的形式进行分组变量间关系的对比分析。</p></blockquote><ol type="1"><li>分析 <span class="math inline">\(\rightarrow\)</span> 描述统计 <span class="math inline">\(\rightarrow\)</span> 频率</li><li>选择行（自变量）列数据（因变量）</li><li>格式 <span class="math inline">\(\rightarrow\)</span> 百分比选择列</li><li>可以选择簇状条形图</li></ol><h2 id="数据异常值检验">数据异常值检验</h2><ol type="1"><li>图形 <span class="math inline">\(\rightarrow\)</span> 箱图 <span class="math inline">\(\rightarrow\)</span> 简单，单独变量的摘要</li><li>箱表示：移入需要检测的变量</li><li>观察箱线图，除去异常值或将其设置为均值</li></ol><h2 id="数据正态分布检验">数据正态分布检验</h2><ol type="1"><li>分析 <span class="math inline">\(\rightarrow\)</span> 描述统计 <span class="math inline">\(\rightarrow\)</span> 探索</li><li>全部选入因变量列表，图 <span class="math inline">\(\rightarrow\)</span> 因子级别并置，茎叶图，含检验的正态图</li><li>观察变量的显著性 p 值</li></ol><h2 id="相关分析和独立性检验">相关分析和独立性检验</h2><blockquote><p>相关关系是指现象之间存在着非严格的、不确定的依存关系。这种依存关长系的特点是：某一现象在数量上发生变化会影响另一现象数量上的变化，而且这种变化在数量上具有一定的随机性。即当给定某一现象一数值时，另一现象会有若干个数值与之对应，并且总是遵循一定的规律， 围绕这些数值的平均数上下波动，其原因是影响现象发生变化的因素不止一个。</p><p>相关关系可分为线性相关和非线性相关，线性相关也称为直线相关，线性相关是最常用的一种，即当一 个连续变量发生变动时，另一个连续变量相应地呈线性 关系变动，用 <strong>皮尔逊（Pearson)相关系数</strong> 上来度量。</p><p><strong>皮尔逊相关系数</strong> 就是反映连续变量之间线性相关强度的一个度量指标，它的取值范围限于 [-1, 1]。 r 的正、负号可以反映相关的方向，当 r &gt; 0 时表示表示 线性正相关，当 r &lt; 0 时，线性负相关。 r 的大小可以反映相关的程度，r = 0 表示两个变量之间不存在线性关系。一般认为 0.3~0.8 为中度相关。</p><p>非线性相关某种意义来讲也就是曲线相关，一般不用相关系数度量其相关性。</p></blockquote><h3 id="相关分析">相关分析</h3><p>前提：两变量为 <strong>连续变量</strong>，两变量之间为 <strong>线性相关</strong>。数据服从正态分布且无异常值。</p><ol type="1"><li><p>绘制散点图大致判断是否为线性关系（图形 <span class="math inline">\(\rightarrow\)</span> 简单散点图）</p></li><li><p>计算相关系数（分析 <span class="math inline">\(\rightarrow\)</span> 相关 <span class="math inline">\(\rightarrow\)</span> 双变量）</p></li><li><p>显著性检验，即上一步中得到的 <span class="math inline">\(Sig.\)</span> 也就是所谓的 P 值</p><blockquote><p>P 值小于一般显著性水平（<strong>一般为 0.05</strong>）则认为变量间存在显著性相关关系，小于 0.01 则具有极其显著的相关关系。P 值大于一般显著性水平（一般为 0.05）则认为变量间不存在显著性相关关系。</p></blockquote></li></ol><h3 id="卡方独立性检验">卡方独立性检验</h3><p>前提：</p><ol type="1"><li><p>观测变量（因变量）是二分类变量（布尔变量）。</p></li><li><p>分组变量（自变量）的类别大等于 2。</p></li><li><p>抽样是独立的。</p></li><li><p>样本量足够大，最小的样本量要求分析中的任一单元 <strong>格期望频数大于 5</strong></p></li></ol><p>步骤：</p><ol type="1"><li>判断期望频数<ol type="1"><li>分析 <span class="math inline">\(\rightarrow\)</span> 描述统计 <span class="math inline">\(\rightarrow\)</span> 频率 <span class="math inline">\(\rightarrow\)</span> 交叉表</li><li>分组变量（自变量）放入行，观测变量（因变量）放入列</li><li>单元格 <span class="math inline">\(\rightarrow\)</span> 取消实测 <span class="math inline">\(\rightarrow\)</span> 选中期望</li><li>统计 <span class="math inline">\(\rightarrow\)</span> 选中卡方</li><li>观察输出的交叉表，发现每个单元格的数值都大于 5 即可、</li></ol></li><li>计算卡方值<ol type="1"><li>重复第 1 部分</li><li>单元格 <span class="math inline">\(\rightarrow\)</span> 取消期望 <span class="math inline">\(\rightarrow\)</span> 选中实测 <span class="math inline">\(\rightarrow\)</span> 列</li><li>组间比较（当分组变量类别大于 2 时可选）：单元格 <span class="math inline">\(\rightarrow\)</span> z 检验 <span class="math inline">\(\rightarrow\)</span> 调整 p 值</li><li>观察输出的卡方检验表，其中渐进显著性为 p 值</li><li>组间比较：观察输入的交叉表，其中计数会出现字母，字母不同表示该类别的差异具有统计学意义，反之则无。</li></ol></li></ol><h2 id="回归分析">回归分析</h2><div><p>graph LR 回归分析----&gt; 线性回归 线性回归----&gt; 一元线性回归 线性回归----&gt; 多元线性回归 回归分析----&gt; 非线性回归</p></div><p>联系：两者均为研究及测度两个或两个以上变量之间关系的方法。在实际工作中，一般先进行相关分析，计算相关系数，然后建立回归模型，最后用回归模型进行推算或预测。</p><p>区别：相关分析研究的都是随机变量，并且不分自变量与因变量，回归分析研究的变量要定义出自变量与因变量，并且自变量是确定的普通变量，因变量是随机变量。相关分析主要是描述两个变量之间相关关系的密切程度；回归分析不仅可以揭示变量 x 对变量 y 的影响程度，还可以根据回归模型进行预测。</p><h3 id="一元线性回归">一元线性回归</h3><blockquote><p>一元线性回归，就是回归模型中只含一个自变量，它主要用来处理一个自变量与一个因变量之间的线性关系。简单线性回归模型为： <span class="math inline">\(Y = a+bX+\varepsilon\)</span> ，使用的时 <strong>最小二乘法</strong> 式中： Y--因变量； X--自变量； a--常数项，是回归直线在纵坐标轴上的截距； b--回归系数，是回归直线的斜率； <span class="math inline">\(\varepsilon\)</span> --随机误差，即随机因素对因变量所产生的影响。</p></blockquote><p>前提：两变量为 <strong>连续变量</strong>，两变量之间存在线性关系</p><ol type="1"><li><p>根据预测目标确定因变量</p></li><li><p>绘制散点图确定回归模型</p></li><li><p>估计模型参数，建立线性回归模型</p><ol type="1"><li>回归 <span class="math inline">\(\rightarrow\)</span> 线性 <span class="math inline">\(\rightarrow\)</span> 选择变量</li><li>图 <span class="math inline">\(\rightarrow\)</span> Y：DEP，X：ZRE（标准化残差） <span class="math inline">\(\rightarrow\)</span> 直方图，正态概率图</li><li>保存 <span class="math inline">\(\rightarrow\)</span> 预测值：未标准化，残差：标准化，距离：库克，杠杆（显示异常点），预测区间：平均值，单值</li><li>选项：使用 F 的概率默认，在方程中包含常量</li></ol></li><li><p>对模型进行检验</p><ol type="1"><li><p>除去变量表（除去没有相关性的变量）</p></li><li><p>线性回归模型汇总表：观察调整后 R 方</p><blockquote><p>R 方：判定系数。 值为 0~1 之间，越接近 1, 预测值与观测值越接近。一般认为，<strong>R 方大于 0.75, 表示拟合程度很好</strong>，小于 0.5, 表示拟合有问题，不适合回归分析，R 方介两者之间说明拟合程度一般。</p></blockquote></li><li><p>方差分析表 ANOVA：观察显著性 p 值（通过 F 检验算出）</p></li><li><p>回归系数表：得到回归模型系数和常量，以及显著性 p 值（通过 t 检验算出）</p></li><li><p>观察残差直方图：因变量的残差值基本符合正态分布为好</p></li><li><p>观察残差正态 p-p 图：如果样本数据来自正态分布的话， 所有散点都应分布在对角线附近。说明样本数据比较正确。</p></li></ol></li></ol><h3 id="多元线性回归">多元线性回归</h3><p>前提：</p><ol type="1"><li>需要至少 2 个自变量，且自变量之间互相独立</li><li>因变量为为连续变量</li><li>数据具有 <strong>方差齐性、无异常值和正态分布</strong> 的特点</li><li>自变量间不存在多重共线性</li></ol><p>步骤：</p><ol type="1"><li><p>检验并去除异常值</p></li><li><p>检验是否为正态分布</p></li><li><p>检验方差齐性（莱文或者 ANOVA）</p><ol type="1"><li><p>分析 <span class="math inline">\(\rightarrow\)</span> 描述统计 <span class="math inline">\(\rightarrow\)</span> 探索</p></li><li><p>设置因变量为预测变量，因子列表为自变量</p></li><li><p>图 <span class="math inline">\(\rightarrow\)</span> 因子级别并置，茎叶图，莱文未转换</p></li><li><p>观察莱文方差齐性检验的显著性 p 值是否大于 0.05</p><blockquote><p>莱文检验原假设 <span class="math inline">\(H_0\)</span> ：各组方差相等，符合方差齐性</p></blockquote></li><li><p>分析 <span class="math inline">\(\rightarrow\)</span> 比较均值 <span class="math inline">\(\rightarrow\)</span> 单因素 ANOVA 检验</p></li><li><p>将预测变量设置为因变量，但需要注意的是，ANOVA 检验无法将名义变量设为因子</p></li><li><p>选项 <span class="math inline">\(\rightarrow\)</span> 方差齐性检验</p></li><li><p>观察方差齐性检验的显著性 p 值是否大于 0.05</p><blockquote><p>检验原假设 <span class="math inline">\(H_0\)</span> ：各组方差相等，符合方差齐性</p></blockquote></li></ol></li><li><p>检验多重共线性</p><ol type="1"><li><p>分析 <span class="math inline">\(\rightarrow\)</span> 回归 <span class="math inline">\(\rightarrow\)</span> 线性</p></li><li><p>输入自变量和因变量</p></li><li><p>统计 <span class="math inline">\(\rightarrow\)</span> 共线性诊断</p></li><li><p>关注系数表，当 <span class="math inline">\(VIF\)</span> 值大于等于 10 时，我们认为变量间存在严重的共线性。</p><p>当 <span class="math inline">\(VIF\)</span> 值小于 10 时，我们认为数据基本符合多元线性分析的假设，即不存在多重共线性问题。</p></li></ol></li><li><p>分析 <span class="math inline">\(\rightarrow\)</span> 回归 <span class="math inline">\(\rightarrow\)</span> 线性</p></li><li><p>填入自变量和因变量</p></li><li><p>统计</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622140830.jpeg" alt="img" / loading="lazy"><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>保存 <span class="math inline">\(\rightarrow\)</span> 预测值：未标准化，残差：学生化，学生化后删除，距离：库克，杠杆（显示异常点），包含协方差矩阵</p></li><li><p>对模型进行检验</p><ol type="1"><li>除去变量表（除去没有相关性的变量）</li><li>线性回归模型汇总表：观察调整后 R 方</li><li>方差分析表 ANOVA：观察显著性 p 值（通过 F 检验算出）</li><li>回归系数表：得到回归模型系数和常量，以及显著性 p 值（通过 t 检验算出），以及 VIF</li></ol></li><li><p>结果表述</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622143012.png" alt="image-20220622143012110" / loading="lazy"><figcaption aria-hidden="true">image-20220622143012110</figcaption></figure></li></ol><h3 id="多元线性逐步回归">多元线性逐步回归</h3><blockquote><p>逐步法结合向前法和向后法的优点，在向前引入每一个新自变量之后都要重新对已代入的自变量进行计算，以检验其有无继续保留在方程中的价值，并以此为依据进行自变量的引入和剔除交替进行，直到没有新的变量可以引入或剔除为止，此法较为准确。</p></blockquote><p>前提：同多元线性回归</p><ol type="1"><li><p>检验并去除异常值</p></li><li><p>检验是否为正态分布</p></li><li><p>检验方差齐性（莱文或者 ANOVA）</p></li><li><p>检验多重共线性</p></li><li><p>分析 <span class="math inline">\(\rightarrow\)</span> 回归 <span class="math inline">\(\rightarrow\)</span> 线性</p></li><li><p>填入自变量和因变量，方法选择步进</p></li><li><p>统计：估算值，模型拟合，共线性诊断，德斌沃森残差分析</p></li><li><p>保存：学生化，杠杆值，协方差矩阵</p></li><li><p>对模型进行检验</p><ol type="1"><li>残差统计表：在满足假设后，我们还需要依据残差统计表中的库克距离（cook 值）来判断数据有无强影响点，若库克距离的最大值大于 1，则应检查数据是否存在的异常值；若库克距离的最大值小于 1，则数据中不存在强影响点，可以进行下一步的分析。</li><li>模型纳入变量表：去除不重要的变量</li><li>模型摘要表：表下的注释可以看出逐步回归分析中每一步引入回归方程的自变量。观测调整后 R 方</li><li>ANOVA 表：此检验的零假设是多重相关系数 R = 0。如果 P &lt; 0.05，就说明多重线性回归模型中至少有一个自变量的系数不为零。同时，回归模型有统计学意义也说明相较于空模型，纳入自变量有助于预测因变量；或说明该模型优于空模型。</li><li>回归模型系数表：显著性检验结果，当 P &gt; 0.05 时，该自变量在本模型中没有统计学意义，应当在回归模型中删除相应变量；反之保留。</li></ol></li><li><p>表述</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622142941.png" alt="image-20220622142941884" / loading="lazy"><figcaption aria-hidden="true">image-20220622142941884</figcaption></figure></li></ol><h3 id="非线性回归">非线性回归</h3><ol type="1"><li>绘制散点图，大致确定关系</li><li>曲线估算<ol type="1"><li>分析 <span class="math inline">\(\rightarrow\)</span> 回归 <span class="math inline">\(\rightarrow\)</span> 曲线估算</li><li>填入因变量和独立（自变量）</li><li>选择可能的模型</li><li>观察模型和参数估计表，有 R 方和显著性 p 值，选择 R 方优越的模型</li><li>根据参数估计值得到曲线表达式</li></ol></li></ol><h2 id="参考">参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNzAxMDY5NQ==&amp;mid=2247483917&amp;idx=1&amp;sn=8c2358dbf63fa5785bc7a0d0e8937932&amp;chksm=f99fe665cee86f73a702f1552a3589d6934e5263031624964b640521c8de71bae94838eff632&amp;scene=178&amp;cur_album_id=1354525438097539072#rd">SPSS 多元线性回归分析</a></p><p><a href="https://www.bilibili.com/video/BV133411K7yd">2022 校赛赛前培训 SPSS 基础</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;福州好热，暑假又要开模了呜呜呜我的 CS 呜呜呜。趁着训练前终于把打了一年的 MHW 煌黑龙和黑龙通了，芜湖~~&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622143315.png&quot; alt=&quot;image-20220622143314890&quot; /&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20220622143314890&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    <category term="数学建模" scheme="http://lapras.xyz/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="回归" scheme="http://lapras.xyz/tags/%E5%9B%9E%E5%BD%92/"/>
    
    <category term="数学" scheme="http://lapras.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="SPSS" scheme="http://lapras.xyz/tags/SPSS/"/>
    
  </entry>
  
  <entry>
    <title>SSH 的二三事</title>
    <link href="http://lapras.xyz/2022/03/20/844ad6f8.html"/>
    <id>http://lapras.xyz/2022/03/20/844ad6f8.html</id>
    <published>2022-03-19T16:18:05.000Z</published>
    <updated>2022-08-21T07:21:56.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>来学校上了两周网课，两周线下，现在又要上网课了 G！上网课就算了，我还要给学弟上网课哈哈。整一波虚拟教师 V 出道</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220320002327.jpg" alt="63476067_p0_master1200" style="zoom: 67%;" / loading="lazy"></p><span id="more"></span><h2 id="什么是-ssh">什么是 SSH</h2><blockquote><p>SSH（Secure Shell 的缩写）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。</p><p>实际使用中，它主要用于保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。</p></blockquote><p>比如我们都知道的 Github 下载源代码有两种方式，HTTPS 和 一种形如 <code>git@github.com:username/repositoryname.git</code> 的连接，这其实就是一种 SSH 协议。</p><p>再比如我们要操作机房里的服务器，不可能给每一台服务器都配上键盘鼠标显示器，一般都是通过网络的方式远程访问一台服务器。就类似于 TeamViewer 的远程桌面。</p><h3 id="安装-ssh-服务">安装 SSH 服务</h3><p>现在几乎所有的 Linux 发行版、Windows 以及 MacOS 基本都自带了 <code>ssh</code> 服务，其中绝大部分都是 OpenSSH ，这是一个关于实现 SSH-2 协议的开源项目，其中还包含了一些常用的辅助工具比如：<code>ssh-keygen</code>、<code>ssh-agent</code>、<code>scp</code> 以及 <code>sftp</code>。</p><p>所以绝大部分的电脑都是有 <code>ssh</code> 的，可以用 <code>ssh -V</code> 简单地查看一下。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#安装</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openssh-client<span class="token function">sudo</span> dnf <span class="token function">install</span> openssh-clients</code></pre><p>然后你就可以用 <code>service</code> 或者 <code>systemctl</code> 之类的开启 <code>sshd</code> 服务。</p><h2 id="ssh-基础用法">SSH 基础用法</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span> -p <span class="token punctuation">&#123;</span><span class="token number">22</span><span class="token punctuation">&#125;</span> <span class="token builtin class-name">command</span></code></pre><ul><li><code>remote_host</code> 可以是一个 IP 地址，也可以是一个可被 DNS 解析的域名（Domain）。</li><li><code>ssh</code> 除了可以登录之外，还可以在后面直接添加一条命令 <code>command</code>，会返回命令的 <code>STDOUT</code>。利用这个可以写一些脚本儿。</li><li><code>-p</code> 制定了 <code>ssh</code> 服务的端口，默认都是 22。</li><li>看看 <code>config</code> 以及 <code>known_hosts</code></li></ul><h3 id="常用配置文件">常用配置文件</h3><p>SSH 客户端的全局配置文件是 <code>/etc/ssh/ssh_config</code>，用户配置文件在 <code>~/.ssh/config</code>，用户配置文件优先级更高</p><p>SSH 服务端的配置文件是 <code>/etc/ssh/sshd_config</code></p><h4 id="config">config</h4><pre class="language-none"><code class="language-none">Host &#123;remoteserver&#125;     HostName &#123;remote_host&#125;     User &#123;username&#125;     Port 2222     IdentityFile ~&#x2F;.ssh&#x2F;id_rsa     ProxyCommand &#123;...&#125;Host *     Port 233     User root</code></pre><ul><li><code>Host *</code> 匹配了所有的 <code>remote_host</code>，也就是当所有匹配不成功的最后选项。后面的 <code>Port</code> 表示所有主机的默认连接端口都是 233，<code>User</code> 表示默认登录用户为 root 。</li><li><code>remoteserver</code> 是 <code>remote_host</code> 的别名</li><li><code>IdentityFile</code> 是指定用来登录验证的私钥文件，与 <code>ssh -i &#123;path/to/id_rsa&#125;</code> 的作用相同</li><li>还有一个 <code>ProxyCommand</code> 它大概有两个使用场景（原理都一样），一个是用代理进行 <code>ssh</code>，另一个是使用跳板机（中转机）。这个我们后面的端口转发篇再说。 与 <code>ssh -o "&#123;ProxyCommand&#125;"</code> 作用相同，这里假设我要用本地的 <code>Clash</code> 7890 端口做一个 <code>socks5</code> 协议的代理。</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#Windows 使用 git 自带的 connect 工具</span>ProxyCommand connect -S <span class="token number">127.0</span>.0.1:7890 %h %p<span class="token comment">#Linux 使用 netcat 也就是 nc 工具</span>ProxyCommand <span class="token function">nc</span> -X <span class="token number">5</span> -x <span class="token number">127.0</span>.0.1:7890 %h %p</code></pre><ul><li><code>%p</code> 和 <code>%h</code> 分别是 <code>ssh</code> 的端口号以及 <code>remote_host</code></li><li><code>connect</code><ul><li><code>-S</code> 和 <code>-H</code> 分别是 <code>socks</code> 和 <code>HTTPS</code> 代理</li></ul></li><li><code>nc</code><ul><li><code>-X 5</code> 指定代理协议为 <code>socks 5</code>，如果是 <code>HTTPS</code> 代理则为 <code>-X connect</code></li><li><code>-x</code> 指定代理的主机地址和端口</li></ul></li></ul><p>登录之后可以用 <code>who -a</code> 查看一下登录的 IP 是否是你的代理服务器 IP。</p><p>当你用 <code>ssh</code> 成功登录一次后，会自动在 <code>config</code> 文件中生成对应的配置文件，<code>IdentityFile</code> 默认缺省。这样，以后我们 <code>ssh</code> 一个已经在 <code>config</code> 中的主机的时候，可以直接 <code>ssh remoteserver</code> 登录，而不需要写一串命令。</p><h4 id="sshd_config">sshd_config</h4><ul><li><strong>Port</strong>：建议改为非 22 的 LuckyNumber，防止被扫端口弱口令爆破。</li><li><strong>PermitRootLogin</strong>：是否允许 root 账号直接登录。设置为 no 可以有效防止自己 <code>rm -rf /</code> 的欲望</li><li><strong>PermitEmptyPasswords</strong>：是否允许空密码登录。如果设置为 yes 并且登录的用户密码为空，则可以使用这个用户免密码登录。</li><li><strong>PasswordAuthentication</strong>：是否允许密码登录。如果设置为 no 可以增加安全性。</li><li><strong>PrintMotd</strong>： 打印登录提示信息，提示信息存储在/etc/moed 文件中</li><li>更改配置项后，记得重启 <code>sshd</code> 服务</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl restart sshd.service</code></pre><h3 id="公私钥的概念">公私钥的概念</h3><p>上面我们使用 <code>ssh</code> 的时候每一次登录都需要输入密码，这并不安全，其次非常麻烦。<code>ssh</code> 鼓励用户使用非对称加密的 <strong>公私钥验证</strong> 来进行登录，而不是使用密码。所谓的 <strong>公私钥验证</strong>，本质上是一套加密算法生成出的一对 RSA <strong>公钥</strong> 和 <strong>私钥</strong>。其中 <strong>私钥</strong> 自行保存，而 <strong>公钥</strong> 可以用来放在远程的服务器上。这样当远程的服务器接收到来自由你私钥发出的命令后，会使用之前存放的公钥进行认证。免去了在网络明文使用密码传输的风险。在 <code>ssh</code> 中，我们可以使用 <code>ssh-keygen</code> 来生成一对公私钥。</p><ul><li>小试一下（使用 <code>ssh-keygen</code> 生成并查看）</li><li><code>ssh-keygen</code> 除了用来生成密钥，还可以用来删除失效变更的公钥指纹（known_hosts），这通常发生在远程服务器出于某些原因被重置了。</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-keygen -R <span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span></code></pre><h3 id="上传-ssh-公钥的三种姿势">上传 SSH 公钥的三种姿势</h3><p>上传公钥的最终目的是在你要登录用户的 <code>~/.ssh/authorized_keys</code> 文件中追加你的 <strong>公钥文本</strong>。如果目标用户没有这个文件，需要先自行创建，并修改对应的 <strong>权限</strong>，否则 <code>ssh</code> 不会信任你的公钥。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token number">600</span> ~/.ssh/authorized_keys<span class="token function">chmod</span> <span class="token number">700</span> ~/.ssh</code></pre><h4 id="manualsimulation">ManualSimulation</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/.ssh<span class="token function">touch</span> ~/.ssh/authorized_keys<span class="token function">vim</span> ~/.ssh/authorized_keys<span class="token comment">#把公钥复制粘贴进去</span></code></pre><p>当然，如果你熟悉管道运算符，你还可以一句话搞定</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub <span class="token operator">|</span> <span class="token function">ssh</span> <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span> <span class="token string">"mkdir -p ~/.ssh &amp;&amp; cat >> ~/.ssh/authorized_keys"</span></code></pre><h4 id="scp">scp</h4><p><code>scp</code> 是 SSH 提供的一个客户端程序，用来在两台主机之间加密传送文件（即复制文件）。其用法和 <code>cp</code> 类似。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> ~/.ssh/id_rsa.pub <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span>:~/<span class="token function">ssh</span> <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span> <span class="token string">"cat ~/id_rsa.pub >> ~/.ssh/authorized_keys"</span><span class="token function">rm</span> ~/id_rsa.pub<span class="token comment"># 或者</span><span class="token function">scp</span> ~/.ssh/id_rsa.pub <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span>:~/.ssh/authorized_keys</code></pre><h4 id="ssh-copy-id">ssh-copy-id</h4><p>OpenSSH 自带一个 <code>ssh-copy-id</code> 命令，可以自动将公钥拷贝到远程服务器的 <code>~/.ssh/authorized_keys</code> 文件。如果 <code>~/.ssh/authorized_keys</code> 文件不存在，<code>ssh-copy-id</code> 命令会自动创建该文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-copy-id -i key_file user@host</code></pre><ul><li>注意，<code>ssh-copy-id</code> 是直接将公钥添加到 <code>authorized_keys</code> 文件的末尾。如果 <code>authorized_keys</code> 文件的末尾不是一个换行符，会导致新的公钥添加到前一个公钥的末尾，两个公钥连在一起，使得它们都无法生效。所以，如果 <code>authorized_keys</code> 文件已经存在，使用 <code>ssh-copy-id</code> 命令之前，务必保证 <code>authorized_keys</code> 文件的末尾是换行符（假设该文件已经存在）。</li></ul><h2 id="ssh-端口转发">SSH 端口转发</h2><blockquote><p>SSH 除了登录服务器，还有一大用途，就是作为加密通信的中介，充当两台服务器之间的通信加密跳板，使得原本不加密的通信变成加密通信。这个功能称为端口转发（port forwarding），又称 SSH 隧道（tunnel）。</p><p>端口转发有两个主要作用：</p><p>（1）将不加密的数据放在 SSH 安全连接里面传输，使得原本不安全的网络服务增加了安全性，比如通过端口转发访问 Telnet、FTP 等明文服务，数据传输就都会加密。</p><p>（2）作为数据通信的加密跳板，绕过网络防火墙。</p></blockquote><h3 id="本地转发正向转发">本地转发（正向转发）</h3><p>把远程服务器的端口映射到本地，绕过防火墙和安全组的限制。比如我在远程服务器的 8888 端口运行了一个不知名的 Web 应用，如果我要在公网临时查看他的部署结果，毕竟远程服务器一般情况下是没有 <code>GUI</code> 的，那么我必须开防火墙和安全组让这个端口暴露在公网，完事后还得再关上，比较麻烦。那么就可以使用 <code>ssh</code> 本地转发。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -L <span class="token punctuation">[</span>local-remote:<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>local-port<span class="token punctuation">&#125;</span>:<span class="token punctuation">&#123;</span>target-host<span class="token punctuation">&#125;</span>:<span class="token punctuation">&#123;</span>target-port<span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>tunnel-host<span class="token punctuation">&#125;</span></code></pre><ul><li><code>local-remote</code> 缺省为本机</li><li><code>tunnel-host</code> 就是一句能正常登陆你的远程服务器的 <code>ssh</code> 连接语句</li><li><code>local-port</code> 是映射到本地的某个端口</li><li><code>target-host</code> 为最终的 <code>remote_host</code>，如果是访问 <code>tunnel-host</code> 的服务，则为 <code>localhost</code>，要不就是某个内网机器的 host 地址</li><li><code>target-port</code> 为最终的 <code>remote_host</code> 的端口号，也就是服务真正所在的端口</li></ul><p>当然，你也可以使用万能的 <strong>VSCode</strong> 直接一键转发。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220319224716.png" alt="image-20220319224707914" / loading="lazy"><figcaption aria-hidden="true">image-20220319224707914</figcaption></figure><h3 id="远程转发反向转发">远程转发（反向转发）</h3><p><strong>WARNING！反向转发有一定风险</strong></p><p>把本地的某个端口映射到远程服务器，这个应用场景也很常见，比如我在宿舍的机子上跑了一个不知名的 WEB Docker 容器，但是校园网是经过 <strong>NAT</strong> 没有所谓的公网 IP，这样在校外就无法访问到我的应用。那么就可以使用 <code>ssh</code> 远程转发，这样我就可以通过访问具有公网 IP 的远程服务器的某个端口访问到我的应用。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -R <span class="token punctuation">[</span>remote-host:<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>remote-port<span class="token punctuation">&#125;</span>:<span class="token punctuation">&#123;</span>target-host<span class="token punctuation">&#125;</span>:<span class="token punctuation">&#123;</span>target-port<span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>tunnel-host<span class="token punctuation">&#125;</span></code></pre><ul><li><code>remote-host</code> 缺省为 <code>tunnel-host</code> 的 <code>localhost</code>。如果你想让应用被公网任意地址访问，需要更改为 <code>0.0.0.0</code>，否则只能被远程机器用 <code>localhost</code> 访问，就完全相当于正向转发的逆向了。</li><li><code>remote-port</code> 是映射到远程服务器的某个端口，记得打开对应防火墙和安全组</li><li><code>target-host</code> 是应用所在的 host ，本地就是 <code>localhost</code></li><li><code>target-port</code> 是服务真正所在的端口</li></ul><p>但是 <code>ssh</code> 默认配置的情况下，哪怕你改了 <code>remote-host</code> 为 <code>0.0.0.0</code> 也不会让你进行一个公网的访问，这是出于安全考量的。</p><p>如果你使用 <code>-v</code> 查看的话，就会发现一个警告 <code>Remote: Forwarding listen address "192.168.1.1" overridden by server GatewayPorts</code></p><p>so，若果想要开启，需要更改 <code>~/.ssh/config</code> 的 <code>GatewayPorts</code> 为 yes</p><h3 id="tips">Tips</h3><ol type="1"><li>反向转发注意安全</li><li>可以使用 <code>-f</code> 后台执行</li><li>可以使用 <code>-N</code> 不进入 ssh 交互命令行模式</li><li>通过 <code>ssh</code> 进行端口转发其实并不稳定，想要构建稳定的端口转发可以了解 <code>autossh</code> 或者 <code>frp</code></li></ol><h2 id="参考">参考</h2><p>https://wangdoc.com/ssh/basic.html</p><p>https://kanda.me/2019/07/01/ssh-over-http-or-socks/</p><p>https://abcdabcd987.com/ssh/</p><p>https://www.cnblogs.com/bonelee/p/12511024.html</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;来学校上了两周网课，两周线下，现在又要上网课了 G！上网课就算了，我还要给学弟上网课哈哈。整一波虚拟教师 V 出道&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220320002327.jpg&quot; alt=&quot;63476067_p0_master1200&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="项目经历" scheme="http://lapras.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="教程" scheme="http://lapras.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="网络" scheme="http://lapras.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>浅谈贝叶斯定理</title>
    <link href="http://lapras.xyz/2022/02/28/8fd34f7b.html"/>
    <id>http://lapras.xyz/2022/02/28/8fd34f7b.html</id>
    <published>2022-02-28T11:03:59.000Z</published>
    <updated>2022-08-21T07:21:56.344Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>恍恍惚惚，大二下开始学习概率论了，G！</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220228195301.jpg" alt="95841206_p0" / loading="lazy"><figcaption aria-hidden="true">95841206_p0</figcaption></figure><span id="more"></span><h3 id="引例">引例</h3><p>上完了九年义务制教育的朋友们大多知道什么叫概率，再不济也知道古典概型无非就是从有限的盒子里等可能地去摸球。概率嘛，无非就是可能除以总数（X）。好，那让我们来看看下面这个问题：</p><blockquote><p>假设某种疾病在所有人群中的感染率是 1%，医院现有的技术对于该疾病检测的灵敏度(Sensitivity)为 90%，这意味着 100 个确诊的人中有 10 名将会是误诊的。而技术的特异度（Specificity）为 91%，这意味着 100 名健康的人群中会有 9 人误诊。</p><p>好的，现在请思考一下，假设我们对 1000 名人员进行该医学检测，而你不幸被检测为阳性（患病），请问你患病的几率大概是多少呢？</p></blockquote><p>A. <span class="math inline">\(9\over 10\)</span> B. <span class="math inline">\(8\over10\)</span> C. <span class="math inline">\(1\over 10\)</span> D. <span class="math inline">\(1\over 100\)</span></p><p><strong>答案在分割线下！！！</strong></p><hr /><p>嘿嘿，答案是 <strong>C</strong>。</p><p>真是奇怪，明明这么高的灵敏度，为什么患病的几率反而如此之低 ne？这其实就是一种反直觉的现象。现在让我们一起算一下这题。</p><p>1000 个人中的感染率为 1%，也就是有 10 个人是真正的患者，检测的灵敏度为 90%，换言之误诊率为 10%。这意味着我们会检测出其中的 9 名真正的患者和 1 名误诊的。而 91%的特异度将会为我们带来 <span class="math display">\[(1000-10)*(1-91\%)\approx89\]</span> 89 名误诊！接着用我们都会的条件概率进行简单地计算 <span class="math display">\[P(confirm\, Patient|Patient)=\tfrac{9}{9+89}= 0.091\]</span> 不到十分之一的概率为真正的患者，That's so ridiculous。其实不难发现，这里的假阳性比阳性的还要多。</p><h3 id="谬">“谬”</h3><p>这里引用 <span class="math inline">\(3b1b\)</span> 大佬的话，我们算出的概率并不能体现你患病的几率，正确的观点是我们算出的概率 <strong>更新</strong> 了你患病的几率。</p><p>这里就可以引出先验概率的概念</p><blockquote><p>先验概率（prior probability）是指根据以往经验和分析得到的概率，如全概率公式，它往往作为 "由因求果" 问题中的 "因" 出现的概率。</p></blockquote><p>显然，原本的先验概率为人群中的感染率也就是 1%。而检测的值 <strong>更新</strong> 了这一概率，将概率增加了一个数量级。但这并不是我们想要的答案。在本题中我们只关心检测出为阳性时的情况倾向。 <span class="math display">\[\tfrac{Sensitivity}{1-Specificity}= 10\]</span> 这就是似然比(likelihood ratio)，也叫做贝叶斯因子。这里有个著名的经验公式，贝叶斯推断。用于更新 <strong>较小的先验概率</strong>。在本例中，先验概率为 1%，乘以贝叶斯因子后结果为 0.1 接近了正确答案 0.091。</p><p>再举个例子，将上面的条件由 1000 人换到 100 人，患病率由 1%换成 10%。这意味着我们将有 10 名确诊（9 名真患者，1 名误诊），90 名正常（8 人逃脱，81 名正常）。但是我们的似然比保持不变为 10。 <span class="math display">\[P(confirm\, Patient|Patient)=\tfrac{9}{9+8}\approx 53\%\]</span> 显然在先验概率过大的情况下随意使用经验公式，会出问题。但事实上，之所以只能在较小的先验概率中使用，是因为他的原型为更新比率而非更新概率。比如 50%的概率，他的比率为 1: 1。所以真正的贝叶斯公式，<strong>是将先验概率以比率的形式被贝叶斯因子更新。</strong></p><p>回到最开始的条件，先验概率为 1%，比率形式为 1: 99，然后用贝叶斯因子更新为 10: 99 也就是 10/109 的概率，与我们计算的答案别无二致。</p><p>同样的，当先验概率为 10%，比率形式为 1: 9 ，更新后为 10: 9 也就是 10/19 的概率，正好是 53%。</p><p>回到，我们一开始的问题。给予人们这种错觉的原因往往是条件概率的认知不清。当我们在说准确率为 99%准确性的测试的时候，表示的是 <strong>已知一个人得病(B)的情况下检测出阳性(A)的概率</strong>。即 <span class="math inline">\(P(A|B)\)</span> ，而人人往往将其等同于 <strong>一个人在检测出阳性(A)的情况下得病(B)的概率</strong>。即 <span class="math inline">\(P(B|A)\)</span> 。那么，有没有一种………</p><h3 id="贝叶斯">贝叶斯</h3><p>贝叶斯是一种已知结果 B 反求因 A 的思想。下面举个例子：</p><div><p>graph TB A1(A1)--&gt; B(B) A2(A2)--&gt; B(B) A3(A3)--&gt; B(B)</p></div><p>显然这里有三条路径来完成整件事情，对于第一条路径 A1-&gt; B 而言： <span class="math display">\[P_1 = P(A1)*P(B|A1)\]</span> 同样的，我们可以得到 <span class="math inline">\(P2\)</span> 和 <span class="math inline">\(P3\)</span> ，而他们的求和正好就是 B 的全概率公式，也是贝叶斯公式的分母。</p><p>那么现在我们求的 <strong>因</strong>，也就是其中一条路径在全部路径中的概率，问题就是一个简单的 <strong>类古典概型</strong> 了。</p><p>给出我们的通式： <span class="math display">\[P(A|B)=\frac{P(B|A)*P(A)}{P(B|A)* P(A)+P(B|A^c)*P(A^c)}\]</span></p><ul><li>这里的 <span class="math inline">\(A^c\)</span> 是 A 的对立事件</li><li>分母为 <span class="math inline">\(P(B)\)</span> 的全概率公式</li></ul><h3 id="参考">参考</h3><p><a href="https://zhuanlan.zhihu.com/p/22467549">Think Bayes</a></p><p><a href="https://www.youtube.com/watch?v=lG4VkPoG3ko">The medical test paradox, and redesigning Bayes' rule</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;恍恍惚惚，大二下开始学习概率论了，G！&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220228195301.jpg&quot; alt=&quot;95841206_p0&quot; /&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;95841206_p0&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    
    <category term="数学" scheme="http://lapras.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>信息茧房脱出-自建 RSS</title>
    <link href="http://lapras.xyz/2021/12/15/3db8db5b.html"/>
    <id>http://lapras.xyz/2021/12/15/3db8db5b.html</id>
    <published>2021-12-15T03:37:57.000Z</published>
    <updated>2022-09-10T09:30:50.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>RSS，也就是 Rich Summary Site 。这玩意儿有点时代的眼泪的感觉了。在推荐算法大行其道的当下，RSS 本身是一种逆潮流的选择。加之国区对于 RSS 应用的监管力度之大致使很多优秀的 RSS 服务在国内被和谐。</p><p>我之前一直使用的是 feeder.co 无奈他的 IPAD 应用不仅要 Dollar，还锁了国区。所以选择折腾一手，自建 RSS。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216172339.jpeg" alt="img" style="zoom:67%;" / loading="lazy"></p><span id="more"></span><h2 id="miniflux">Miniflux</h2><p><a href="https://miniflux.app/">Miniflux</a> 是一个免费开源的 RSS 聚合源，与另一个开源的 <a href="https://tt-rss.org/">TTRSS</a> 相比，它的极简设计风格，深的我心（虽然默认 UI 都差不多丑）。</p><p>然后 Miniflux 是基于 <code>GO</code> 的，没有其他奇奇怪怪的依赖项。</p><h3 id="部署">部署</h3><p>如果你没有 Docker 以及 Docker-compose，请立即安装并学习。</p><p><a href="https://vuepress.mirror.docker-practice.com/">Docker 从入门到实践</a></p><ol type="1"><li>新建一个 miniflux 目录</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/miniflux <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> ~/miniflux</code></pre><ol start="2" type="1"><li>创建并修改 <code>docker-compose.yml</code></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.4'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">miniflux</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> miniflux/miniflux<span class="token punctuation">:</span>latest    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"&lt;181>:8080"</span>  <span class="token comment"># 端口181</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> db    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> DATABASE_URL=postgres<span class="token punctuation">:</span>//miniflux<span class="token punctuation">:</span>&lt;passWord<span class="token punctuation">></span><span class="token punctuation">,</span>.@db/miniflux<span class="token punctuation">?</span>sslmode=disable <span class="token comment"># 数据库密码</span>      <span class="token punctuation">-</span> RUN_MIGRATIONS=1      <span class="token punctuation">-</span> CREATE_ADMIN=1      <span class="token punctuation">-</span> ADMIN_USERNAME=&lt;admin<span class="token punctuation">></span>  <span class="token comment"># 登录Miniflux的用户名，可自定义</span>      <span class="token punctuation">-</span> ADMIN_PASSWORD=&lt;password<span class="token punctuation">></span>  <span class="token comment"># 登录Miniflux的密码，可自定义，至少6位</span>    <span class="token key atrule">healthcheck</span><span class="token punctuation">:</span>      <span class="token key atrule">test</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"CMD"</span><span class="token punctuation">,</span> <span class="token string">"/usr/bin/miniflux"</span><span class="token punctuation">,</span> <span class="token string">"-healthcheck"</span><span class="token punctuation">,</span> <span class="token string">"auto"</span><span class="token punctuation">]</span>  <span class="token key atrule">db</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span class="token punctuation">:</span>latest    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> POSTGRES_USER=miniflux      <span class="token punctuation">-</span> POSTGRES_PASSWORD=secret    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> miniflux<span class="token punctuation">-</span>db<span class="token punctuation">:</span>/var/lib/postgresql/data    <span class="token key atrule">healthcheck</span><span class="token punctuation">:</span>      <span class="token key atrule">test</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"CMD"</span><span class="token punctuation">,</span> <span class="token string">"pg_isready"</span><span class="token punctuation">,</span> <span class="token string">"-U"</span><span class="token punctuation">,</span> <span class="token string">"miniflux"</span><span class="token punctuation">]</span>      <span class="token key atrule">interval</span><span class="token punctuation">:</span> 10s      <span class="token key atrule">start_period</span><span class="token punctuation">:</span> 30s<span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">miniflux-db</span><span class="token punctuation">:</span></code></pre><ul><li>自行修改上述带有 <code>&lt;&gt;</code> 的选项</li></ul><ol start="3" type="1"><li>启动 Miniflux</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> up -d</code></pre><p>访问 <code>localhost:&lt;端口&gt;</code> 进入 Miniflux 的管理页面说明大成功，然后就可以开启相应的防火墙，让外网也可以访问。</p><h2 id="rsshub">RssHub</h2><p>Miniflux 充当的角色是个 <strong>聚合的订阅源</strong>，那么源本身从哪里来呢？别人整合的固然方便，但是自定义程度肯定不如自己来得爽。但是有些网站或者博客根本没有做 RSS 订阅（<del> 比如我 </del>）</p><blockquote><p>RSSHub 是一个开源、简单易用、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。RSSHub 借助于开源社区的力量快速发展中，目前已适配数百家网站的上千项内容</p><p>可以配合浏览器扩展 <a href="https://github.com/DIYgod/RSSHub-Radar">RSSHub Radar (opens new window)</a> 和 移动端辅助 App <a href="https://github.com/Cay-Zhang/RSSBud">RSSBud (opens new window)</a>(iOS) 与 <a href="https://github.com/LeetaoGoooo/RSSAid">RSSAid (opens new window)</a>(Android) 食用</p></blockquote><h3 id="使用">使用</h3><p>最常用的场景就是下载一个浏览器插件，他会自动嗅探当前网页，如果有符合的路由规则（来自于开源社区的支持），他会自动帮你生成一个 RSS 源，同时支持一键导入到你的聚合源（在设置界面中添加 Miniflux 的地址）。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216165507.png" alt="image-20211216165506944" style="zoom:67%;" / loading="lazy"></p><h3 id="部署-1">部署</h3><p>RSSHub 默认可以使用官方提供的服务器服务，但出于反爬以及稳定性的考量，还是建议我们选择自建服务。</p><del>如果你没有 Docker 以及 Docker-compose，请立即安装并学习。</del><p>运行下面的命令下载 RSSHub 镜像</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> pull diygod/rsshub</code></pre><p>然后运行</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -d --name rsshub -p <span class="token number">1200</span>:1200 diygod/rsshub</code></pre><h3 id="添加配置">添加配置</h3><p>配置运行在 docker 中的 RSSHub，最便利的方法是使用 docker 环境变量</p><p>以设置缓存时间为 1 小时举例，只需要在运行时增加参数：<code>-e CACHE_EXPIRE=3600</code></p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -d --name rsshub -p <span class="token number">1200</span>:1200 -e <span class="token assign-left variable">CACHE_EXPIRE</span><span class="token operator">=</span><span class="token number">3600</span> </code></pre><p>更多配置项请看 <a href="https://docs.rsshub.app/install/#pei-zhi">官方文档</a></p><h3 id="使用-1">使用</h3><p>同样的，在部署成功之后访问对应的地址。（记得打开防火墙）</p><p>然后就可以在 RSSHub Rader 等的设置页面，使用自定义 RSSHub 域名</p><h2 id="阅读器推荐">阅读器推荐</h2><p>说了这么多，总得来点读的，考虑到我的使用场景，所以没有找 IOS 或者 Android 的阅读器。</p><h3 id="win10win11">win10&amp;win11</h3><p>推荐国人大佬 云之幻 制作的 <a href="https://www.microsoft.com/zh-cn/p/rss-%E8%BF%BD%E8%B8%AA/9n85pv1rjd6v">RSS 追踪</a>，界面充分体现了 UWP 应用一贯的极简且平滑的设计理念👍。</p><blockquote><p>集成多种主流 RSS 服务的原生 UWP 阅读器，通过在线服务，你可以实现多端同步。经过全新设计的 UI 与强化后的功能，是 Windows 端一个不错的 RSS 阅读选择</p></blockquote><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216170732.jpeg" alt="img" style="zoom:67%;" / loading="lazy"></p><p>这里选择 Fever 模式</p><p>进入 Miniflux 的后台，在设置中打开 Fever 插件，设置用户名密码后。即可用 <code>http://IP:minifluxport/fever/</code> 的方式导入</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216171232.png" alt="image-20211216171231808" style="zoom:67%;" / loading="lazy"></p><p>总之就是清爽😎</p><h3 id="ipados">ipadOS</h3><p>APPStore 个人觉得最好用的 Feeder 5 已经从国区下架了，国人团队做的 Ego Reader 体验也不错。可惜横屏适配问题一直没有解决。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216172758.jpg" alt="img" style="zoom:67%;" / loading="lazy"></p><h2 id="踩坑">踩坑</h2><h3 id="v2raya-代理问题">V2rayA 代理问题</h3><p>可能因为 <code>/etc/resolv.conf</code> 被 V2rayA 自动修改成本地的 53 端口来进行 <code>redirect</code> 透明代理，导致 docker 内容器出现 ping 不通，curl 不了的问题。经过以下三个步骤，我把 docker 容器都设置为走 V2rayA 的代理模式了。</p><ol type="1"><li>重新用 docker 部署了一遍 V2rayA</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># run v2raya</span><span class="token function">docker</span> run -d <span class="token punctuation">\</span>  --restart<span class="token operator">=</span>always <span class="token punctuation">\</span>  --privileged <span class="token punctuation">\</span>  --network<span class="token operator">=</span>host <span class="token punctuation">\</span>  --name v2raya <span class="token punctuation">\</span>  -e <span class="token assign-left variable">V2RAYA_ADDRESS</span><span class="token operator">=</span><span class="token number">0.0</span>.0.0:2017 <span class="token punctuation">\</span>      -v /lib/modules:/lib/modules <span class="token punctuation">\</span>  -v /etc/resolv.conf:/etc/resolv.conf <span class="token punctuation">\</span>  -v /etc/v2raya:/etc/v2raya <span class="token punctuation">\</span>  mzz2017/v2raya</code></pre><ol start="2" type="1"><li>设置 <code>~/.docker/config.json</code></li></ol><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"proxies"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"default"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"httpProxy"</span><span class="token operator">:</span> <span class="token string">"http://172.17.0.1:20172"</span><span class="token punctuation">,</span>      <span class="token property">"httpsProxy"</span><span class="token operator">:</span> <span class="token string">"http://172.17.0.1:20172"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><code>172.17.0.1</code> 是我自定义的 docker0 inet，请使用 <code>ifconfig</code> 或者 <code>ip a</code>，自行查看 <code>docker0</code> 的 inet</li><li>20172 是我的 V2RayA 的 HTTP 分流端口</li></ul><ol start="3" type="1"><li>我的 V2rayA 的设置</li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216160732.png" alt="image-20211216160732519" style="zoom:50%;" / loading="lazy"></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216160830.png" alt="image-20211216160829968" style="zoom: 67%;" / loading="lazy"></p><h2 id="参考">参考</h2><p><a href="https://miniflux.app/">Miniflux</a></p><p><a href="https://docs.rsshub.app/">RSSHub</a></p><p><a href="https://hydrotho.github.io/Miniflux-Build-Guide/">利用 Miniflux 自建 RSS</a></p><p>​</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;RSS，也就是 Rich Summary Site 。这玩意儿有点时代的眼泪的感觉了。在推荐算法大行其道的当下，RSS 本身是一种逆潮流的选择。加之国区对于 RSS 应用的监管力度之大致使很多优秀的 RSS 服务在国内被和谐。&lt;/p&gt;
&lt;p&gt;我之前一直使用的是 feeder.co 无奈他的 IPAD 应用不仅要 Dollar，还锁了国区。所以选择折腾一手，自建 RSS。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216172339.jpeg&quot; alt=&quot;img&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="分享" scheme="http://lapras.xyz/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="教程" scheme="http://lapras.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
