<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anduin9527的乖离器</title>
  
  <subtitle>正在进修摸鱼学导论</subtitle>
  <link href="http://lapras.xyz/atom.xml" rel="self"/>
  
  <link href="http://lapras.xyz/"/>
  <updated>2022-07-26T08:04:11.663Z</updated>
  <id>http://lapras.xyz/</id>
  
  <author>
    <name>Anduin9527</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成原理笔记（五）</title>
    <link href="http://lapras.xyz/2022/07/26/fe0a25d8.html"/>
    <id>http://lapras.xyz/2022/07/26/fe0a25d8.html</id>
    <published>2022-07-26T07:53:07.000Z</published>
    <updated>2022-07-26T08:04:11.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>难起来了，光看哈工大的mooc感觉已经听不懂了，准备去啃啃 CSAPP 或者 Nand2Tetris 。</p><span id="more"></span><h2 id="概述">概述</h2><h3 id="输入输出系统的发展概况">输入输出系统的发展概况</h3><p>早期的计算机数目较少，应用少，外设也少。所以早期使用<strong>分散连接</strong>的方式，即每一个设备都有专门的控制电路，甚至与CPU的控制电路高度耦合。所以对外设增删都非常麻烦。外部设备与主机的连接主要采用<strong>程序查询方式</strong>，即CPU和I/O设备<strong>串行工作</strong>。</p><p>随着计算机发展，分散连接逐步被淘汰。出现了<strong>I/O接口</strong>与<strong>DMA控制器</strong>，采用<strong>总线</strong>方式进行连接，一条总线连接多个设备，总线与I/O设备的传输方式也变成了<strong>并行工作</strong>。</p><p>为了进一步使得I/O操作独立于CPU之外，又出现了具有<strong>通道结构</strong>的I/O，可以看成<strong>小型的DMA控制器</strong>，具有自己的指令系统，可以控制连接在通道上的I/O设备直接与主机交互。</p><p>现代的超级计算机可以使用专门的处理器作为I/O处理机，甚至能帮助CPU进行运算。</p><h3 id="输入输出系统的组成">输入输出系统的组成</h3><p><strong>I/O软件</strong></p><ol type="1"><li>I/O指令：CPU指令集的一部分，其格式为操作码+命令码+设备码</li><li>通道指令：通道能够指令由通道指令构成的程序，指出数组的首地址、传送字数、操作命令</li></ol><p><strong>I/O硬件</strong></p><ol type="1"><li>设备–I/O接口–总线–主机</li><li>设备–设备控制器–子通道–通道–主机</li></ol><h3 id="io设备与主机的联系方式">I/O设备与主机的联系方式</h3><p>I/O设备是有地址的，主机必须要给出其地址才能操作。所以要对I/O设备编址，其编址方式有：</p><p><strong>统一编址</strong>：将I/O设备地址编写在内存区域，用取数和读数到对应区域则为I/O操作。显然会节省命令集，但是对于寻址空间的要求较高。</p><p><strong>单独编址</strong>：在内存地址之外，专门设置一个地址空间给外部设备。为了区分指令是对内存还是对I/O设备，此时需要有专门的I/O指令进行操作。</p><p>编址之后，需要选址。采用<strong>设备选择电路</strong>识别是否被选中，只要把CPU给出的地址和设备中保存的地址进行比较，相同则为选中。然后就可以开始数据传送：</p><p><strong>串行</strong>：数据一位一位进行传输，传输速度慢，适合远程上传输</p><p><strong>并行</strong>：同时有多位数据进行传输，通常情况下为8的倍数。</p><p>联络方式：外设接受或发送数据的响应情况</p><p><strong>立即响应</strong>：直接发生响应</p><p><strong>异步工作</strong>：一般采用应答信号的方式，分为并行传输和串行传输。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%80%E8%88%AC%E9%87%87%E7%94%A8%E5%BA%94%E7%AD%94%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%96%B9%E5%BC%8F.png" alt="image-20220724133812663" style="zoom:80%;" / loading="lazy"></p><p><strong>同步工作</strong>：采用同步时标</p><h3 id="io设备与主机信息传送的控制方式">I/O设备与主机信息传送的控制方式</h3><p>程序查询方式：CPU和外设串行工作</p><p>程序中断方式：CPU和外设做到部分并行</p><p>DMA方式：使得外部设备和内存之间建立直接连接，无需CPU额外处理</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="image-20220724135731680" style="zoom:80%;" / loading="lazy"></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD.png" alt="image-20220724140401331" style="zoom:80%;" / loading="lazy"></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD2.png" alt="image-20220724140459014" style="zoom:80%;" / loading="lazy"></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/DMAa.png" alt="image-20220724141208316" style="zoom:80%;" / loading="lazy"></p><h2 id="外部设备">外部设备</h2><h3 id="概述-1">概述</h3><p>外部设备（I/O设备）通过I/O接口与主机相连，其主要包含两个部分：设备控制器与物理部分。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87.png" alt="image-20220725101402068" style="zoom:80%;" / loading="lazy"></p><h3 id="外部设备的分类">外部设备的分类</h3><ol type="1"><li>人机交互设备：键盘、鼠标、打印机、显示器</li><li>计算机信息存储设备：磁盘、光盘、磁带</li><li>机-机通信设备：调制解调器</li></ol><h2 id="io接口">I/O接口</h2><h3 id="接口的功能">接口的功能</h3><ol type="1"><li>实现设备的选择</li><li>实现数据的缓冲平衡不同外部设备速度匹配</li><li>实现数据串-并格式转换</li><li>实现电平转换</li><li>传送控制命令</li><li>反映设备的工作状态。</li></ol><h3 id="接口的组成">接口的组成</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E6%88%90.png" alt="image-20220725103240038" style="zoom:80%;" / loading="lazy"></p><ul><li>设备选择线（单向）：传送本次参与信息传输的设备码（设备地址）或端口地址给I/O接口进行匹配</li><li>数据线（双向）：完成数据的输入输出</li><li>命令线（单向）：主机发送命令进过缓冲和译码之后，控制设备操作</li><li>状态线（单向）：从I/O接口发送给主机，告知设备的状态</li></ul><h3 id="接口的功能和组成">接口的功能和组成</h3><table><thead><tr class="header"><th>功能</th><th>组成</th></tr></thead><tbody><tr class="odd"><td>选址功能</td><td>设备选择电路</td></tr><tr class="even"><td>传送命令</td><td>命令寄存器、命令译码器</td></tr><tr class="odd"><td>传送数据</td><td>数据缓冲寄存器</td></tr><tr class="even"><td>反映设备状态</td><td>设备状态标记</td></tr></tbody></table><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/I/O%E6%8E%A5%E5%8F%A3%E7%BB%84%E6%88%90.png" alt="image-20220725104935351" style="zoom:80%;" / loading="lazy"></p><h3 id="接口分类">接口分类</h3><ol type="1"><li>数据传送方式分类：并行接口、串行接口</li><li>选择的灵活性分类：可编程接口、不可编程接口</li><li>通用性分类：通用接口、专用接口</li><li>数据传送的控制方式：中断方式接口、DMA接口</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;难起来了，光看哈工大的mooc感觉已经听不懂了，准备去啃啃 CSAPP 或者 Nand2Tetris 。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（四）</title>
    <link href="http://lapras.xyz/2022/07/23/9194e09f.html"/>
    <id>http://lapras.xyz/2022/07/23/9194e09f.html</id>
    <published>2022-07-23T05:58:07.000Z</published>
    <updated>2022-07-23T06:18:05.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>摸了一周崛起，又回来上工了！</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220723135707.png" alt="image-20220723135707436" style="zoom:80%;" / loading="lazy"></p><span id="more"></span><h2 id="概述">概述</h2><h3 id="问题的提出">问题的提出</h3><p>CPU的发展速度非常快，而存储器的速度则会成为瓶颈，则CPU存在<strong>空等</strong>现象。通过在CPU和主存之间增加一个Cache缓存，其由静态RAM组成，和主存相比容量小，速度快。</p><blockquote><p>Cache之所以行之有效，就不得不提<strong>程序访问的局部性原理</strong>，这个原理的内含分两部分，一是时间的局部性：当前访问到的指令和数据在不久的将来很有可能还会被访问到；二是空间的局部性：当前访问的指令和数据的附近的指令和数据在不久的将来很可能会被访问到。因此，如果我们把当前访问的指令、数据及其附近的指令和数据都缓存到Cache，那么之后再访问时，CPU就无需访存了，进而提升了系统的性能。</p></blockquote><h3 id="主存和缓存的编址">主存和缓存的编址</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Cache%E7%BB%93%E6%9E%84.png" alt="Cache结构" style="zoom:80%;" / loading="lazy"></p><ul><li>内存被分为<span class="math inline">\(M\)</span>块，缓存被分为<span class="math inline">\(C\)</span>块，其块的大小相同都为<span class="math inline">\(B\)</span>个字。通常<span class="math inline">\(M \gg C\)</span>，这意味着同一时间内，只有一小部分的主存会被缓存</li><li>主存中的数据都是按块被缓存的，当某块被缓存时，由硬件为Cache的每一块维护的标记会记录下被缓存的主存块的块号。之后CPU访问该块的数据时，在缓存的标记中可以找到该块的块号，且相应<strong>缓存块有效</strong>，那么就不需要访存了，直接访问相应的缓存块即可</li></ul><h3 id="缓存的命中率">缓存的命中率</h3><p>所谓Cache的命中，就是指CPU访问某个指令或数据时，其对应的主存块已经被写入缓存（已建立了对应关系/标记），反之则为未命中，CPU必须到主存中去获取对应指令。</p><blockquote><p>CPU多次访问数据，其中缓存命中的比率称为Cache的<strong>命中率</strong>。命中率与Cahce的容量和块的大小有关，一般来说容量越大，块越大，则命中率越高。当然，凡是不能极端，缓存过大会提升成本和功耗，而块过大会减少块的数量，进而降低同一时间能够被缓存的主存块的数量。</p></blockquote><p>总的来说，命中率 与 Cache 的 容量与块长有关。一般块长取一个存取周期内从主存调出的信息长度</p><h4 id="访问效率e">访问效率<span class="math inline">\(e\)</span></h4><p><span class="math display">\[\begin{align*}e &amp;= \frac{t}{\overline t}*100\% \\&amp;=\frac{t_c}{h*t_c+(1-h)*t_m}*100\% \end{align*}\]</span></p><ul><li><span class="math inline">\(t\)</span>为访问Cache的时间，<span class="math inline">\(\overline t\)</span>为平均访问时间</li><li>带入命中率<span class="math inline">\(h\)</span>后，t_c<span class="math inline">\(为访问Cache的时间，\)</span>t_m$为访问主存的时间</li></ul><h3 id="cache的基本结构">Cache的基本结构</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="image-20220721105528285" style="zoom:80%;" / loading="lazy"></p><h3 id="cache读写操作">Cache读写操作</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Cache%E8%AF%BB.png" alt="image-20220721110412863" style="zoom:80%;" / loading="lazy"></p><p>写操作主要有两种方式：</p><ul><li>写直达法：写操作时既写入Cache也写入主存，写操作时间即为访问主存的时间，Cache块退出时，不需要对主存执行写操作，因此Cache块的更新策略比较容易实现。</li><li>写回法：写操作时只把数据写入Cache而不写入主存，写操作时间即为访问Cache的时间，当Cache数据被替换出去时需要写回主存，因此增加了Cache的复杂性。</li></ul><h3 id="cache改进">Cache改进</h3><ul><li>增加Cache的层次级数：Cache本质上通常是SRAM，不过不同的单元电路组成的SRAM是有区别的，有的速度快、功耗高、成本高，有的速度慢、功耗低、成本低、且易于集成(具体内容可搜索LVT HVT关键字)。因此，参照整个存储系统的层次结构，Cache也可以细分出不同层次，比如L1 Cache、L2 Cache等，以此来获得性能、功耗、芯片面积、成本等方面的平衡。</li><li>参照哈佛架构分立缓存：采用独立的数据Cache和指令Cache。现代处理器基本上都采用了流水线结构，如果单独为数据和指令设置Cache，则在某条指令执行需要访问数据时，不会影响后面的指令的取指(一个是访问数据Cache，一个是访问指令Cache)，从而提高计算机的性能。</li></ul><h2 id="主存地址映射">主存地址映射</h2><h3 id="直接映射">直接映射</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.png" alt="image-20220721112338281" style="zoom:80%;" / loading="lazy"></p><p>首先要对主存按照缓存块的大小进行划分成不同的区，每个区的第一个字块都放置于Cache存储体中的第0块。CPU给出的主存地址可以分成三个部分：区号（主存字块标记），块号（Cache字块地址），偏移地址（字块内地址）。这种结构的优点是结构简单、速度快，缺点是在Cache有很多空闲的情况下仍出现Cache冲突，影响Cache利用率。</p><h3 id="全相联映射">全相联映射</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="全相联映射" style="zoom:80%;" / loading="lazy"></p><p>从全相联的结构可知，这种结构相较直接映射能够提高Cache的利用率，因为一个主存块可以被缓存到任一缓存块。但缺点也正是源于此，无法根据主存地址确定地址所在主存块会被缓存到哪个缓存块，因此在检查缓存是否命中时，需要多个比较器同时比较主存地址中主存块的块号和所有缓存标记，造成电路结构复杂，功耗也更高。</p><h3 id="组相联映射">组相联映射</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="image-20220721115852678" style="zoom:80%;" / loading="lazy"></p><p>直接映射中，一个主存块只可能被缓存到某个特定的缓存块；全相联映射正好相反，一个主存块可以被缓存到任一缓存块。可以说这两种方式走了两个极端，各有优缺点，而组相联映射是前两种映射方式的折中，实现了一个主存块可以被缓存到若干个缓存块(<strong>一组缓存块</strong>)中：</p><h2 id="替换算法">替换算法</h2><h3 id="fifo">FIFO</h3><p>先进先出置换算法。这个就是类似于队列，先装入的页面先被置换掉。易于实现但是有可能淘汰频繁使用的页面，效果不好。</p><h3 id="lru">LRU</h3><p>将近期内最久末被访问过的Cache块置换出去。</p><p>LRU算法是指:会为每一个Cache块设置一个“计数器”，用于记录每个Cache块究竟有多长时间没有被访问了。在替换时直接选取“计数器”最大的替换即可。</p><ul><li>命中时，所命中的行的计数器清零，比其低的计数器+1，其余不变</li><li>未命中且还有空闲行时，新装入的行的计数器置为0，其余非空闲行全+1</li><li>未命中且没有空闲行时，计数器最大的行的信息块被淘汰，新装入行的计数器置为0，其余全+1</li></ul><h3 id="lfu">LFU</h3><p>将一段时间内被访问次数最少的那块从Cache中置换出去</p><p>LFU算法会为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache块满后会替换计数器最小的</p><ul><li>新调入的块计数器为0，之后每访问一次计数器就+1。需要替换时，选择计数器最小的一行替换</li><li>若有多个计数器最小的行，可以按照行号递增或FIFO策略进行选择</li></ul><h3 id="随机替换">随机替换</h3><p>随机确定将哪块从Cache中替换出去。 ## 辅助存储器</p><p>其不能直接与CPU进行信息交换，最常用的辅助存储器是<strong>磁表面辅助存储器</strong></p><h3 id="磁表面辅助存储器">磁表面辅助存储器</h3><h4 id="技术指标">技术指标</h4><ol type="1"><li>记录密度：<ol type="1"><li>道密度<span class="math inline">\(D_t\)</span>：沿磁盘半径方向单位长度上的磁道数，单位为道/英寸</li><li>位密度<span class="math inline">\(D_b\)</span>：磁道单位长度上能记录的二进制代码位数，单位为位/英寸</li></ol></li><li>存储容量：一个硬盘存储器所能存储的字节长度，<span class="math inline">\(C=n*k*s\)</span></li><li>平均存取时间：存取时间是指从发出读写命令后。磁头从某一起始位置移动至新的记录位置，到开始从盘片表而读出或写入信息所需要的时间。<strong>这段时间由两个数值决定，一个是将磁头定位至所要求的磁道所需的时间，称为定位时间或寻道时间：另一个是寻道完成后至磁道上需要访问的信息到达磁头下的时间，称为等待时间</strong>，这两个时间都是随机变化的，因此往往使用平均值来表示。平均存取时间等于平均寻道时间与平均等待时间之和。平均寻道时间是最大寻道时间与最小寻道时间的平均值。</li><li>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，叫数据传输率， 传输率与存储设备和主机接口逻辑有关。从存储设备考虑，假设磁盘旋转速度为<span class="math inline">\(n\)</span>转/秒，每条磁道容量为<span class="math inline">\(N\)</span>个字节，则数据传输率<span class="math inline">\(D_r=D_b*V(Bps)\)</span>, 其中<span class="math inline">\(D_b\)</span>为位密度，<span class="math inline">\(V\)</span>为磁盘旋转的线速度。</li><li>误码率：出错的信息位数与读出信息位总数之比</li></ol><h4 id="磁记录原理">磁记录原理</h4><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A3%81%E7%9B%98%E5%86%99.png" alt="image-20220723131552620" style="zoom:80%;" / loading="lazy"></p><p>通过写线圈通入方向不一样的电流来写入改变局部磁化单元的朝向，从而记录0与1</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A3%81%E7%9B%98%E8%AF%BB.png" alt="image-20220723131807182" style="zoom:80%;" / loading="lazy"></p><p>读写头在磁场中运动，切割磁力线，产生不同方向的电流，磁通与电势都发生变化，从而读取0和1。</p><h3 id="硬磁盘存储器">硬磁盘存储器</h3><p>硬磁盘存储器的类型：</p><ol type="1"><li>固定磁头和移动磁头</li><li>可换盘和固定盘</li></ol><p>硬磁盘存储器的结构：</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A1%AC%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png" alt="image-20220723132957919" style="zoom:80%;" / loading="lazy"></p><ul><li>磁盘控制器接受来自主机的指令，转换为磁盘驱动器的控制命令。实现主机与驱动器之间的数据格式转换</li><li>盘片由硬质铝合金材料制成</li></ul><h3 id="软磁盘存储器">软磁盘存储器</h3><p>时代的眼泪，就速度而言不如硬盘，磁头来说软盘的磁头都是活动的，盘片为可更换，价格低廉但是容易损坏。</p><h3 id="光盘存储器">光盘存储器</h3><p>采用光存储技术，利用激光进行读写，第一代技术采用非磁性介质，不可擦写。第二代技术采用磁性介质后可以擦写。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;摸了一周崛起，又回来上工了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220723135707.png&quot; alt=&quot;image-20220723135707436&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>提高爬虫效率</title>
    <link href="http://lapras.xyz/2022/07/10/ee385c19.html"/>
    <id>http://lapras.xyz/2022/07/10/ee385c19.html</id>
    <published>2022-07-10T12:54:00.000Z</published>
    <updated>2022-07-10T12:55:28.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>爬都可以爬</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/xigua.png" alt="99586772_p0" style="zoom: 50%;" / loading="lazy"></p><span id="more"></span><h2 id="线程进程">线程？进程？</h2><p>简单地来说，<strong>进程</strong>是<strong>系统进行资源调度和分配的的基本单位</strong>，是<strong>资源单位</strong>。比如任务管理器里面管理的就是一堆进程。而<strong>线程</strong>则是进程的子任务，<strong>是CPU调度和分派的基本单位</strong>，是<strong>执行单位</strong>。显然一个进程可以有多个线程。</p><h3 id="线程与进程的小栗子">线程与进程的小栗子</h3><p><code>Python</code>中最简单的一个多线程例子：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread<span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello new World"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  t <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>func<span class="token punctuation">)</span>  <span class="token comment"># 创建新线程并安排任务</span>  t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 标记线程为可以启动状态，但具体启动时间由系统决定</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Main thread"</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>或者也可以像<code>Java</code>中常做的那样，重写一下<code>run</code>方法</p><p><code>Python</code>中最简单的一个多线程例子：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello new World"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>func<span class="token punctuation">)</span>  p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Main process"</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li>不难发现，API长得几乎一样</li><li>如果想要对函数传参的话，需要使用<code>p = Process(target=func,args=(tuple))</code>的形式，线程同理</li></ul><h3 id="线程池和进程池">线程池和进程池</h3><p>一次性开辟若干个线程（进程），用户只需要给线程池（进程池）提交任务即可。对于具体的线程调度不需要关心</p><p><code>Python</code>的线程池</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> concurrent<span class="token punctuation">.</span>futures <span class="token keyword">import</span> ThreadPoolExecutor<span class="token punctuation">,</span> ProcessPoolExecutor<span class="token keyword">def</span> <span class="token function">fn</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  <span class="token comment"># 创建线程池</span>  <span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      t<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token string">"Thread-"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 等待所有线程结束，才继续执行守护</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ThreadPoolExecutor done"</span><span class="token punctuation">)</span></code></pre><ul><li>进程池的话，就换成<code>ProcessPoolExecutor</code>即可</li></ul><h3 id="使用线程池进行爬取">使用线程池进行爬取</h3><p>对<a href="http://xinfadi.com.cn/priceDetail.html">北京新发地的菜价</a>进行一个爬取。首先要分析一下网页，发现他的数据来源是通过更改<code>id="current"</code>标签的<code>value</code>值实现的，然后使用网络工具抓包，发现其数据是请求另一个URL后进行渲染的。所以我们请求数据页后将数据记录于csv文件中。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> csv<span class="token keyword">import</span> timef <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'xinfadi.csv'</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'w'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>csvw <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">get_one_page</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>  proxy <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'http'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7890'</span><span class="token punctuation">,</span>           <span class="token string">'https'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7890'</span><span class="token punctuation">&#125;</span>  url <span class="token operator">=</span> <span class="token string">"http://xinfadi.com.cn/getPriceData.html"</span>  headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36'</span><span class="token punctuation">,</span>    <span class="token string">'referer'</span><span class="token punctuation">:</span> <span class="token string">"http://xinfadi.com.cn/priceDetail.html"</span><span class="token punctuation">&#125;</span>  data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'current'</span><span class="token punctuation">:</span> value<span class="token punctuation">&#125;</span>  resp <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span> proxies<span class="token operator">=</span>proxy<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>  resp<span class="token punctuation">.</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span>  res <span class="token operator">=</span> resp<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'list'</span><span class="token punctuation">]</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> res<span class="token punctuation">:</span>    <span class="token comment"># 写入csv</span>    csvw<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span>i<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'the </span><span class="token interpolation"><span class="token punctuation">&#123;</span>value<span class="token punctuation">&#125;</span></span><span class="token string"> page done'</span></span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  <span class="token comment"># 计算时间</span>  start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    get_one_page<span class="token punctuation">(</span>i<span class="token punctuation">)</span>  end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'总共用时</span><span class="token interpolation"><span class="token punctuation">&#123;</span>end <span class="token operator">-</span> start<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span></code></pre><p>试着爬取100页的数据，发现耗时为68.33s，而数据库有16000页。这显然太慢了。所以使用线程池的方式进行一个改写。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> concurrent<span class="token punctuation">.</span>futures <span class="token keyword">import</span> ThreadPoolExecutor<span class="token punctuation">,</span> ProcessPoolExecutor<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  <span class="token comment"># 计算时间</span>  start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 使用线程池</span>  <span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      t<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>get_one_page<span class="token punctuation">,</span> i<span class="token punctuation">)</span>  end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'总共用时</span><span class="token interpolation"><span class="token punctuation">&#123;</span>end <span class="token operator">-</span> start<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span></code></pre><p>使用了50个线程的表现为12s，显然有质的提升</p><h2 id="协程">协程？</h2><p>众所周知，当程序处于I/O操作时，线程往往会处于堵塞状态。比如用 requests 发请求，或者读写数据库。如果我们能在堵塞状态时也能执行别的事情，那么效率就会提高。协程就是可以当线程堵塞时，选择性地切换到别的任务，提高CPU的利用率。所以即使在<strong>单线程</strong>的条件下，我们也能看到多个任务"同时"进行的现象。</p><h3 id="多任务异步协程">多任务异步协程</h3><p>下面举个经典例子来说明协程的含金量</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> time<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'func1'</span><span class="token punctuation">)</span>  <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'func1'</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'func2'</span><span class="token punctuation">)</span>  <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'func2'</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'func3'</span><span class="token punctuation">)</span>  <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'func3'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>  tasks <span class="token operator">=</span> <span class="token punctuation">[</span>func1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> func2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> func3<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span>  loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>  end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'总共用时</span><span class="token interpolation"><span class="token punctuation">&#123;</span>end <span class="token operator">-</span> start<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span></code></pre><ol type="1"><li>将任务声明为协程对象，即使用<code>async def</code>的方式定义函数。任何调用该函数的行为返回的都是一个<code>coroutine object</code>，而非运行其中的代码。如果想要运行其中的函数，则需要满足进入<code>async</code>模式且<code>coroutine</code>变为<code>task</code></li><li>正常的Python代码都是<code>sync</code>也就是同步模式，想要切换到<code>async</code>模式。我们通常使用<code>asyncio.run()</code>（Python &gt;= 3.7），其参数为<code>coroutine</code>，它会建立<code>event loop</code>并把参数<code>coroutine</code>变为其中的第一个<code>task</code>开始运行</li><li>能被 <code>await</code>的对象有3种：<code>coroutine</code>、<code>task</code>和<code>future</code>。</li><li>当你<code>await coroutine</code>时，<span class="math inline">\(Don&#39;t \ do\  that\)</span>。直接这样做就与同步别无二致。</li><li>所以我们需要直接<code>await task</code>，<code>event loop</code>就直接给出控制权，并在结束时记录返回值。这也就需要我们提前使用<code>asyncio.create_task(coroutine obj)</code>注册<code>task</code></li><li>那么如果有很多<code>task</code>需要注册呢？则可以用<code>asyncio.gather()</code>。其会返回一个<code>future</code>，参数为若干个可<code>await</code>的对象。<code>task</code>会被注册到<code>event loop</code>中，如果是<code>coroutine</code>则首先会被包装成<code>task</code>再注册到<code>event loop</code>中。然后返回的<code>future</code>其目的是告知<code>event loop</code>需要完成其中所有的<code>task</code>后才能继续执行。最后返回其中所有<code>task</code>的<code>return</code>值按照顺序返回到一个<code>list</code>中。</li></ol><h3 id="aiohttp">aiohttp</h3><p>因为异步中不能使用<code>requests</code>，所以需要使用<code>aiohttp</code>，下面是稍加改动后的官网的例子</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> aiohttp<span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">fetch</span><span class="token punctuation">(</span>session<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">async</span> <span class="token keyword">with</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token keyword">as</span> response<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> response<span class="token punctuation">.</span>status<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">async</span> <span class="token keyword">with</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> session<span class="token punctuation">:</span>    text<span class="token punctuation">,</span> status_code <span class="token operator">=</span> <span class="token keyword">await</span> fetch<span class="token punctuation">(</span>session<span class="token punctuation">,</span> <span class="token string">"http://httpbin.org/get"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"text:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>text<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token format-spec">100]</span><span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"code:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>status_code<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>大体上与<code>request.session</code>的操作方式相同。首先用<code>async with aiohttp.ClientSession() as session:</code>注册一个支持异步的上下文客户端会话管理器<code>session</code>，用<code>session</code>去异步地发送请求<code>async with session.get(url) as response:</code>此时可以添加<code>params,headers,data,cookies</code>。最后使用<code>await resp.json() or .text() or .read()</code>来得到数据</p><p>下面给出一个常用框架：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> aiohttp<span class="token keyword">import</span> asyncio<span class="token keyword">def</span> <span class="token function">get_tasks</span><span class="token punctuation">(</span>session<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">"""  获取任务列表  :param 客户端会话  :return: 任务列表  """</span>  tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    tasks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>fetch<span class="token punctuation">(</span>session<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> tasks<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">fetch</span><span class="token punctuation">(</span>session<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">"""  异步获取网页的具体过程  :param 客户端会话  :return: 网页的数据  """</span>  <span class="token keyword">async</span> <span class="token keyword">with</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://httpbin.org/get'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> resp<span class="token punctuation">:</span>    <span class="token comment"># 断言，如果状态码不是 200，则抛出异常</span>    <span class="token keyword">assert</span> resp<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> resp<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token keyword">async</span> <span class="token keyword">with</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> session<span class="token punctuation">:</span>    tasks <span class="token operator">=</span> get_tasks<span class="token punctuation">(</span>session<span class="token punctuation">)</span>    responses <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token operator">*</span>tasks<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>responses<span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="参考">参考</h2><p>https://www.kingname.info/2020/03/23/insert-sprit/</p><p>https://www.bilibili.com/video/BV1oa411b7c9</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;爬都可以爬&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/xigua.png&quot; alt=&quot;99586772_p0&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫学习" scheme="http://lapras.xyz/categories/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Python" scheme="http://lapras.xyz/tags/Python/"/>
    
    <category term="爬虫" scheme="http://lapras.xyz/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python网页解析库小介绍</title>
    <link href="http://lapras.xyz/2022/07/09/f8dd4268.html"/>
    <id>http://lapras.xyz/2022/07/09/f8dd4268.html</id>
    <published>2022-07-09T02:57:00.000Z</published>
    <updated>2022-07-25T17:47:33.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在用<code>Python</code>进行网络爬虫，拿到HTML内容之后势必要对其进行一些内容上的解析。之前用过正则表达式<code>re</code>和<code>BeautifulSoup</code>。前者速度挺快的，但是代码可读性较差。后者虽然简单，但是速度令人捉急。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220709111111.jpg" alt="92274729_p0_master1200" style="zoom:80%;" / loading="lazy"></p><span id="more"></span><p>先放个速度对比图，数据来源<a href="https://zhuanlan.zhihu.com/p/25887452">知乎-拒绝撕逼，用数据来告诉你选择器到底哪家强</a></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220726005550.png" alt="img" style="zoom:80%;" / loading="lazy"></p><h2 id="xpath">XPath</h2><p><code>XPath</code>是一门在<code>XML</code>⽂档中查找信息的语言.<code>XPath</code>可用来在<code>XML</code>文档中对元素和属性进行遍历。而我们熟知的<code>HTML</code>恰巧属于<code>XML</code>。 所以完全可以用其进行解析。</p><h3 id="xml基本知识">XML基本知识</h3><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>book</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>高等数学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>price</span><span class="token punctuation">></span></span>28.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>price</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>author</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nick</span><span class="token punctuation">></span></span>武钟祥<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nick</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nick</span><span class="token punctuation">></span></span>张宇<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nick</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>author</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>book</span><span class="token punctuation">></span></span></code></pre><ul><li>DOM 将 HTML 表示为标签的树形结构。</li><li>每一对标签都是一个节点</li><li><strong>标签中的属性及文本也可视为该节点的子节点</strong></li><li>节点之间有父子关系，同胞关系。以及先辈和后裔这种一代及以上的关系</li><li>利用缩进，可以很好的理解这些概念</li></ul><h3 id="安装导入">安装导入</h3><pre class="language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> lxml -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><p>有很多库都提供了 Xpath 解析的方法，这里选择 <code>lxml</code>。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> lxml <span class="token keyword">import</span> etree<span class="token comment"># 或者</span><span class="token keyword">from</span> lxml <span class="token keyword">import</span> htmletree <span class="token operator">=</span> html<span class="token punctuation">.</span>etree</code></pre><h3 id="解析过程">解析过程</h3><ol type="1"><li>准备源文件</li><li>得到解析对象<code>et = etree.HTML(html)</code></li><li>使用<code>xpath</code>方法进行解析，视情况选择直接解析或者进一步<code>for</code>循环解析。</li></ol><h3 id="具体方法介绍">具体方法介绍</h3><ol type="1"><li><p>节点选取</p><ul><li>node：选取此节点的所有子节点</li><li><code>/</code>：从根节点选取</li><li><code>//</code>：从当前节点选择文档中后裔节点</li><li><code>.</code>：选取当前节点</li><li><code>..</code>：选取当前节点的父节点</li><li><code>@</code>：选取属性</li></ul></li><li><p>节点选取举例</p><table><thead><tr class="header"><th>表达式</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>bookstore</td><td>选取 bookstore 元素的所有子节点</td></tr><tr class="even"><td>/ bookstore</td><td>选取根元素 bookstore ，相当于绝对路径的写法</td></tr><tr class="odd"><td>bookstore/book</td><td>选取属于 bookstore 的子元素的所有 book 元素</td></tr><tr class="even"><td>//book</td><td>选取所有 book 子元素，而不管它们在文档中的位置</td></tr><tr class="odd"><td>bookstore//book</td><td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置</td></tr><tr class="even"><td>//<span class="citation" data-cites="lang">@lang</span></td><td>选取名为 lang 的所有属性</td></tr></tbody></table></li><li><p>值筛选</p><p>上述表达式都会返回一个<code>Element</code>类的列表，我们可以在<strong>表达式中</strong>使用<code>[]</code>进行进一步筛选节点。</p><p>用法为在任意节点后添加<code>[]</code>，里面的表达式可以为：</p><ul><li><code>1</code>：选取该节点的第一个元素</li><li><code>last()</code>：选取该节点的最后一个元素</li><li><code>position()</code>：选取位置符合布尔表达式的元素。比如<code>position()&gt;4</code>。</li><li><code>@lang</code>：选取拥有名为 lang 的属性的该节点元素。比如<code>//title[@lang]</code>表示选取所有拥有名为 lang 的属性的 title 元素</li><li><code>@lang='xx'</code>：选取拥有名为 lang 的属性且值为 xx 的该节点元素</li><li><code>contains(@属性,"值")</code>：选取属性包含有某个值的节点元素</li><li>可以搭配<code>and or |</code>使用</li></ul></li><li><p>通配符</p><ul><li><code>*</code>：匹配任何元素节点</li><li><code>@*</code>：匹配任何属性节点</li><li><code>node()</code>：匹配任何节点</li></ul></li><li><p>获取数据</p><ul><li><code>/text()</code>：获取节点文本内容</li><li><code>/@属性</code>：获取节点某个属性的内容</li></ul></li></ol><h3 id="浏览器工具">浏览器工具</h3><ol type="1"><li><p>首先当然是万能的<code>F12</code>。可以通过右键元素选择检查，找到元素的相对位置</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220708154611.png" alt="F12检查" / loading="lazy"><figcaption aria-hidden="true">F12检查</figcaption></figure><p>同时，在开发者工具的<code>Element</code>中搜索时可以使用<code>XPath</code>表达式进行检索。也可以右键元素，选择复制<code>XPath</code></p></li><li><p><code>selectorshub</code>这个浏览器插件，可以直接生成 xpath, cssSelector, Playwright selectors , jQuery, JS Path 等路径</p></li></ol><h3 id="小栗子">小栗子</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> lxml <span class="token keyword">import</span> etree<span class="token keyword">import</span> requests<span class="token comment"># 爬取B站排行榜</span>url <span class="token operator">=</span> <span class="token string">'https://www.bilibili.com/v/popular/rank/all'</span>headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36'</span><span class="token punctuation">&#125;</span>proxy <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'http'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7890'</span><span class="token punctuation">,</span>         <span class="token string">'https'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7890'</span><span class="token punctuation">&#125;</span>resp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">,</span> proxies<span class="token operator">=</span>proxy<span class="token punctuation">)</span>resp<span class="token punctuation">.</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span><span class="token comment"># etree把网页内容转换成可以操作的对象</span>et <span class="token operator">=</span> etree<span class="token punctuation">.</span>HTML<span class="token punctuation">(</span>resp<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment"># 获取排行榜的标题</span>titles <span class="token operator">=</span> et<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span><span class="token string">"//div[@class='info']/a/text()"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>titles<span class="token punctuation">)</span></code></pre><h2 id="pyquery">Pyquery</h2><p>与 JS 中使用的 Jquery 基本相同，都是使用 CSS 选择器达到解析的目的。</p><h3 id="常用的css选择器">常用的CSS选择器</h3><ol type="1"><li>标签选择器<code>Label</code>：选择器名和指定的HTML元素名的不区分大小写的匹配。这是选择所有指定类型的最简单方式</li><li>类选择器<code>.Label</code>：类名是在HTML class文档元素属性中没有空格的任何值。类 Class 是可以重复且有多个的</li><li>ID选择器<code>#Label</code>： 任何元素都可以使用 id 属性设置唯一的 ID 名称。 这是选择单个元素的最有效的方式</li><li>通配选择器<code>*</code>：选择在一个页面中的所有元素,常常搭配使用</li><li>组合器分组<code>Label1, Label2......</code>：选择所有出现的Label</li><li>后代选择器<code>Label1 Label2</code>：选择<code>Label1</code>中的所有<code>Label2</code>后裔</li><li>子选择器<code>Label1 &gt; Label2</code>：选择<code>Label1</code>中的所有<code>Label2</code>直接后代</li><li>相邻兄弟选择器<code>Label1+Label2</code>：选择<code>Label2</code>元素，它是<code>Label1</code>的下一个直接兄弟元素</li><li>通用兄弟选择器<code>Label1~Label2</code>：选择<code>Label2</code>元素，它是<code>Label1</code>的兄弟元素</li><li>属性选择器<code>Label[attr]</code>表示选择包含 attr 属性的所有元素，<code>Label[attr]=val</code>表示仅选择 attr 属性被赋值为 val 的所有元素，<code>[attr~=val]</code>：该选择器仅选择 attr 属性的值（以空格间隔出多个值）中有包含 val 值的所有元素</li><li>伪类选择器：内容繁多，功能丰富。详见<a href="https://www.w3school.com.cn/css/css_pseudo_classes.asp">w3c</a></li></ol><h3 id="安装导入-1">安装导入</h3><pre class="language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> pyquery -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pyquery <span class="token keyword">import</span> PyQuery <span class="token keyword">as</span> pq</code></pre><h3 id="解析过程-1">解析过程</h3><ol type="1"><li>准备源文件</li><li>得到解析对象<code>doc = pq(resp.text)</code></li><li>使用<code>doc(CSS选择器表达式)</code>的方式获取<code>HTML</code>内容</li><li>使用<code>.text()</code>获取文本，使用<code>.attr('属性')</code>获取属性值</li><li>使用<code>.attr('属性', '值')</code>来修改属性或者添加属性</li><li>使用<code>.children(css)</code>查找子节点，<code>.find(css)</code>查找子孙节点</li><li>使用<code>.parent(css)</code>查找父节点，<code>.parents(css)</code>查找祖先节点</li><li>使用<code>.siblings(css)</code>查找兄弟节点</li><li>如果选择的内容超过一条后想要获取他们的文本属性值，则需使用<code>.items()</code>，返回一个迭代器后使用<code>for</code>迭代或者使用<code>list comprehension</code></li></ol><h3 id="小例子">小例子</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pyquery <span class="token keyword">import</span> PyQuery <span class="token keyword">as</span> pq<span class="token keyword">import</span> requests<span class="token comment"># 爬取B站排行榜</span>url <span class="token operator">=</span> <span class="token string">'https://www.bilibili.com/v/popular/rank/all'</span>headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36'</span><span class="token punctuation">&#125;</span>proxy <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'http'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7890'</span><span class="token punctuation">,</span>         <span class="token string">'https'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7890'</span><span class="token punctuation">&#125;</span>resp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">,</span> proxies<span class="token operator">=</span>proxy<span class="token punctuation">)</span>resp<span class="token punctuation">.</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span><span class="token comment"># pyquery把网页内容转换成可以操作的对象</span>p <span class="token operator">=</span> pq<span class="token punctuation">(</span>resp<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment"># 获取排行榜的标题</span>items <span class="token operator">=</span> p<span class="token punctuation">(</span><span class="token string">'.rank-list .info>a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span>title <span class="token operator">=</span> <span class="token punctuation">[</span>item<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> items<span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span></code></pre><h2 id="parsel">Parsel</h2><p>Parsel 这个库可以解析 HTML 和 XML，同时支持 CSS 和 XPath 两种解析方式并融合了正则表达式的提取功能。<a href="https://scrapy.org/">scrapy</a>选择器部分也是基于此二次封装的产物。</p><h3 id="安装导入-2">安装导入</h3><pre class="language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> parsel -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> parsel <span class="token keyword">import</span> Selector</code></pre><h3 id="解析过程-2">解析过程</h3><ol type="1"><li><p>首先创建一个<code>Selector</code>对象，传入 HTML 字符串。</p><pre class="language-python" data-language="python"><code class="language-python">selector <span class="token operator">=</span> Selector<span class="token punctuation">(</span>text <span class="token operator">=</span> HTML<span class="token punctuation">)</span></code></pre></li><li><p>使用<code>.css()</code>或者<code>.xpath()</code>进行解析，并通过CSS中的<code>::text</code>或者<code>::attr(属性)</code>，通过<code>XPath</code>的<code>/text()</code>和<code>/@属性</code>获取内容，返回一个<code>SelectorList</code>迭代对象</p></li><li><p><code>SelectorList</code>进行遍历用<code>.get()</code>获取内容文本，或者<code>.getall()</code>返回内容文本列表</p></li><li><p><code>SelectorList</code>使用<code>.re()</code>可以使用正则表达式进一步提取内容并返回列表</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在用&lt;code&gt;Python&lt;/code&gt;进行网络爬虫，拿到HTML内容之后势必要对其进行一些内容上的解析。之前用过正则表达式&lt;code&gt;re&lt;/code&gt;和&lt;code&gt;BeautifulSoup&lt;/code&gt;。前者速度挺快的，但是代码可读性较差。后者虽然简单，但是速度令人捉急。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220709111111.jpg&quot; alt=&quot;92274729_p0_master1200&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫学习" scheme="http://lapras.xyz/categories/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Python" scheme="http://lapras.xyz/tags/Python/"/>
    
    <category term="爬虫" scheme="http://lapras.xyz/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（三）</title>
    <link href="http://lapras.xyz/2022/06/30/26b9f9fa.html"/>
    <id>http://lapras.xyz/2022/06/30/26b9f9fa.html</id>
    <published>2022-06-30T14:58:07.000Z</published>
    <updated>2022-06-30T15:14:35.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>市原大輔走了，但没完全走。崛起你真的好温柔。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220630231342.jpg" alt="91953835_p0_master1200" style="zoom:80%;" / loading="lazy"></p><span id="more"></span><h2 id="存储器分类">存储器分类</h2><h3 id="按存储介质分类">按存储介质分类</h3><ol type="1"><li>半导体存储器（易丢失）：TTL（集成度低，功耗高），MOS（集成度高，功耗低）</li><li>磁表面存储器：磁头(读/写)、载磁体(存储)</li><li>磁芯存储器：硬磁材料，环状元件</li><li>光盘存储器：激光(读/写)，磁光材料(存储)</li></ol><h3 id="按存取方式分类">按存取方式分类</h3><ol type="1"><li><p>存取时间与物理地址无关 (随机访问)</p><ul><li><p>随机存储器（<strong>在程序执行过程中</strong>可读可写）</p></li><li><p>只读存储器（<strong>在程序执行过程中</strong>只读）</p></li></ul></li><li><p>存取时间与物理地址有关(串行访问)</p><ul><li><p>顺序存取存储器，如磁带</p></li><li><p>直接存取存储器，如磁盘</p></li></ul></li></ol><h3 id="按在计算机中的作用分类">按在计算机中的作用分类</h3><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%89%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB.png" alt="按在计算机中的作用分类" / loading="lazy"><figcaption aria-hidden="true">按在计算机中的作用分类</figcaption></figure><ul><li><p>Cache：高速缓冲存储器，位于CPU和主存之间，用于缓存主存的数据。本质上是一块集成到CPU的SRAM。</p></li><li><p>RAM：</p><ul><li><p>静态RAM(SRAM)</p></li><li><p>动态RAM(DRAM)</p></li></ul></li><li><p>ROM：</p><ul><li><p>MROM(掩膜ROM)</p></li><li><p>PROM(可编程ROM)</p></li><li><p>EPROM(电可编程ROM)</p></li><li><p>EEPROM(电可编程可擦除ROM)</p></li></ul></li><li><p>Flash Memory（闪存）：可用于固态硬盘</p></li></ul><h2 id="存储器的层次结构">存储器的层次结构</h2><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E5%99%A8%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="image-20220628201956665" / loading="lazy"><figcaption aria-hidden="true">image-20220628201956665</figcaption></figure><ul><li>速度：从快到慢</li><li>容量：从小到大</li><li>价格：从高到低</li><li>寄存器：集成在CPU当中，I/O端口中也存在。<ul><li>从体系结构的角度，供给给机器语言程序员使用的称为体系结构寄存器。</li></ul></li><li>缓存：一部分集成在CPU当中。如果CPU需要读取或写入数据，缓存的速度更快</li></ul><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BC%93%E5%AD%98%20%E4%B8%BB%E5%AD%98%E5%B1%82%E6%AC%A1%E5%92%8C%E4%B8%BB%E5%AD%98%20%E8%BE%85%E5%AD%98%E5%B1%82%E6%AC%A1.png" alt="缓存 主存层次和主存 辅存层次" / loading="lazy"><figcaption aria-hidden="true">缓存 主存层次和主存 辅存层次</figcaption></figure><ul><li>缓存到辅存的管理由CPU提供的硬件来完成，通常软件开发者不需要了解其中的细节。</li><li>主存到辅存的管理由CPU提供的<strong>MMU</strong>以及操作系统提供的<strong>内存管理模块</strong>共同完成，不仅可以为每个进程提供<strong>独立的地址空间</strong>，还可以借助辅存让那些比主存容量还要大的程序得以运行。</li></ul><h2 id="主存储器">主存储器</h2><h3 id="概述">概述</h3><ol type="1"><li>主存的基本结构</li></ol><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="主存的基本结构" / loading="lazy"><figcaption aria-hidden="true">主存的基本结构</figcaption></figure><ul><li>MAR：记录了我们要访问的存储单元地址</li><li>MDR：记录了我们要读出或者写入的数据</li><li>具体的读还是写，则是由控制电路控制读写电路实现</li></ul><ol start="2" type="1"><li>主存和CPU联系</li></ol><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E8%81%94%E7%B3%BB.png" alt="主存和CPU联系" / loading="lazy"><figcaption aria-hidden="true">主存和CPU联系</figcaption></figure><ul><li>MDR和MAR都是集成在CPU上的，但属于主存</li><li>数据总线完成CPU和主存的信息传输</li><li>地址总线是单向的，CPU给定要访问的内存单元地址</li><li>控制信号：读取或者写入</li></ul><ol start="3" type="1"><li><p>主存中存储单元地址的分配</p><p>假设当前使用的存储器字长为32位，要存储的数为12345678H。首先根据8位一个字节，每个字节都要有一个<strong>字地址</strong>，那么一个存储单元就可以分为4个字节。<strong>字地址的选择是当前字节的第一个地址</strong>，所以根据数据的存放顺序，可以分为两种方式。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png" alt="大端和小端方式" / loading="lazy"><figcaption aria-hidden="true">大端和小端方式</figcaption></figure><ul><li>如图，每一个格子都有八位（存储两个16进制数），一行就是一个存储单元（字长为32）</li><li>字地址从0开始编号</li><li><strong>主存的寻址方式</strong>：按字节寻址（每个地址对应一个字节）和按字寻址（每个地址对应一个字）</li></ul></li><li><p>主存的技术指标</p><ul><li><p>存储容量：存放二进制数据的总位数或总字节数</p></li><li><p>存储速度：</p><ul><li>存取时间：存储器的访问(读/写)时间，即给出地址信号到访问完成所需的时间</li><li>存取周期：<strong>连续</strong>两次<strong>独立</strong>的存储器访问操作所需的<strong>最小</strong>时间间隔，通常<strong>大于</strong>存取时间</li></ul></li><li><p>存储器的带宽：单位时间内写入的位数</p></li></ul></li></ol><h3 id="半导体芯片简述">半导体芯片简述</h3><ol type="1"><li><p>半导体芯片的存储结构</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%8A%E5%AF%BC%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="半导体芯片的存储结构" / loading="lazy"><figcaption aria-hidden="true">半导体芯片的存储结构</figcaption></figure><ul><li>地址线：单向，由CPU或I/O设备</li><li>数据线：双向，读取向外，写入向内</li><li><strong>芯片容量</strong>：假设地址线有<span class="math inline">\(n\)</span>条，数据线有<span class="math inline">\(m\)</span>条。则芯片容量为<span class="math inline">\(m*2^n\)</span>位，通常将<span class="math inline">\(2^n\)</span>表示为<span class="math inline">\(K\)</span>的形式，即<span class="math inline">\(2^{10}\)</span>为<span class="math inline">\(1K\)</span>。然后写为 <span class="math inline">\(\alpha K \times m\)</span>位 ，其中<span class="math inline">\(\alpha\)</span>为系数</li><li>片选线：传输片选信号，用来选中具体的芯片（存储器可能由多个存储芯片构成）。表示为<span class="math inline">\(\overline{CS},\overline{CE}\)</span></li><li>读写控制线：<span class="math inline">\(\overline {WE}\)</span>（低电平写，高电平读），或者用两根线表示：<span class="math inline">\(\overline{OE},\overline{WE}\)</span></li></ul></li><li><p>半导体存储芯片扩展</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E6%89%A9%E5%B1%95.png" alt="存储芯片扩展" / loading="lazy"><figcaption aria-hidden="true">存储芯片扩展</figcaption></figure><p>首先是位扩展：将8片一位的并为一组，则得到<span class="math inline">\(16K \times 8\)</span>位存储器</p><p>然后是字扩展：复制为4组即可得到<span class="math inline">\(64K \times 8\)</span>位存储器</p><p>所以一共使用了32片存储芯片，即其存储容量的倍数关系</p></li><li><p>半导体芯片的译码驱动方式</p><p>线选法</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BA%BF%E9%80%89%E6%B3%95.png" alt="线选法" / loading="lazy"><figcaption aria-hidden="true">线选法</figcaption></figure><p>线选法主要是通过地址译码器，走指定字线到目标的存储单元。并且根据读写控制电路选择数据的流通方向。显然这样做系统的结构非常清晰，但是内部字线的数量会随着地址增加而变得非常臃肿。</p><p>重合法</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%87%8D%E5%90%88%E6%B3%95.png" alt="重合法" / loading="lazy"><figcaption aria-hidden="true">重合法</figcaption></figure><p>重合法将所有的存储单元形成一个矩阵布局。通过行（X地址）列（Y地址）分别进行译码操作。</p></li></ol><h3 id="随机存取存储器ram">随机存取存储器（RAM）</h3><h4 id="静态ramsram">静态RAM（SRAM）</h4><p>SRAM使用<strong>触发器</strong>来保存0和1这两个状态。具体的电路实现就省略了。下面开始举例：</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Intel%202114.png" alt="Intel 2114" / loading="lazy"><figcaption aria-hidden="true">Intel 2114</figcaption></figure><ul><li><span class="math inline">\(\overline {WE}\)</span>：读写控制</li><li><span class="math inline">\(\overline {CS}\)</span>：片选信号，只有当其为低电平时，该芯片被选中</li><li><span class="math inline">\(A\)</span>：地址线，一共有10条，说明是地址位为<span class="math inline">\(1K\)</span></li><li><span class="math inline">\(I/O\)</span>：数据线，一共有4条，说明数据位为4</li></ul><p>下面举个例子，将2114拼成一个64X64的存储阵列，通过重合法，一次<strong>读取同一行的四列数据</strong></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/64X64%202114.png" alt="64X64 2114" / loading="lazy"><figcaption aria-hidden="true">64X64 2114</figcaption></figure><ul><li>不难发现，行地址全部正常编号。列地址只使用了4位，即编号16个地址。那么将列数64与16相除，得到四组。这样一来每次就能实现选取同一行的四列数据</li></ul><h4 id="动态ramdram">动态RAM（DRAM）</h4><p>DRAM使<strong>用电容存储电荷的方式来存储1，0</strong>。读数据时，当电容是高电平的时候为1，低电平的时候为0。写数据时，写1就是为电容充电，写0则是电容放电。由于电容会通过电路漏电，时间一久电荷就会流失，导致信息丢失，因此需要周期性的刷新电容(为电容充电)。其具体电路实现分为<strong>单管</strong>和<strong>三管</strong></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220629125609.png" alt="Intel1103-DRAM三管读取数据" / loading="lazy"><figcaption aria-hidden="true">Intel1103-DRAM三管读取数据</figcaption></figure><ul><li>由图易得，是<span class="math inline">\(1K \times 1\)</span>位的存储器。通过重合法进行译码</li><li>首先是行地址，注意这里除了5位行地址，还包括一位读取信号。列地址同理</li><li>得到数据后，通过读写控制电路向外界传输</li></ul><h4 id="动态ram的刷新">动态RAM的刷新</h4><p>回想动态RAM的操作过程，首先是行地址取出一整行的数据到某条选择线上。这时我们在选择线上加装一个刷新放大器，即可保存原本的数值。所以，<strong>刷新只与行地址有关，每次刷新一行</strong></p><ol type="1"><li>集中刷新：存在死区</li><li>分散刷新：无死区，但读写周期加长，性能变差</li><li>异步刷新：存在小死区，但是如果安排得当。比如放置在CPU进行指令译码时，则无死区。</li></ol><h4 id="动态ram和静态ram比较">动态RAM和静态RAM比较</h4><ol type="1"><li>存储原理：输出DRAM使用电容存储数据；SRAM使用触发器存储数据</li><li>集成度：DRAM的基本单元电路结构更简单，方便大规模集成，因此DRAM集成度更高</li><li>引脚数量：DRAM通常将行列地址复用引脚，因此引脚数量少(进而芯片封装的体积较小)；而SRAM出于速度的考虑，一般不会这样做</li><li>功耗：DRAM的功耗主要消耗在电容充放电，功耗较小；SRAM的使用触发器存放数据，而构成触发器的管子有部分是一直导通的，也就一直消耗功率，因此功耗较大</li><li>价格：同样存储一个bit，DRAM的单元电路简单，价格低；SRAM的单元电路复杂，用的管子多，因此价格高</li><li>速度：访问DRAM伴随着电容的充放电，因此速度较慢；而SRAM采用chu'fa，访问速度快</li><li>刷新：DRAM需要周期性的刷新其中的电容，才能保持数据；SRAM则没有这个需要。</li></ol><h3 id="只读存储器rom">只读存储器（ROM）</h3><p>ROM的发展历程</p><ol type="1"><li>早期的ROM在出厂时就会被厂家烧写好内容，且不支持用户再次对ROM进行编程</li><li>用户可以使用专门的擦写设备对芯片进行一次擦写，<strong>仅可擦写一次</strong></li><li>用户可以使用专门的擦写设备对芯片进行多次擦写，比如用紫外线擦写的EPROM，这时候擦写还比较麻烦</li><li>EEPROM的出现使得用户可以多次擦写ROM，且无需使用专门的擦写设备</li></ol><h4 id="几种rom的简介">几种ROM的简介</h4><ul><li>MROM（掩模式只读存储器）：<strong>行列选择线交叉处有MOS管则表示1，无MOS管则表示0。</strong>因为有无MOS管在芯片生产出来后就决定了，因此不可编程。</li><li>PROM（可编程只读存储器）：通常实现为在行列选择线之间<strong>添加一根熔丝</strong>，编程时需要写0则加大电流让熔丝熔断，否则熔丝连通表示1。由于熔丝熔断后不可在连接，因此<strong>只可进行一次编程</strong>。</li><li>EPROM（可擦除可编程式只读存储器）：EPROM可通过对芯片中的<strong>N型沟道浮动栅MOS管</strong>的D端加电压，形成浮动栅，进而电路不导通表示0，反之表示1。浮动栅可由<strong>紫外线照射后消除</strong>，因此可以利用紫外线实现芯片的全部擦写，从而实现芯片的多次编程。</li><li>EEPROM（电子式可擦除可编程只读存储器）：EEPROM改进了芯片的擦写功能，实现了电可擦写，且既可局部擦写也可全局擦写。</li><li>Flash Memory（闪存）：，较EEPROM成本更低，单元电路更为简单，集成度高，访问速度也更快。不过寿命不如EEPROM，因此闪存通常用于保存大量数据，而EEPROM则用于存放不需要经常改变的一些系统参数(数据量少)。只有少数支持片上执行(XIP)的闪存(如NorFlash)才可以作为主存储器，存放程序(不可以随机写，因此无法存放程序运行时加工的数据)。而大部分闪存一般用作辅存。</li></ul><h3 id="存储器的扩展">存储器的扩展</h3><h4 id="位扩展">位扩展</h4><p>电路连接时，两块或多块芯片共用地址线，数据线则分别与CPU的不同数据线连接，片选和读写控制连接在一起，实现同时读，同时写。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="2片1Kx4组成1Kx8" / loading="lazy"><figcaption aria-hidden="true">2片1Kx4组成1Kx8</figcaption></figure><h4 id="字扩展">字扩展</h4><p>电路连接时，共用低位的地址线，片选信号则通过译码器连接CPU地址线的高位，芯片数量少时，也可以不用译码器，直接使用非门</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%97%E6%89%A9%E5%B1%95.png" alt="2片1Kx8组成2Kx8" / loading="lazy"><figcaption aria-hidden="true">2片1Kx8组成2Kx8</figcaption></figure><h4 id="字位扩展">字、位扩展</h4><p>先按位扩展将多个芯片组成一个位数更多的芯片组，各组之间再按照字扩展的连接方式与CPU连接</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/8%E7%89%871Kx4%E7%BB%84%E6%88%904Kx8.png" alt="8片1Kx4组成4Kx8" / loading="lazy"><figcaption aria-hidden="true">8片1Kx4组成4Kx8</figcaption></figure><h3 id="存储器与cpu的连接">存储器与CPU的连接</h3><ol type="1"><li>地址线的连接</li><li>数据线的连接</li><li>读/写命令线的连接</li><li>片选线的连接</li><li>合理选择存储芯片：系统配置和系统程序使用ROM，用户程序选择RAM。</li><li>其他 时序、负载</li></ol><h3 id="对存储器进行校验">对存储器进行校验</h3><p>复杂的电磁环境下，工作中的存储器受到干扰，可能导致其内部存储的1、0发生翻转，即1变成0、0变成1，这样存储的信息就出错了。如果我们无法得知这一情况，而在程序中使用了错误的数据，那么就可能造成损失。</p><p>一个编码集合中，任意两个合法编码之间<strong>二进制位数</strong>的<strong>最少差异</strong>称为<strong>编码的最小距离</strong>，编码的纠错和检错能力与其最小距离有关。具体关系如下： <span class="math display">\[L - 1 = D + C (D &gt;= C)\]</span></p><ul><li>L：编码的最小距离</li><li>D：能够检错的位数</li><li>C：能够纠错的位数</li></ul><p>常用的检验方法有奇偶校验，海明码，CRC循环校验</p><h4 id="奇偶校验">奇偶校验</h4><p>奇校验：使待校验bit串和校验位共有<strong>奇数</strong>个1</p><p>偶校验：使待校验bit串和校验位共有<strong>偶数</strong>个1</p><h4 id="海明码汉明码">海明码（汉明码）</h4><p>是一种多重分组奇偶校验。将数据组织为<span class="math inline">\(k\)</span>个分组，每组进行奇偶校验。不仅能检验是否出错，也能定位错误，但定位代价较大，假设有<span class="math inline">\(n\)</span>位有效码，设置了<span class="math inline">\(k\)</span>位校验码，则<span class="math inline">\(n\)</span>与<span class="math inline">\(k\)</span>关系为 <span class="math display">\[2^k≥n + k + 1\]</span> + 假设有<span class="math inline">\(k\)</span>个校验位，一位有0或1两种情况，<span class="math inline">\(k\)</span>位就有<span class="math inline">\(2^k\)</span>种排列情况，能表示<span class="math inline">\(2^k\)</span>种状态。其中一个状态用来表示正确（没有错误发生）的这种情况。其余的<span class="math inline">\(2^k-1\)</span>种状态来表示错误发生在哪一位。总共有<span class="math inline">\(n+k\)</span>位，所以<span class="math inline">\(2^k-1\)</span>要大等于<span class="math inline">\(n+k\)</span>。</p><ul><li><p>海明码的校验码总是放在<span class="math inline">\(2^i,i=0,1,2,3...\)</span></p></li><li><p>把海明码（有效码和校验码的结合）从左到右，从<strong>1</strong>开始编号<span class="math inline">\(C_1C_2n_3C_4n_5n_6n_7C_8...\)</span></p></li><li><p>各检验码负责的部分：<span class="math inline">\(C_i\)</span>负责检验第<span class="math inline">\(i\)</span>位为1的编号</p></li><li><p>校验码的数值 = 它所负责的有效码的异或（偶校验规则下）或者凑偶数个1</p></li><li><p>海明码的纠错过程：</p><ol type="1"><li>接收方先根据数据长度确定<span class="math inline">\(k\)</span></li><li>增设检验位<span class="math inline">\(P_i\)</span>，比如假设此时<span class="math inline">\(k=3\)</span>，则新的检验码为<span class="math inline">\(P_4P_2P_1\)</span></li><li>根据检验码的规则计算<span class="math inline">\(P_i\)</span>，比如偶规则下，<span class="math inline">\(P_1 = 1\oplus 3 \oplus 5\oplus7\)</span></li><li>得到二进制表示的检验码<span class="math inline">\(P\)</span>，换算成10进制即可得到哪一位出错了。如果是全0则表示无错误</li></ol></li><li><p>海明距离：是字符串相对于同样长度的零字符串的汉明距离，也就是说，它是字符串中非零的元素个数：对于二进制字符串来说，就是1的个数，所以11101的汉明重量是4。</p></li></ul><h3 id="提高访存速度的措施">提高访存速度的措施</h3><blockquote><ol type="1"><li>采用高速组件</li><li>采用层次结构 Cache-主存</li><li>调整主存结构</li></ol></blockquote><p>下面介绍通过调整主存结构的方式：</p><ol type="1"><li><p>单体多字系统</p><p>将存储器的和CPU的存储控制器的位宽设置为CPU字长(寄存器宽度)的整数倍，一次性可以读出多条指令或数据，缺点是写的时候，如果仅写一个字的内容比较麻烦，需要相应的硬件配合。</p></li><li><p>多体并行系统 主要思想是采用多个存储器并行工作，CPU访问第一个存储器后，在读到数据前，无需等待，直接访问下一个存储器。这样一轮下来，第一个存储器已经准备好了数据，并能够接收下一次访问(存取周期已到)，于是再来一轮。如此，CPU和存储器都不会空闲。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;市原大輔走了，但没完全走。崛起你真的好温柔。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220630231342.jpg&quot; alt=&quot;91953835_p0_master1200&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Python求解规划类问题</title>
    <link href="http://lapras.xyz/2022/06/29/d7cb7c5c.html"/>
    <id>http://lapras.xyz/2022/06/29/d7cb7c5c.html</id>
    <published>2022-06-29T15:08:00.000Z</published>
    <updated>2022-06-29T15:09:08.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>摸鱼，等崛起的神威太刀。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B3%A1%E5%A3%B6%E9%BE%99%E5%A4%AA%E5%88%80.jpg" alt="89249011_p1_master1200" style="zoom: 67%;" / loading="lazy"></p><span id="more"></span><h2 id="线性规划">线性规划</h2><p><strong>生产问题，投料问题</strong></p><p>线性规划求解需要确定目标函数（<span class="math inline">\(max，min\)</span>）和约束条件（<span class="math inline">\(s.t.\)</span>）</p><p>求解前应该转为标准形式，即不等式约束，等式约束以及范围约束： <span class="math display">\[\min \mathrm{c}^{T} x \\\begin{equation}\text { s.t. }\left\{\begin{array}{c}A x \leq b \\A e q * x=b e q \\l b \leq x \leq u b\end{array}\right.\end{equation}\]</span></p><ul><li><span class="math inline">\(c^T\)</span>为目标函数系数<strong>向量</strong></li><li><span class="math inline">\(A\)</span>为不等式组系数<strong>矩阵</strong>，<span class="math inline">\(b\)</span>为不等式组常数<strong>向量</strong></li><li><span class="math inline">\(Aeq\)</span>为等式组系数<strong>矩阵</strong>，<span class="math inline">\(beq\)</span>为等式组系数<strong>向量</strong></li><li><span class="math inline">\(lb,ub\)</span>为下界和上界<strong>向量</strong></li></ul><pre class="language-matlab" data-language="matlab"><code class="language-matlab"><span class="token punctuation">[</span>x<span class="token punctuation">,</span>fval<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">linprog</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> A<span class="token punctuation">,</span> b<span class="token punctuation">,</span> Aeq<span class="token punctuation">,</span> beq<span class="token punctuation">,</span> lb<span class="token punctuation">,</span> ub<span class="token punctuation">,</span> X0<span class="token punctuation">)</span></code></pre><ul><li><p>标准形式为求解最小值，如果求解最大值等价于求<span class="math inline">\(-\min \mathrm{c}^{T} x\)</span>的最小值，最后结果再给个相反数即可</p></li><li><p>标准形式的不等式为<strong>小等于</strong></p></li><li><p><code>x</code> 为最小值的系数<strong>向量</strong>，<code>fval</code>为最小值</p></li><li><p><code>X0</code>为迭代初值，可省略</p></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> scipy <span class="token keyword">import</span> optimize<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">LinearProgram</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> A<span class="token punctuation">,</span> b<span class="token punctuation">,</span> Aeq<span class="token punctuation">,</span> beq<span class="token punctuation">,</span> bounds<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 求解函数</span>  res <span class="token operator">=</span> optimize<span class="token punctuation">.</span>linprog<span class="token punctuation">(</span>c<span class="token punctuation">,</span> A<span class="token punctuation">,</span> b<span class="token punctuation">,</span> Aeq<span class="token punctuation">,</span> beq<span class="token punctuation">,</span> bounds<span class="token punctuation">)</span>  <span class="token comment"># 目标函数最小值</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token comment"># 最优解</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>x<span class="token punctuation">)</span></code></pre><ul><li>标准形式为求解最小值，如果求解最大值等价于求<span class="math inline">\(-\min \mathrm{c}^{T} x\)</span>的最小值，最后结果再给个相反数即可</li><li>标准形式的不等式为<strong>小等于</strong></li><li>无上下界约束为默认值</li><li><code>bounds</code>为二元组列表，每个二元组对应一个<span class="math inline">\(x\)</span>的下界和上界，无限制则为<code>None</code></li></ul><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220421172003.png" alt="线性规划例子" / loading="lazy"><figcaption aria-hidden="true">线性规划例子</figcaption></figure><h2 id="整数规划">整数规划</h2><h3 id="线性整数规划">线性整数规划</h3><p><strong>钢管切割问题</strong></p><p>在线性规划的基础上，加入决策变量为整数的条件</p><p>整数规划求解的基本框架是<strong>分支定界法</strong>（Branch and bound，BnB）</p><p>首先去除整数约束得到“<strong>松弛模型</strong>”，使用线性规划的方法求解。若有某个变量不是整数，在松弛模型上分别添加约束</p><p>但是<code>python</code>实现分支定界较为繁琐，所以选择使用<code>Plup</code>这个专门用来解线性规划问题的库</p><pre class="language-matlab" data-language="matlab"><code class="language-matlab"><span class="token punctuation">[</span>x<span class="token punctuation">,</span>fval<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">intlinprog</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> intcon<span class="token punctuation">,</span> A<span class="token punctuation">,</span> b<span class="token punctuation">,</span> Aeq<span class="token punctuation">,</span> beq<span class="token punctuation">,</span> lb<span class="token punctuation">,</span> ub<span class="token punctuation">)</span></code></pre><ul><li><code>intcon</code>为一个<strong>向量</strong>，指定那些决策变量是整数</li></ul><h3 id="规划">0-1规划</h3><p><strong>背包问题，指派问题</strong></p><p>特殊的线性整数规划，即决策变量只取0或者1</p><p>显然，只需要对线性整数规划的上下界进行约束即可</p><h3 id="plup">Plup</h3><blockquote><p>真好用啊，符合人类直觉的限制方式</p><p>Pulp本质上是求解器的接口，具体的求解是依赖优化器实现的</p></blockquote><ol type="1"><li>定义一个规划问题类<code>LpProblem</code></li></ol><pre class="language-python" data-language="python"><code class="language-python">myProb <span class="token operator">=</span> pulp<span class="token punctuation">.</span>LpProblem<span class="token punctuation">(</span><span class="token string">"ProblemName"</span><span class="token punctuation">,</span> sense<span class="token operator">=</span>pulp<span class="token punctuation">.</span>LpMaximize<span class="token punctuation">)</span></code></pre><ul><li><code>sense</code>可为：<code>LpMinimize</code> <code>LpMaximize</code>对最小值问题和最大值问题</li></ul><ol start="2" type="1"><li>定义决策变量<code>LpVariable</code></li></ol><pre class="language-python" data-language="python"><code class="language-python">x1 <span class="token operator">=</span> pulp<span class="token punctuation">.</span>LpVariable<span class="token punctuation">(</span><span class="token string">'x1'</span><span class="token punctuation">,</span> lowBound<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> upBound<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">,</span> cat<span class="token operator">=</span>pulp<span class="token punctuation">.</span>LpConstraint<span class="token punctuation">)</span> x2 <span class="token operator">=</span> pulp<span class="token punctuation">.</span>LpVariable<span class="token punctuation">(</span><span class="token string">'x2'</span><span class="token punctuation">,</span> lowBound<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> cat<span class="token operator">=</span>pulp<span class="token punctuation">.</span>LpInteger<span class="token punctuation">)</span>x3 <span class="token operator">=</span> pulp<span class="token punctuation">.</span>LpVariable<span class="token punctuation">(</span><span class="token string">'x3'</span><span class="token punctuation">,</span> cat<span class="token operator">=</span>pulp<span class="token punctuation">.</span>LpBinary<span class="token punctuation">)</span> </code></pre><ul><li>上下界缺省为无穷</li><li><code>cat</code>设定变量类型，用于解决小数、整数以及0-1规划</li></ul><ol start="3" type="1"><li>添加目标函数</li></ol><pre class="language-python" data-language="python"><code class="language-python">myProb <span class="token operator">+=</span> <span class="token number">2</span><span class="token operator">*</span>x1 <span class="token operator">+</span> <span class="token number">3</span><span class="token operator">*</span>x2 <span class="token operator">-</span> <span class="token number">5</span><span class="token operator">*</span>x3<span class="token comment"># 设置目标函数</span></code></pre><ul><li>添加目标函数使用 “之前定义的规划问题类 += 目标函数式” 格式。</li></ul><ol start="4" type="1"><li>添加约束条件</li></ol><pre class="language-python" data-language="python"><code class="language-python">myProb <span class="token operator">+=</span> <span class="token number">2</span><span class="token operator">*</span>x1 <span class="token operator">-</span> <span class="token number">5</span><span class="token operator">*</span>x2 <span class="token operator">+</span> x3 <span class="token operator">>=</span> <span class="token number">10</span>  <span class="token comment"># 不等式约束</span>myProb <span class="token operator">+=</span> x1 <span class="token operator">+</span> <span class="token number">3</span><span class="token operator">*</span>x2 <span class="token operator">+</span> x3 <span class="token operator">&lt;=</span> <span class="token number">12</span>  <span class="token comment"># 不等式约束</span>myProb <span class="token operator">+=</span> x1 <span class="token operator">+</span> x2 <span class="token operator">+</span> x3 <span class="token operator">==</span> <span class="token number">7</span>  <span class="token comment"># 等式约束</span></code></pre><ul><li>约束式只能为<code>==</code> <code>&gt;=</code> <code>&lt;=</code></li></ul><ol start="5" type="1"><li>求解</li></ol><pre class="language-python" data-language="python"><code class="language-python">myProb<span class="token punctuation">.</span>solve<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># myProb.solve(pulp.GUROBI_CMD())</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"求解状态:"</span><span class="token punctuation">,</span> pulp<span class="token punctuation">.</span>LpStatus<span class="token punctuation">[</span>myProb<span class="token punctuation">.</span>status<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span> v <span class="token keyword">in</span> myProb<span class="token punctuation">.</span>variables<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"="</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>varValue<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"目标值="</span><span class="token punctuation">,</span> pulp<span class="token punctuation">.</span>value<span class="token punctuation">(</span>myProb<span class="token punctuation">.</span>objective<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ul><li>PuLP默认采用 CBC 求解器来求解优化问题</li><li>可以调用其它的优化器来求解，如：GLPK，COIN CLP/CBC，CPLEX，和GUROBI，但需要另外安装。</li></ul><h3 id="cvxpy">CvxPY</h3><blockquote><p>支持较多变量需要用到矩阵乘法的规划问题</p></blockquote><ol type="1"><li>定义系数矩阵</li></ol><pre class="language-python" data-language="python"><code class="language-python">C <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>A <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>B <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><ol start="2" type="1"><li>声明决策变量</li></ol><pre class="language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> cp<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span>n<span class="token punctuation">,</span>integer <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span></code></pre><ul><li><span class="math inline">\(n\)</span>为变量长度</li><li>可以声明决策变量类型<ul><li><code>neg pos nonneg nonpos</code>：负数 正数 非负数 非正数</li><li><code>boolean</code>：布尔变量</li></ul></li></ul><ol start="3" type="1"><li>声明问题</li></ol><pre class="language-python" data-language="python"><code class="language-python">objective <span class="token operator">=</span> cp<span class="token punctuation">.</span>Minimize<span class="token punctuation">(</span>cp<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>C<span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ul><li><code>Minimize</code>和<code>Maximize</code></li></ul><ol start="4" type="1"><li>定义约束</li></ol><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 开始拼接约束方程</span><span class="token comment"># B是右边的常数项</span>B <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>B1<span class="token punctuation">,</span> B2<span class="token punctuation">,</span> B3<span class="token punctuation">,</span> B4<span class="token punctuation">,</span> B5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># print(B)</span><span class="token comment"># A是左边的约束项</span>A <span class="token operator">=</span> np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">[</span>A1<span class="token punctuation">,</span> A2<span class="token punctuation">,</span> A3<span class="token punctuation">,</span> A4<span class="token punctuation">,</span> A5<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># print(A)</span><span class="token comment"># Be是右边的等式约束项</span>Be <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>Be1<span class="token punctuation">,</span> Be2<span class="token punctuation">,</span>Be3<span class="token punctuation">,</span>Be4<span class="token punctuation">,</span>Be5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># print(Be)</span><span class="token comment"># Ae是左边的等式约束项</span>Ae <span class="token operator">=</span> np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">[</span>Ae1<span class="token punctuation">,</span> Ae2<span class="token punctuation">,</span>Ae3<span class="token punctuation">,</span>Ae4<span class="token punctuation">,</span>Ae5<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><ol start="5" type="1"><li>定义求解器</li></ol><pre class="language-python" data-language="python"><code class="language-python">constraints <span class="token operator">=</span> <span class="token punctuation">[</span>Ae @ x <span class="token operator">==</span> Be<span class="token punctuation">,</span> A @ x <span class="token operator">>=</span> B<span class="token punctuation">]</span>prob <span class="token operator">=</span> cp<span class="token punctuation">.</span>Problem<span class="token punctuation">(</span>objects<span class="token punctuation">,</span> constraints<span class="token punctuation">)</span>prob<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>solver<span class="token operator">=</span>cp<span class="token punctuation">.</span>GUROBI<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Status:"</span><span class="token punctuation">,</span> prob<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Optimal value"</span><span class="token punctuation">,</span> prob<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Optimal var\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span>value<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="非线性规划">非线性规划</h2><p>如果目标函数或者约束条件存在非线性函数，即为非线性规划情况 <span class="math display">\[\min \mathrm{c}^{T} x \\\begin{equation}\text { s.t. }\left\{\begin{array}{c}A x \leq b \\A e q * x=b e q \\C(x) \leq 0 \\Ceq(x) =0 \\l b \leq x \leq u b\end{array}\right.\end{equation}\]</span></p><p>不难发现，比起线性规划的标准形式，非线性规划多了<strong>非线性不等式约束</strong><span class="math inline">\(C(x) \leq 0\)</span>以及<strong>非线性等式约束</strong><span class="math inline">\(Ceq(x)=0\)</span></p><ul><li><p><span class="math inline">\(c^T\)</span>为目标函数系数<strong>向量</strong></p></li><li><p><span class="math inline">\(C(x)\)</span>为非线性函数<strong>向量</strong></p></li><li><p><span class="math inline">\(Ceq\)</span>为非线性函数向量</p></li></ul><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220422103411.png" alt="非线性规划例子" / loading="lazy"><figcaption aria-hidden="true">非线性规划例子</figcaption></figure><pre class="language-matlab" data-language="matlab"><code class="language-matlab"><span class="token punctuation">[</span>x<span class="token punctuation">,</span> fval<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fmincon</span><span class="token punctuation">(</span><span class="token operator">@</span>fun<span class="token punctuation">,</span> X0<span class="token punctuation">,</span> A<span class="token punctuation">,</span> b<span class="token punctuation">,</span> Aeq<span class="token punctuation">,</span> beq<span class="token punctuation">,</span> lb<span class="token punctuation">,</span> ub<span class="token punctuation">,</span> <span class="token operator">@</span>nonlfun<span class="token punctuation">,</span> OPTION<span class="token punctuation">)</span></code></pre><ul><li>算法本身求取的是局部最优，所以预期的初始值<code>X0</code>非常重要</li><li>如果要求全局最优：<ul><li>给定不同的初始值，得到“全局最优解”</li><li>先用蒙特卡罗模拟，将该解作为初始值来求取最优解（推荐）</li></ul></li><li><code>OPTION</code>可以指定使用的求解算法，<strong>通过改变算法，可以体现你的模型稳定性</strong></li><li><code>@fun</code>和<code>@nonlfun</code>需要用额外的<code>.m</code>文件定义</li></ul><p>非线性规划可以依据目标函数类型简单分为两种，凸函数和非凸函数</p><ul><li>凸函数可以使用<code>cvxpy</code>库</li><li>非凸函数没有特定的算法可以尝试寻找极值：<ul><li>纯数学</li><li>神经网络，深度学习</li><li><code>scipy.optimize.minimize</code></li><li><code>gekko</code></li></ul></li></ul><h3 id="scipy-optimize">SciPy optimize</h3><blockquote><p>与matlab一样，需要定义目标函数以及约束条件</p></blockquote><p>目标函数</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">objective</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">'''  args 为决策变量的系数向量  '''</span>  a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d <span class="token operator">=</span> args  <span class="token keyword">def</span> <span class="token function">v</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> a<span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> d<span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>a<span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> c<span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>  <span class="token keyword">return</span> v</code></pre><p>约束条件</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">constraints</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">'''  args 为约束条件的常数向量  '''</span>  eq1<span class="token punctuation">,</span> ineq1 <span class="token operator">=</span> args  cons <span class="token operator">=</span> <span class="token punctuation">(</span>      <span class="token punctuation">&#123;</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'ineq'</span><span class="token punctuation">,</span> <span class="token string">'fun'</span><span class="token punctuation">:</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span> ineq1<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'eq'</span><span class="token punctuation">,</span> <span class="token string">'fun'</span><span class="token punctuation">:</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span>       x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">-</span> eq1<span class="token punctuation">&#125;</span>  <span class="token punctuation">)</span>  <span class="token keyword">return</span> cons</code></pre><ul><li><code>type</code>有<code>ineq, eq</code>分别表示不等式约束和等式约束类型</li><li>最后记得减去常数以保证形式都为0</li><li>注意：在<code>optimize.minimize</code>中的<strong>不等式约束标准形式为大等于</strong>，与<code>optimize.linprog</code>相反</li></ul><p>求解</p><pre class="language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">res &#x3D; minimize(objective(objargs), X0, method&#x3D;&#39;SLSQP&#39;,bounds&#x3D;bounds, constraints&#x3D;constraints(conargs))</code></pre><ul><li>算法本身求取的是局部最优，所以预期的初始值<code>X0</code>非常重要</li><li><code>method</code>可选多种算法</li></ul><h3 id="gekko">Gekko</h3><blockquote><p>与Pulp语法比较接近，属于人类直觉型库</p></blockquote><ol type="1"><li>初始化</li></ol><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> gekko <span class="token keyword">import</span> GEKKOm <span class="token operator">=</span> GEKKO<span class="token punctuation">(</span>remote<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment"># 指定求解器</span>m<span class="token punctuation">.</span>options<span class="token punctuation">.</span>SOLVER <span class="token operator">=</span> <span class="token number">3</span></code></pre><ol start="2" type="1"><li>定义决策变量</li></ol><pre class="language-python" data-language="python"><code class="language-python">x1 <span class="token operator">=</span> m<span class="token punctuation">.</span>Var<span class="token punctuation">(</span>lb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> ub<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>x2 <span class="token operator">=</span> m<span class="token punctuation">.</span>Var<span class="token punctuation">(</span>lb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> ub<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>x3 <span class="token operator">=</span> m<span class="token punctuation">.</span>Var<span class="token punctuation">(</span>lb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> ub<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>x4 <span class="token operator">=</span> m<span class="token punctuation">.</span>Var<span class="token punctuation">(</span>lb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> ub<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span></code></pre><ol start="3" type="1"><li>定义约束条件</li></ol><pre class="language-python" data-language="python"><code class="language-python">m<span class="token punctuation">.</span>Equation<span class="token punctuation">(</span>x1 <span class="token operator">*</span> x2 <span class="token operator">*</span> x3 <span class="token operator">*</span> x4 <span class="token operator">>=</span> <span class="token number">25</span><span class="token punctuation">)</span>m<span class="token punctuation">.</span>Equation<span class="token punctuation">(</span>x1<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x2<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x3<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x4<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">40</span><span class="token punctuation">)</span></code></pre><ol start="4" type="1"><li>定义目标函数</li></ol><pre class="language-python" data-language="python"><code class="language-python">m<span class="token punctuation">.</span>Obj<span class="token punctuation">(</span>x1 <span class="token operator">*</span> x4 <span class="token operator">*</span> <span class="token punctuation">(</span>x1 <span class="token operator">+</span> x2 <span class="token operator">+</span> x3<span class="token punctuation">)</span> <span class="token operator">+</span> x3<span class="token punctuation">)</span></code></pre><ol start="5" type="1"><li>求解</li></ol><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 指定优化器</span>m<span class="token punctuation">.</span>options<span class="token punctuation">.</span>IMODE <span class="token operator">=</span> <span class="token number">3</span><span class="token comment"># 求解</span>m<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>disp<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment"># Solve</span><span class="token comment"># 输出结果</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'x1 = '</span><span class="token punctuation">,</span> x1<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'x2 = '</span><span class="token punctuation">,</span> x2<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'x3 = '</span><span class="token punctuation">,</span> x3<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'x4 = '</span><span class="token punctuation">,</span> x4<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Objective: '</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>options<span class="token punctuation">.</span>objfcnval<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;摸鱼，等崛起的神威太刀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B3%A1%E5%A3%B6%E9%BE%99%E5%A4%AA%E5%88%80.jpg&quot; alt=&quot;89249011_p1_master1200&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学建模" scheme="http://lapras.xyz/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="数学" scheme="http://lapras.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python" scheme="http://lapras.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（二）</title>
    <link href="http://lapras.xyz/2022/06/25/6ba75aa8.html"/>
    <id>http://lapras.xyz/2022/06/25/6ba75aa8.html</id>
    <published>2022-06-25T14:01:07.000Z</published>
    <updated>2022-06-28T14:32:04.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>今日KEEP<del>KFC</del></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%B1%B3%E5%B1%B1%E8%88%9E-eva.jpeg" alt="米山舞 eva" style="zoom:80%;" / loading="lazy"></p><span id="more"></span><h2 id="总线的基本概念">总线的基本概念</h2><blockquote><p><strong>总线</strong>（Bus）是指计算机组件间规范化的交换数据的方式，即以一种通用的方式为各组件提供数据传送和控制逻辑。从另一个角度来看，如果说<a href="https://zh.wikipedia.org/wiki/主機板">主板</a>（Mother Board）是一座城市，那么总线就像是城市里的公共汽车（bus），能按照固定行车路线，传输来回不停运作的<a href="https://zh.wikipedia.org/wiki/位元">比特</a>（bit）。这些线路在同一时间内都仅能负责传输一个比特。因此，必须同时采用多条线路才能发送更多资料，而总线可同时传输的资料数就称为宽度（width），以比特为单位，总线宽度愈大，传输性能就愈佳。总线的<a href="https://zh.wikipedia.org/wiki/頻寬">带宽</a>（即单位时间内可以传输的总资料数）为：总线带宽 = 频率×宽度（Bytes/sec）</p></blockquote><h3 id="为什么使用总线">为什么使用总线</h3><table><thead><tr class="header"><th>连接方式</th><th>硬件资源</th><th>可扩展性</th></tr></thead><tbody><tr class="odd"><td>两两单独连接</td><td>占用引脚多，连线复杂</td><td>需要现有设备提供与新设备之间的接口，扩展起来麻烦</td></tr><tr class="even"><td>总线式连接</td><td>占用引脚少，连线简单</td><td>只需将新设备挂到总线，扩展方便</td></tr></tbody></table><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BA%BF.png" alt="为什么要使用总线" / loading="lazy"><figcaption aria-hidden="true">为什么要使用总线</figcaption></figure><h3 id="总线上信息的传输">总线上信息的传输</h3><p>首先，<strong>在任意时刻一条总线只能有一对部件进行信息传输</strong></p><p>总线信息传输方式可以分为<strong>串行传输</strong>和<strong>并行传输</strong>，字面意思来看，串行就是数据是一位一位的发送<strong>，</strong>并行就是数据一组一组的发送。以直觉来看，并行应该是比串行传输速率高的，但事实上现在大部分的芯片都选择串行传输</p><blockquote><p><strong>并行总线由于是多个数据同时传输，需要考虑数据的协同性，这就导致了并行传输的频率不能做的很高</strong>。相对的，串行总线只有一条链路，就可以把频率做的很高，提高传输速度，速度提高了就能够弥补一次只能传输一个数据的缺陷。</p><p>此外，<strong>并行总线两根相邻的链路其数据是同时传输的</strong>，这就会导致它们彼此之间会产生<strong>严重干扰</strong>，并行的链路越多，干扰越强。因此并行总线需要加强抗干扰的能力，否则传输过程中数据就可能被损坏。如果传输过程中数据故障了，就需要重新对齐数据再传输。而串行总线如果一个数据出错了，只需要重新传输一次就好了，由于串行总线频率高，很快就可以把错误数据重新传输过去。</p><p>再次，由于<strong>并行总线是多链路一块传输数据</strong>，就需要很多线，接口需要很多针脚，老式计算机里的并行接口做得很大，接线比较宽，针脚非常多。这样一来装机也很麻烦，因为走线不方便、接口体积很大。</p></blockquote><h2 id="总线的分类">总线的分类</h2><h3 id="根据总线位置进行分类">根据总线位置进行分类</h3><ol type="1"><li>片内总线：芯片内部的总线</li><li>系统总线：计算机各部件的信息传输<ol type="1"><li>数据总线：双向，与机器字长、存储字长相关</li><li>地址总线：单向，与存储地址、I/O地址相关</li><li>控制总线：<ul><li>有出：中断请求、总线请求</li><li>存储器读、存储器写、总线使用权许可、中断确认</li></ul></li></ol></li><li>通信总线：用于 计算机系统之间 或 计算机系统 与 其他系统。<ol type="1"><li>串行传输</li><li>并行传输</li></ol></li></ol><h2 id="总线特性及性能指标">总线特性及性能指标</h2><h3 id="总线特性">总线特性</h3><table><thead><tr class="header"><th>特性分类</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>机械特性</td><td>尺寸、形状、引脚数、引脚的排列顺序等</td></tr><tr class="even"><td>电气特性</td><td>传输方向、有效电平范围等</td></tr><tr class="odd"><td>功能特性</td><td>每根线的功能，如地址、数据、控制等</td></tr><tr class="even"><td>时间特性</td><td>时钟频率、信号的时序关系等</td></tr></tbody></table><h3 id="性能指标">性能指标</h3><ol type="1"><li>总线宽度：数据线的根数，根数越多，同时传输的位数就越多</li><li>标准传输率：每秒传输的最大字节数（MBps）</li><li>时钟类型：同步、不同步</li><li>总线复用：地址线和数据线<strong>复用</strong>，以减少芯片的管脚数</li><li>信号线数：地址线、数据线和控制线的总和</li><li>总线控制方式：突发、自动、仲裁、逻辑、计数</li><li>其他指标：负载能力</li></ol><h3 id="总线标准">总线标准</h3><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86.png" alt="image-20220627192109975" / loading="lazy"><figcaption aria-hidden="true">image-20220627192109975</figcaption></figure><p>顺便一提，现代总线比如雷电4标准已经到 40 Gbps，所以总线标准也是计算机的性能瓶颈之一。</p><h2 id="总线结构">总线结构</h2><h3 id="单总线结构">单总线结构</h3><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="单总线结构" / loading="lazy"><figcaption aria-hidden="true">单总线结构</figcaption></figure><ul><li>存在主线争用问题</li><li>时间延迟高</li></ul><h3 id="多总线结构">多总线结构</h3><ol type="1"><li><p>面向CPU的双总线结构</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%9D%A2%E5%90%91CPU%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="面向CPU的双总线结构" / loading="lazy"><figcaption aria-hidden="true">面向CPU的双总线结构</figcaption></figure><ul><li>考虑到<strong>指令</strong>和<strong>数据</strong>都来自主存，所以用单独的M总线保证其交换速度</li><li>假设主存要与I/O设备信息传输，就不得不经过CPU，会打乱CPU的信息交换任务</li></ul></li><li><p>面向存储器的双总线结构</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%9D%A2%E5%90%91%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="面向存储器的双总线结构" / loading="lazy"><figcaption aria-hidden="true">面向存储器的双总线结构</figcaption></figure><ul><li>从主存发出两条总线：存储总线和系统总线</li><li>CPU和主存也保留了专用总线</li><li>CPU也可以直接与I/O设备交互</li><li>目前还不能做到主存同时使用两根总线</li></ul></li><li><p>使用通道</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%80%9A%E9%81%93%E5%8F%8C%E4%B8%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="通道双主线" / loading="lazy"><figcaption aria-hidden="true">通道双主线</figcaption></figure><ul><li>一般来说通道有自己的控制器，指令等</li></ul></li><li><p>三总线结构</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="三总线结构" / loading="lazy"><figcaption aria-hidden="true">三总线结构</figcaption></figure><ul><li>在面向CPU的双总线结构上，将I/O设备分为高速和低速</li><li>将高速设备通过新的DMA总线与内存进行直接地信息交换</li></ul></li><li><p>三总线结构-2</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%842" alt="三总线结构2" / loading="lazy"><figcaption aria-hidden="true">三总线结构2</figcaption></figure><ul><li>由于内存的进步较于CPU缓慢，容易成为计算机的瓶颈点。所以使用Cache对内存中常用的指令预先读取，然后单独与CPU连接一条局部总线</li><li>系统总线通过一个扩展总线接口连接扩展总线，但这样会影响外部设备的传输速率</li></ul></li><li><p>四总线结构</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9B%9B%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="四总线结构" / loading="lazy"><figcaption aria-hidden="true">四总线结构</figcaption></figure><ul><li>在三总线-2的基础上将外设分为高速和低速</li></ul></li></ol><h2 id="总线控制">总线控制</h2><p>总线控制主要解决两个问题：多设备同时申请使用总线的判定（总线判优控制/仲裁）和设备占用总线中保证通讯的正确性（总线通信控制）</p><h3 id="总线判优控制">总线判优控制</h3><p>根据组件在总线中的功能可以分为总设备（模块）和从设备（模块）</p><p>主设备：对总线有控制权，可以发出占用总线的申请</p><p>从设备：没有控制权，只能响应主设备发出的申请</p><p>集中式仲裁：把总线的判优逻辑放在一个部件中，根据查询方式不同，又可以分为：<strong>链式查询、计数器定时查询和独立请求方式</strong></p><p>分布式仲裁：总线的仲裁逻辑分散在与总线连接的各主设备上。典型的例子有<strong>以太网</strong>，以太网上接入的各台计算机都可以发起通信，为避免无序竞争，它们都需要遵循以太网的仲裁逻辑，即<strong>载波侦听/冲突检测</strong>。</p><h4 id="链式查询">链式查询</h4><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2.png" alt="链式查询" / loading="lazy"><figcaption aria-hidden="true">链式查询</figcaption></figure><ul><li><p>地址线：从设备查找</p></li><li><p>数据线：数据传输</p></li><li><p>BR 总线：各接口向总线控制部件提出占用请求</p></li><li><p>BG 总线：总线控制部件<strong>链式地</strong>查询哪个I/O接口提出了占用请求（碰到就停止查询）</p></li><li><p>BS 总线：获得总线使用权的接口利用 BR 总线向总线控制部件，发送一个总线忙碌状态以应答</p></li><li><p>链式查询的顺序就是设备的优先级顺序</p></li><li><p>优点：结构简单，算法简单，增删设备容易</p></li><li><p>缺点：BG 对电路故障特别敏感，速度较慢</p></li></ul><h4 id="计数器定时查询">计数器定时查询</h4><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2.png" alt="计时器定时查询" / loading="lazy"><figcaption aria-hidden="true">计时器定时查询</figcaption></figure><ul><li>设备地址线：由总线控制部件的<strong>计数器</strong>发出信号，通过这个地址来查找某个设备是否发出总线请求</li><li>计数器：各接口向总线控制部件通过 BR 提出占用请求。控制器接受到请求并成功通过后就会启动计数器（初值为0或者某个地址），计数器的值通过设备地址线向外输出，查询接口为初值的I/O接口。如果没有提出，则计数器++后重复查询，直到找到提出的I/O接口，并用 BR 进行应答。</li><li>优点：优先级是优先级较为灵活，比如通过软件的方式设定初值，那么优先级也就随之改变了</li></ul><h4 id="独立请求方式">独立请求方式</h4><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png" alt="独立请求方式" / loading="lazy"><figcaption aria-hidden="true">独立请求方式</figcaption></figure><ul><li>任何一个I/O接口都增加了两条线 BR BG</li><li>排队器：通过软件的方式在总线控制部件中动态地调整优先级</li><li>缺点：连接复杂</li></ul><h3 id="总线通信控制">总线通信控制</h3><p>总线传输周期：完成一次传输需要的时间</p><ul><li>申请分配：判优问题</li><li>寻址阶段：主设备向从设备给出地址和命令</li><li>传输阶段：主设备和从设备交换数据</li><li>结束阶段：主设备撤销相关信息</li></ul><p>方式：</p><table><thead><tr class="header"><th>通信方式</th><th>特点</th></tr></thead><tbody><tr class="odd"><td>同步通信</td><td>统一定宽定距的时标控制数据传输</td></tr><tr class="even"><td>异步通信</td><td>无统一时标，采用应答方式。主设备发出请求（命令），从设备应答，进而完成数据交换</td></tr><tr class="odd"><td>半同步通信</td><td>引入等待信号，解决不同速度的两个设备之间的通讯，同步异步结合</td></tr><tr class="even"><td>分离式通信</td><td>不在等待时占据总线，提高总线通信的效率</td></tr></tbody></table><h4 id="同步通信">同步通信</h4><ol type="1"><li>同步通信输入</li></ol><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1.png" alt="同步通信" / loading="lazy"><figcaption aria-hidden="true">同步通信</figcaption></figure><ul><li>假设一次数据传输使用了四个时钟周期</li><li><span class="math inline">\(T_1\)</span>的上升沿之前：主设备发出地址信号并持续</li><li><span class="math inline">\(T_2\)</span>的上升沿之前：给出读命令</li><li><span class="math inline">\(T_3\)</span>的上升沿之前：从设备需要将需要数据发送到数据线上</li><li><span class="math inline">\(T_4\)</span>的上升沿之前：撤销数据、撤销读命令</li><li><span class="math inline">\(T_4\)</span>结束之前：撤销地址</li></ul><ol start="2" type="1"><li><p>同步通信输出</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E8%BE%93%E5%87%BA.png" alt="image-20220627210825638" / loading="lazy"><figcaption aria-hidden="true">image-20220627210825638</figcaption></figure><ul><li>假设一次数据传输使用了四个时钟周期</li><li><span class="math inline">\(T_1\)</span>的上升沿之前：主设备发出地址信号并持续</li><li><span class="math inline">\(T_1\)</span>的下降沿之前：给出数据到数据线上</li><li><span class="math inline">\(T_2\)</span>的上升沿之前：给出写命令</li><li><span class="math inline">\(T_4\)</span>的上升沿之前：撤销数据、撤销写命令</li><li><span class="math inline">\(T_4\)</span>结束之前：撤销地址</li></ul></li></ol><p>同步通讯特点：需要选择最慢的设备（模块）作为统一通讯的时标，所以通常应用于总线长度短（长度越长频率越低）且各个模块存取时间较为一致。</p><h4 id="异步通讯">异步通讯</h4><p>异步通讯中根据应答信号是否互锁，即请求和回答信号的建立和撤消是否互相依赖，异步通讯可分为三种类型：非<strong>互锁通讯、半互锁通讯和全互锁通讯</strong>。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF.png" alt="异步通讯" / loading="lazy"><figcaption aria-hidden="true">异步通讯</figcaption></figure><ul><li>锁：可以简单理解为状态锁，即保持发送请求这个状态。</li><li>不互锁：主设备发出请求信号，经过一段时间（主设备觉得从设备差不多收到）后，就撤销请求信号。从设备同理，接收到请求信号后，经过一段时间，撤销响应信号。<strong>即主设备主观、从设备主观</strong></li><li>半互锁：主设备发出请求信号，直到从设备发出应答信号后才能撤销。而从设备无需等待主设备发出撤销信号，经过一段时间后，撤销响应信号。<strong>即主设备客观、从设备主观</strong></li><li>全互锁：主设备发出请求信号，直到从设备发出应答信号后才能撤销。从设备发出响应信号，知道主设备发出撤销信号后才能撤销响应信号。<strong>即主设备客观、从设备客观</strong></li><li>显然互锁方式不同，传输的速率和可靠程度亦不同</li></ul><h4 id="半同步通信">半同步通信</h4><p>同步特点：发送方用系统时钟前沿<strong>发信号</strong>，接收方用系统时钟后沿<strong>判断、识别</strong></p><p>异步特点：允许不同速度的模块一同工作，增加了一条“等待”响应信号<span class="math inline">\(\overline {WAIT}\)</span></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png" alt="半同步通信读取" / loading="lazy"><figcaption aria-hidden="true">半同步通信读取</figcaption></figure><ul><li><span class="math inline">\(T_1\)</span>的上升沿之前：主设备发出地址信号并持续</li><li><span class="math inline">\(T_2\)</span>的上升沿之前：给出读命令</li><li><span class="math inline">\(T_3\)</span>的上升沿之前：如果从设备无法准备好数据，则给出<span class="math inline">\(\overline {WAIT}\)</span>告知 CPU 进行等待，CPU会插入<span class="math inline">\(T_w\)</span>时钟周期。直到某次检测<span class="math inline">\(WAIT\)</span>信号为1，则进入<span class="math inline">\(T_3\)</span></li><li><span class="math inline">\(T_4\)</span>的上升沿之前：撤销读命令、撤销数据</li><li><span class="math inline">\(T_4\)</span>的上升沿之前：撤销地址</li></ul><h4 id="分离式通信">分离式通信</h4><p>上述三种通信控制方式，准备数据的时候总线都没有被占用，这就造成了浪费。于是乎，我们将一个完整的总线传输周期分为两个小周期，<strong>放弃等待数据这段时间的总线占用</strong>。那么这么判断何时从设备准备好数据了呢？所以在分离式通信中，<strong>每个设备都能作为主设备发出请求信号</strong>，这样从设备就能正常地提供数据以继续流程。</p><ol type="1"><li><p>主设备 发出地址和命令占用总线，使用完后主设备放弃总线，从设备进行准备。</p></li><li><p>如果 从设备 准备好数据，<strong>从设备会化身为主设备</strong>向总线发出请求</p></li></ol><p>特点：</p><ol type="1"><li>各模块均有权有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li><strong>准备数据时不占用总线</strong></li><li>总线被占用时，无空闲</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;今日KEEP&lt;del&gt;KFC&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%B1%B3%E5%B1%B1%E8%88%9E-eva.jpeg&quot; alt=&quot;米山舞 eva&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（一）</title>
    <link href="http://lapras.xyz/2022/06/25/5bb1b670.html"/>
    <id>http://lapras.xyz/2022/06/25/5bb1b670.html</id>
    <published>2022-06-25T09:36:13.000Z</published>
    <updated>2022-06-26T13:47:09.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>暑假正式开始，开（huan）坑（zhai）计组。笔记会同步更新于<a href="https://github.com/Anduin9527/CS-Professional-Notes-of-NJUPT">我的Github笔记仓库</a></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625173242.webp" alt="img" style="zoom:67%;" / loading="lazy"></p><span id="more"></span><h2 id="计算机系统简介">计算机系统简介</h2><h3 id="计算机软硬件概念">计算机软硬件概念</h3><p>计算机系统</p><ol type="1"><li>硬件：计算机的实体：如主机、外设</li><li>软件：具有各类特殊功能的信息（程序）组成<ol type="1"><li>系统软件：用来管理整个计算机系统<ol type="1"><li>语言处理程序（编译、链接）</li><li>操作系统</li><li>服务性程序</li><li>数据库管理系统</li><li>网络软件</li></ol></li><li>应用软件：按任务需要编写的程序</li></ol></li></ol><h3 id="计算机系统的层次结构">计算机系统的层次结构</h3><ol type="1"><li><p>物理结构抽象</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625092903.png" alt="image-20220625092855877" / loading="lazy"><figcaption aria-hidden="true">image-20220625092855877</figcaption></figure><p>自底向上地来看：</p><ol type="1"><li>Physics 物理抽象，电子设备依靠电子的移动进行工作。可以使用 量子 机制，和麦克斯韦方程进行描述。</li><li>Devices 电子元件，利用电子在不同物质中的移动特征来构建不同的电子元件，其具有不同的电压电流特征用以描述。</li><li>Analog Circuits 模拟电路，利用基本的电子元件构建放大器，滤波器等部件。</li><li>Digital Circuits 数字电路，利用模拟电路层进一步构建与非门等。</li><li>Logic 逻辑层，利用数字电路进行加法器和存储器的实现。</li><li>Microarchitecture 微体系(架构)结构层，具有执行单元和控制单元</li></ol></li><li><p>程序员角度</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625094958.png" alt="image-20220625094958199" / loading="lazy"><figcaption aria-hidden="true">image-20220625094958199</figcaption></figure></li></ol><h2 id="计算机的基本组成">计算机的基本组成</h2><h3 id="冯诺依曼计算机的特点">冯·诺依曼计算机的特点</h3><ol type="1"><li>计算机由五大部件（运算器、控制器、存储器、输入设备和输出设备）组成</li><li>指令和数据以同等地位<strong>存于存储器</strong>，可按地址寻访</li><li>指令和数据用二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序（核心特征）</li><li>以运算器为中心</li></ol><h3 id="冯诺依曼计算机的硬件图">冯·诺依曼计算机的硬件图</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625101051.png" alt="image-20220625101051177" style="zoom:80%;" / loading="lazy"></p><ul><li>实线表示数据通路</li><li>虚线表示控制和状态反馈</li><li>运算器：核心，算术运算与逻辑运算</li><li>存储器：存放数据和程序</li><li>控制器：指挥控制程序的运行</li><li>输入设备：将信息转化为机器能识别的形式</li><li>输出设备：将结果转化为人能识别的形式</li></ul><h3 id="冯诺依曼计算机的结构改进">冯·诺依曼计算机的结构改进</h3><p>以存储器为中心的计算机硬件框图</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625101628.png" alt="image-20220625101628906" / loading="lazy"><figcaption aria-hidden="true">image-20220625101628906</figcaption></figure><p>其中，运算器（ALU）和控制器（CU）可以组成 CPU 。存储器可以进一步分为主存和辅存。主存和CPU可以进一步构成主机。输入设备和输出设备统称为I/O设备，主机和I/O设备统称为硬件。则给出</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625103446.png" alt="image-20220625103446906" style="zoom:80%;" / loading="lazy"></p><h3 id="系统复杂性管理的方法">系统复杂性管理的方法</h3><ol type="1"><li>层次化（Hierachy）：将被设计的系统划分为多个模块或子模块</li><li>模块化（Modularity）：有明确定义（well-defined）的功能和接口</li><li>规则性（regularity）：模块符合某些通用标准，使其更容易被重用</li></ol><h3 id="计算机的工作步骤">计算机的工作步骤</h3><ol type="1"><li>建立数学模型</li><li>确定计算方法</li><li>编写解题程序</li></ol><p>给例子：计算<span class="math inline">\(a x^{2}+b x+c=(a x+b) x+c\)</span></p><ol type="1"><li><p>从问题来看需要<strong>加法指令</strong>和<strong>乘法指令</strong></p></li><li><p>还需要取出数字并放置到累加器中的<strong>取数指令</strong>，和读取结果并放置到存储器中的<strong>读取指令</strong></p></li><li><p>最后是显示或者打印的<strong>打印指令</strong>，以及停机指令</p></li><li><p>计算</p><p>取 x 至运算器中 乘以 a 在运算器中 加 b 在运算器中 乘以 x 在运算器中 加 c 在运算器中</p></li></ol><h3 id="指令格式">指令格式</h3><p>都使用16位长度的指令由6位操作码和8位地址码构成，[] 表示在寄存器中保存的内容</p><ol type="1"><li><p>取数指令</p><p>取数 a，[a] –&gt; ACC</p><p>000001 0000001000，前六位表示取数指令，后十位表示地址8</p></li><li><p>存数指令</p><p>存数 b，[ACC] –&gt; b</p></li><li><p>加法指令</p><p>加数 c，[ACC] + [c] –&gt; [ACC]</p></li><li><p>乘法指令</p><p>乘数 d，[ACC] * [d] –&gt; [ACC]</p></li><li><p>打印指令</p><p><span class="math inline">\(\sigma\)</span> ，[<span class="math inline">\(\sigma\)</span>] –&gt; 打印机</p></li><li><p>停机指令</p></li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625110202.png" alt="image-20220625110202631" style="zoom:67%;" / loading="lazy"></p><h3 id="存储器的基本组成">存储器的基本组成</h3><p>上面我们知道，<strong>指令</strong>和<strong>数据</strong>都保存在存储器当中。<strong>存储器</strong>的主要部分是<strong>存储体，MAR，MDR</strong></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625161002.png" alt="image-20220625161002215" style="zoom:67%;" / loading="lazy"></p><ul><li><p><strong>存储体</strong>又有若干<strong>存储单元</strong>构成，<strong>存储单元</strong>又由若干<strong>存储元件</strong>（0/1）构成。</p></li><li><p>存储单元：存放一串二进制代码，即<strong>存储字</strong></p></li><li><p>存储字长：存储字的长度（位数）</p></li><li><p>存储单元<strong>按照地址寻址</strong></p></li><li><p>MAR：存储器<strong>地址寄存器</strong>，<strong>保存了存储单元的地址</strong>，MAR的位数反映了存储单元的个数。<strong>即存储单元个数是<span class="math inline">\(2^{n_{MAR}}\)</span></strong>。</p></li><li><p>MDR：存储器<strong>数据寄存器</strong>，MDR的位数表示该存储器的<strong>存储字长</strong>，即<strong>存储字长是</strong><span class="math inline">\(n_{MDR}\)</span></p></li><li><p>MAR 就像存储器的入口，其接受某个地址作为寻找请求。存储器找到后将其地址中的<strong>内容</strong>交给存储器出口MDR</p></li></ul><h3 id="运算器的基本组成">运算器的基本组成</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625162012.png" alt="image-20220625162012087" style="zoom:80%;" / loading="lazy"></p><p>ALU：Arithmetic Logic Unit，<strong>算术逻辑运算单元</strong>，运算器中完成算术逻辑运算的逻辑部件</p><p>ACC：Accumulator，<strong>累加器</strong>，运算器中运算前存放操作数、运算后存放运算结果的寄存器</p><p>MQ：Multiplier-Quotient Register，<strong>乘商寄存器</strong>，乘法运算时存放乘数、除法时存放商的寄存器</p><p>X：此字母没有专指的缩写含义，可以用作任一部件名，在此表示操作数寄存器，即运算器中工作寄存器之一，用来<strong>存放操作数</strong></p><p>例：加法操作过程，设加法指令操作码为000001，加数的地址为M</p><ol type="1"><li>初态：ACC中已经存放好了被加数</li><li>[M] –&gt; X</li><li>[ACC] + [X] –&gt; ACC</li></ol><p>例2：减法操作过程，设减法指令操作码为000010，减数的地址为M</p><ol type="1"><li>初态：ACC中已经存放好了被减数</li><li>[M] –&gt; X</li><li>[ACC] - [X] –&gt; ACC</li></ol><p>例3：乘法操作过程，设乘法指令操作码为000011，乘数的地址为M</p><ol type="1"><li>初态：ACC中已经存放好了被乘数</li><li>[M] –&gt; MQ</li><li>[ACC] –&gt; X</li><li>0 –&gt; ACC</li><li>[ACC] * [X] –&gt; ACC//MQ</li></ol><p>例4：除法操作过程，设触发指令操作码为000111，除数的地址为M</p><ol type="1"><li>初态：ACC中已经存放好了被除数</li><li>[M] –&gt; X</li><li>[ACC] / [X] –&gt; MQ，余数在ACC中</li></ol><h3 id="控制器的基本组成">控制器的基本组成</h3><p>控制器由PC、IR与CU组成</p><p>控制器用以解释指令并保证指令按照正确的次序执行，下面来看完成一条指令需要三个大步骤：</p><ol type="1"><li>取指令，<strong>PC（程序计数器）</strong>存放当前欲执行指令的地址， 具有计数功能：（PC）+ 1 –&gt; PC</li><li>分析指令，<strong>IR（指令寄存器）</strong>存放当前欲执行的指令</li><li>执行指令，<strong>CU</strong></li></ol><p>例：完成一条<strong>取数指令</strong>的过程</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625165601.png" alt="image-20220625165601107" style="zoom:80%;" / loading="lazy"></p><ol type="1"><li>取指令<ol type="1"><li>PC 把指令的地址给MAR</li><li>MAR 在控制器的控制之下，根据地址寻找指定的存储单元</li><li>存储体把指定的存储单元中的指令取出送入 MDR</li><li>MDR 取出的指令送入 IR</li></ol></li><li>分析指令<ol type="1"><li>IR 中的操作码部分送给 CU，由 CU 根据指令开始执行操作</li></ol></li><li>执行指令<ol type="1"><li>IR 中的地址码部分送给 MAR</li><li>MAR 在控制器的控制之下，根据地址寻找指定的存储单元</li><li>存储体把指定的存储单元中的数据取出送入 MDR</li><li>MDR 取出的数据送入ACC，取数完毕</li></ol></li></ol><h3 id="总结">总结</h3><ol type="1"><li>将程序通过输入设备送至计算机</li><li>程序首地址 –&gt; PC</li><li>启动程序运行</li><li>取指令PC→MAR→M→MDR→IR，(PC)+1→PC</li><li>分析指令OP(IR)→CU</li><li>执行指令AD(IR)→MAR→M→MDR→ACC</li><li>……</li><li>打印结果</li><li>停机</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;暑假正式开始，开（huan）坑（zhai）计组。笔记会同步更新于&lt;a href=&quot;https://github.com/Anduin9527/CS-Professional-Notes-of-NJUPT&quot;&gt;我的Github笔记仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625173242.webp&quot; alt=&quot;img&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://lapras.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="http://lapras.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>SPSS基础应用与聚类分析</title>
    <link href="http://lapras.xyz/2022/06/23/aef9302d.html"/>
    <id>http://lapras.xyz/2022/06/23/aef9302d.html</id>
    <published>2022-06-22T16:49:42.000Z</published>
    <updated>2022-06-22T17:06:42.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>6月23日、『Honkai Impact 3』の新メインライン発売まで10時間、『Rise of SunBreak』の発売まで7日です。 もう我慢できない！ テレビゲームがしたい！</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220623010515.png" alt="image-20220623010515152" / loading="lazy"><figcaption aria-hidden="true">image-20220623010515152</figcaption></figure><span id="more"></span><h2 id="标准化数据">标准化数据</h2><blockquote><p>​ 大型数据分析项目中，数据来源不同，量纲及量纲单位不同，为了让它们具备可比性，需要采用标准化方法消除由此带来的偏差。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。这就是数据标准化。</p><p><strong>基本原理</strong>：z-score标准化。数值减去平均值，再除以其标准差，得到<strong>均值为0，标准差为1</strong>的服从<strong>标准正态分布</strong>的数据。</p></blockquote><ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>描述</li><li>将标准化值另存为变量（Z）</li></ol><h2 id="归一化数据">归一化数据</h2><blockquote><p>主要是为了数据处理方便提出来的，把数据映射到0～1范围之内处理，把有量纲表达式变为无量纲表达式。</p></blockquote><ol type="1"><li><p>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>描述</p></li><li><p>选项<span class="math inline">\(\rightarrow\)</span>最小值、最大值</p></li><li><p>转换<span class="math inline">\(\rightarrow\)</span>计算变量 <span class="math display">\[x^* = \frac{x-min}{max-min}\]</span></p></li></ol><h2 id="聚类分析">聚类分析</h2><blockquote><p>聚类分析是一种探索性分析方法，与判别分析不同，<strong>聚类分析事先并不知道分类的标准，甚至不知道应该分成几类，</strong>而是会根据样本数据的特征，自动进行分类。严格说来聚类分析并不是纯粹的统计技术，它不像其它多元分析法那样，需要从样本去推断总体。一般都涉及不到有关统计量的分布，也不需要进行显著性检验。假定研究对象均用所谓的“点”来表示。 在聚类分析中，一般的规则是将“距离”较 小的点归为同一类，将“距离”较大的点归为不同的类。 常见的是对个案分类，也可以对变量分类， 但对于变量分类此时一般使用相似系数作为 “距离”测量指标。</p><p>目的：使属于同一类别的数据间的 相似性尽可能大，不同类别中的数据间的相似性尽可能小</p><p><strong>注意：</strong>聚类分析更像是一种建立假设的方法，而对于相关假设的检验还需要借助其他统计的方法，比如判别分析、T-检验、方差分析等，看聚类出来的几个类别是否存在差异</p></blockquote><ul><li><p>从统计学的观点看，聚类分析是通过数据建模简化数据的一种方法。</p></li><li><p>从机器学习的角度看，簇相当于隐藏模式。聚类是搜索簇的无监督学习过程。</p></li><li><p>从实际应用的角度看，聚类分析是数据预处理（降维）和信息挖掘的主要任务之一。</p></li></ul><p>常规步骤：</p><ol type="1"><li>选择聚类指标（经验、主成分分析、因子分析）</li><li>数据标准化处理（K-means需要预处理，其余SPSS集成）</li><li>选择聚类方法：样本容量，变量类型</li><li>确定分类个数</li><li>进行结果解读</li></ol><h2 id="k均值聚类k-means-cluster">K均值聚类（K-means Cluster）</h2><ul><li><p>聚类对象：个案（Q型聚类分析）</p></li><li><p>变量类型：连续变量</p></li><li><p>分类数：固定</p></li><li><p>样本容量：大样本</p></li></ul><h3 id="流程">流程</h3><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TB选择若干聚类中心 <span class="token arrow operator">----></span> 依据与聚类中心的距离划分出初始分类依据与聚类中心的距离划分出初始分类 <span class="token arrow operator">----></span> 计算出各个分类的中心位置计算出各个分类的中心位置 <span class="token arrow operator">----></span> A<span class="token text string">&#123;用计算出的中心位置重新进行聚类&#125;</span>A <span class="token arrow operator">----></span> 计算出各个分类的中心位置A <span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">聚类中心收敛</span><span class="token arrow operator">--></span></span> END</code></pre><p>整个K-means是一个自平衡的过程，其不断划分类别，然后用某些规则（比如重心）计算聚类中心，再重新根据聚类中心划分类别，如此不断迭代，直到某次循环结果与上次一致或者达到迭代上限。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622224606.gif" alt="img" / loading="lazy"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="优缺点">优缺点</h3><p>优点：</p><ol type="1"><li>原理比较简单，实现也很容易，<strong>收敛速度快</strong>。</li><li>在对大规模数据集进行聚类分析时，算法聚类较高效且聚类效果较好。</li><li>簇与簇之间区别明显时，它的聚类效果很好。</li></ol><p>缺点：</p><ol type="1"><li>分类数从<strong>初始分类开始就确定不变</strong>了，所以要求事先要对样本有足够的了解。</li><li>仅限于<strong>个案间的聚类</strong>（Q型聚类）,不能对变量进行聚类。</li><li>个案间的距离的测量方法使用的是<strong>欧式距离的平方</strong>，因此只能对连续变量进行聚类。</li></ol><h3 id="spss过程">SPSS过程</h3><ol type="1"><li>对变量进行标准化处理</li><li>分析<span class="math inline">\(\rightarrow\)</span>分类<span class="math inline">\(\rightarrow\)</span>k均值聚类</li><li>选择个案变量（比如ID），其余变量放置于变量，设置聚类数。</li><li>迭代<span class="math inline">\(\rightarrow\)</span>默认迭代十次</li><li>保存<span class="math inline">\(\rightarrow\)</span>聚类成员</li><li>统计<span class="math inline">\(\rightarrow\)</span>初始聚类中心，ANOVA，每个个案的聚类信息</li><li>结果分析<ol type="1"><li>初始聚类中心、最终聚类中心和迭代历史记录（若不收敛调整迭代次数）</li><li>ANOVA：<strong>聚类均方</strong>对应组间均方差，<strong>误差均方</strong>对应组内均方差，显著性p&lt;0.05且<strong>组间均方差大于组内均方差</strong>时说明此变量组别之间差异明显，分类可信度较高。</li><li>聚类成员明细</li></ol></li><li>由于可能经过标准化处理，最后的结果是标准化的数值。如果要查看聚类中心原本的数值<ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>比较均值<span class="math inline">\(\rightarrow\)</span>均值</li><li>选择标准化前的变量作为因变量，案例的类别号作为自变量</li><li>选项<span class="math inline">\(\rightarrow\)</span>单元格统计量只要均值</li></ol></li></ol><h2 id="系统聚类分层聚类">系统聚类（分层聚类）</h2><ul><li><p>聚类对象：个案或变量</p></li><li><p>变量类型：连续变量或分类变量</p></li><li><p>分类数：固定或指定范围</p></li><li><p>样本容量：中小样本</p></li></ul><h3 id="流程-1">流程</h3><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622233231.png" alt="image-20220622233231246" style="zoom:67%;" / loading="lazy"></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622233846.gif" alt="6-what-is-clustering" / loading="lazy"><figcaption aria-hidden="true">6-what-is-clustering</figcaption></figure><h3 id="优缺点-1">优缺点</h3><p>优点：</p><ol type="1"><li>距离和规则的相似度容易定义，限制少。</li><li>既可对分类变量聚类，也可对连续变量聚类。</li><li>事先不需要确定要分多少类，系统会自动确定最佳分类数。</li></ol><p>缺点：</p><ol type="1"><li>运行较慢，适合样本容量较少</li><li>系统聚类分析时，每个个案一旦归为某一类就不允许再改变，但最初的分类可能不是最优的选择。</li></ol><h3 id="spss过程-1">SPSS过程</h3><ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>分类<span class="math inline">\(\rightarrow\)</span>系统聚类</li><li>聚类可以选择个案（标注个案变量）或者变量</li><li>统计<span class="math inline">\(\rightarrow\)</span>集中计划，近似值矩阵</li><li>图<span class="math inline">\(\rightarrow\)</span>谱系图，取消冰柱图</li><li>方法<span class="math inline">\(\rightarrow\)</span>标准化：Z得分（按变量）；聚类方法：一般而言组间联接是最好的，ward法聚类出来会比较平均；度量标准：个案一般用平方欧式距离，变量一般用皮尔逊相关系数</li><li>结果分析</li></ol><h2 id="二阶聚类twostep-cluster">二阶聚类（TwoStep Cluster）</h2><ul><li><p>聚类对象：个案或变量</p></li><li><p>变量类型：连续变量和分类变量</p></li><li><p>分类数：自动确定</p></li><li><p>样本容量：大样本</p></li></ul><h3 id="优缺点-2">优缺点</h3><p>优点：</p><ol type="1"><li>能够<strong>同时处理分类变量和连续变量</strong></li><li>可自动选择最优的分类个数</li><li>适用于大样本数据</li></ol><p>缺点：</p><ol type="1"><li>聚类结果主要受所选择的变量影响。如果去掉一些变量，或者增加一些变量，结果会很不同</li><li>分类变量应服从<strong>多项分布</strong>，连续变量应服从<strong>正态分布</strong>（但其实会自动剔除异常值）</li></ol><h3 id="spss过程-2">SPSS过程</h3><ol type="1"><li><p>检验正态分布（分类变量多项分布一般都是满足的）</p></li><li><p>检验共线性，去除无关变量</p></li><li><p>分析<span class="math inline">\(\rightarrow\)</span>分类<span class="math inline">\(\rightarrow\)</span>两步聚类</p></li><li><p>按照变量类型分开为分类变量和连续变量，剩余一个为个案变量</p></li><li><p>选项<span class="math inline">\(\rightarrow\)</span>连续变量标准化</p></li><li><p>输出<span class="math inline">\(\rightarrow\)</span>选择透视表；将个案变量作为判断字段；创建聚类成员变量</p></li><li><p>结果分析：</p><ol type="1"><li><p>自动聚类表：</p><blockquote><p>根据施瓦茨贝叶斯准则（BIC)帮助<strong>判断最佳分类数量</strong>，从统计上分析，该数值越小聚类效果越好。但是实际中还要考虑BIC变化量、BIC变化比率和距离测试比率，可以通过他们进一步确定最佳分类数。 判断标准：</p><ol type="1"><li>BIC准则数值越小，聚类效果越好；</li><li>BIC变化量数值越小，聚类效果越好；</li><li>距离测量比率数值越大，聚类效果越好。</li></ol></blockquote></li><li><p>聚类分布，质心：不同类的总体情况</p></li><li><p>模型概要：聚类质量图反映聚类效果的好坏，双击可进入详细模式，然后左下角查看<span class="math inline">\(\rightarrow\)</span>聚类，接着可以点击某些属性来<strong>查看变量重要性</strong>，或者多选某些属性来查看<strong>各类别对比</strong>。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220623003719.png" alt="image-20220623003719854" style="zoom: 80%;" / loading="lazy"></p></li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;6月23日、『Honkai Impact 3』の新メインライン発売まで10時間、『Rise of SunBreak』の発売まで7日です。 もう我慢できない！ テレビゲームがしたい！&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220623010515.png&quot; alt=&quot;image-20220623010515152&quot; /&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20220623010515152&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    <category term="数学建模" scheme="http://lapras.xyz/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="数学" scheme="http://lapras.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="聚类分析" scheme="http://lapras.xyz/tags/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
    
    <category term="统计" scheme="http://lapras.xyz/tags/%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>SPSS基础应用与回归分析</title>
    <link href="http://lapras.xyz/2022/06/22/56984c70.html"/>
    <id>http://lapras.xyz/2022/06/22/56984c70.html</id>
    <published>2022-06-22T06:41:26.000Z</published>
    <updated>2022-06-26T13:27:08.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>福州好热，暑假又要开模了呜呜呜我的CS呜呜呜。趁着训练前终于把打了一年的MHW煌黑龙和黑龙通了，芜湖~~</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622143315.png" alt="image-20220622143314890" / loading="lazy"><figcaption aria-hidden="true">image-20220622143314890</figcaption></figure><span id="more"></span><h2 id="描述性分析">描述性分析</h2><blockquote><p>描述性分析主要是对所收集的数据进行分析，得出反映客观现象和数量特征的一种分析方法，它主要包括数据的集中趋势分析、数据离散程度分析、数据的频数分布分析等，描述性分析是对数据进一步分析的基础。</p><ul><li>分类变量：说明事物的类别，其数据是不连续（指数值上）、互不相容的（指不会同时满足复数个类别）。比如：性别</li><li>连续变量：其数据是连续的。比如：年龄</li></ul></blockquote><h3 id="对分类变量进行频率分析">对分类变量进行频率分析</h3><blockquote><h1 id="注意spss中不支持中文数据所以使用数值型添加标签值的方式">注意SPSS中不支持中文数据，所以使用数值型+添加标签值的方式</h1></blockquote><ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>频率</li><li>选择对应的分类变量</li><li>图表<span class="math inline">\(\rightarrow\)</span>条形图生成</li></ol><h3 id="对连续变量进行频率分析">对连续变量进行频率分析</h3><ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>频率</li><li>选择对应的连续变量</li><li>统计<span class="math inline">\(\rightarrow\)</span>选择一些条目<ul><li>四分位数：输出这组数据的四等分点</li><li>分割点：输出这组数据的n等分点</li><li>百分位数：输出这组数据的指定百分比点</li><li>中位数、平均值、标准差、最小值、最大值</li></ul></li><li>图表<span class="math inline">\(\rightarrow\)</span>直方图<span class="math inline">\(\rightarrow\)</span>显示正态曲线</li></ol><h3 id="交叉表分析统计频率">交叉表分析统计频率</h3><blockquote><p>交叉表分析是用于分析两个或两个以上变量之间的关联关系，以交叉表格的形式进行分组变量间关系的对比分析。</p></blockquote><ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>频率</li><li>选择行（自变量）列数据（因变量）</li><li>格式<span class="math inline">\(\rightarrow\)</span>百分比选择列</li><li>可以选择簇状条形图</li></ol><h2 id="数据异常值检验">数据异常值检验</h2><ol type="1"><li>图形<span class="math inline">\(\rightarrow\)</span>箱图<span class="math inline">\(\rightarrow\)</span>简单，单独变量的摘要</li><li>箱表示：移入需要检测的变量</li><li>观察箱线图，除去异常值或将其设置为均值</li></ol><h2 id="数据正态分布检验">数据正态分布检验</h2><ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>探索</li><li>全部选入因变量列表，图<span class="math inline">\(\rightarrow\)</span>因子级别并置，茎叶图，含检验的正态图</li><li>观察变量的显著性p值</li></ol><h2 id="相关分析和独立性检验">相关分析和独立性检验</h2><blockquote><p>相关关系是指现象之间存在着非严格的、不确定的依存关系。这种依存关长系的特点是：某一现象在数量上发生变化会影响另一现象数量上的变化，而且这种变化在数量上具有一定的随机性。即当给定某一现象一数值时，另一现象会有若干个数值与之对应，并且总是遵循一定的规律， 围绕这些数值的平均数上下波动，其原因是影响现象发生变化的因素不止一个。</p><p>相关关系可分为线性相关和非线性相关，线性相关也称为直线相关，线性相关是最常用的一种，即当一 个连续变量发生变动时，另一个连续变量相应地呈线性 关系变动，用<strong>皮尔逊（Pearson)相关系数</strong>上来度量。</p><p><strong>皮尔逊相关系数</strong>就是反映连续变量之间线性相关强度的一个度量指标，它的取值范围限于[-1, 1]。 r的正、负号可以反映相关的方向，当 r &gt; 0 时表示表示 线性正相关，当 r &lt; 0 时，线性负相关。 r的大小可以反映相关的程度，r = 0 表示两个变量之间不存在线性关系。一般认为0.3~0.8为中度相关。</p><p>非线性相关某种意义来讲也就是曲线相关，一般不用相关系数度量其相关性。</p></blockquote><h3 id="相关分析">相关分析</h3><p>前提：两变量为<strong>连续变量</strong>，两变量之间为<strong>线性相关</strong>。数据服从正态分布且无异常值。</p><ol type="1"><li><p>绘制散点图大致判断是否为线性关系（图形<span class="math inline">\(\rightarrow\)</span>简单散点图）</p></li><li><p>计算相关系数（分析<span class="math inline">\(\rightarrow\)</span>相关<span class="math inline">\(\rightarrow\)</span>双变量）</p></li><li><p>显著性检验，即上一步中得到的<span class="math inline">\(Sig.\)</span>也就是所谓的P值</p><blockquote><p>P值小于一般显著性水平（<strong>一般为0.05</strong>）则认为变量间存在显著性相关关系，小于0.01则具有极其显著的相关关系。P值大于一般显著性水平（一般为0.05）则认为变量间不存在显著性相关关系。</p></blockquote></li></ol><h3 id="卡方独立性检验">卡方独立性检验</h3><p>前提：</p><ol type="1"><li><p>观测变量（因变量）是二分类变量（布尔变量）。</p></li><li><p>分组变量（自变量）的类别大等于2。</p></li><li><p>抽样是独立的。</p></li><li><p>样本量足够大，最小的样本量要求分析中的任一单元<strong>格期望频数大于5</strong></p></li></ol><p>步骤：</p><ol type="1"><li>判断期望频数<ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>频率<span class="math inline">\(\rightarrow\)</span>交叉表</li><li>分组变量（自变量）放入行，观测变量（因变量）放入列</li><li>单元格<span class="math inline">\(\rightarrow\)</span>取消实测<span class="math inline">\(\rightarrow\)</span>选中期望</li><li>统计<span class="math inline">\(\rightarrow\)</span>选中卡方</li><li>观察输出的交叉表，发现每个单元格的数值都大于5即可、</li></ol></li><li>计算卡方值<ol type="1"><li>重复第1部分</li><li>单元格<span class="math inline">\(\rightarrow\)</span>取消期望<span class="math inline">\(\rightarrow\)</span>选中实测<span class="math inline">\(\rightarrow\)</span>列</li><li>组间比较（当分组变量类别大于2时可选）：单元格<span class="math inline">\(\rightarrow\)</span>z检验<span class="math inline">\(\rightarrow\)</span>调整p值</li><li>观察输出的卡方检验表，其中渐进显著性为p值</li><li>组间比较：观察输入的交叉表，其中计数会出现字母，字母不同表示该类别的差异具有统计学意义，反之则无。</li></ol></li></ol><h2 id="回归分析">回归分析</h2><div><p>graph LR 回归分析----&gt;线性回归 线性回归----&gt;一元线性回归 线性回归----&gt;多元线性回归 回归分析----&gt;非线性回归</p></div><p>联系：两者均为研究及测度两个或两个以上变量之间关系的方法。在实际工作中，一般先进行相关分析，计算相关系数，然后建立回归模型，最后用回归模型进行推算或预测。</p><p>区别：相关分析研究的都是随机变量，并且不分自变量与因变量，回归分析研究的变量要定义出自变量与因变量，并且自变量是确定的普通变量，因变量是随机变量。相关分析主要是描述两个变量之间相关关系的密切程度；回归分析不仅可以揭示变量x对变量y的影响程度，还可以根据回归模型进行预测。</p><h3 id="一元线性回归">一元线性回归</h3><blockquote><p>一元线性回归，就是回归模型中只含一个自变量，它主要用来处理一个自变量与一个因变量之间的线性关系。简单线性回归模型为：<span class="math inline">\(Y=a+bX+\varepsilon\)</span>，使用的时<strong>最小二乘法</strong> 式中： Y--因变量； X--自变量； a--常数项，是回归直线在纵坐标轴上的截距； b--回归系数，是回归直线的斜率； <span class="math inline">\(\varepsilon\)</span>--随机误差，即随机因素对因变量所产生的影响。</p></blockquote><p>前提：两变量为<strong>连续变量</strong>，两变量之间存在线性关系</p><ol type="1"><li><p>根据预测目标确定因变量</p></li><li><p>绘制散点图确定回归模型</p></li><li><p>估计模型参数，建立线性回归模型</p><ol type="1"><li>回归<span class="math inline">\(\rightarrow\)</span>线性<span class="math inline">\(\rightarrow\)</span>选择变量</li><li>图<span class="math inline">\(\rightarrow\)</span>Y：DEP，X：ZRE（标准化残差）<span class="math inline">\(\rightarrow\)</span>直方图，正态概率图</li><li>保存<span class="math inline">\(\rightarrow\)</span>预测值：未标准化，残差：标准化，距离：库克，杠杆（显示异常点），预测区间：平均值，单值</li><li>选项：使用F的概率默认，在方程中包含常量</li></ol></li><li><p>对模型进行检验</p><ol type="1"><li><p>除去变量表（除去没有相关性的变量）</p></li><li><p>线性回归模型汇总表：观察调整后R方</p><blockquote><p>R方：判定系数。 值为0~1之间，越接近1,预测值与观测值越接近。一般认为，<strong>R方大于0.75, 表示拟合程度很好</strong>，小于0.5,表示拟合有问题，不适合回归分析，R方介两者之间说明拟合程度一般。</p></blockquote></li><li><p>方差分析表ANOVA：观察显著性p值（通过F检验算出）</p></li><li><p>回归系数表：得到回归模型系数和常量，以及显著性p值（通过t检验算出）</p></li><li><p>观察残差直方图：因变量的残差值基本符合正态分布为好</p></li><li><p>观察残差正态p-p图：如果样本数据来自正态分布的话， 所有散点都应分布在对角线附近。说明样本数据比较正确。</p></li></ol></li></ol><h3 id="多元线性回归">多元线性回归</h3><p>前提：</p><ol type="1"><li>需要至少2个自变量，且自变量之间互相独立</li><li>因变量为为连续变量</li><li>数据具有<strong>方差齐性、无异常值和正态分布</strong>的特点</li><li>自变量间不存在多重共线性</li></ol><p>步骤：</p><ol type="1"><li><p>检验并去除异常值</p></li><li><p>检验是否为正态分布</p></li><li><p>检验方差齐性（莱文或者ANOVA）</p><ol type="1"><li><p>分析<span class="math inline">\(\rightarrow\)</span>描述统计<span class="math inline">\(\rightarrow\)</span>探索</p></li><li><p>设置因变量为预测变量，因子列表为自变量</p></li><li><p>图<span class="math inline">\(\rightarrow\)</span>因子级别并置，茎叶图，莱文未转换</p></li><li><p>观察莱文方差齐性检验的显著性p值是否大于0.05</p><blockquote><p>莱文检验原假设<span class="math inline">\(H_0\)</span>：各组方差相等，符合方差齐性</p></blockquote></li><li><p>分析<span class="math inline">\(\rightarrow\)</span>比较均值<span class="math inline">\(\rightarrow\)</span>单因素ANOVA检验</p></li><li><p>将预测变量设置为因变量，但需要注意的是，ANOVA检验无法将名义变量设为因子</p></li><li><p>选项<span class="math inline">\(\rightarrow\)</span>方差齐性检验</p></li><li><p>观察方差齐性检验的显著性p值是否大于0.05</p><blockquote><p>检验原假设<span class="math inline">\(H_0\)</span>：各组方差相等，符合方差齐性</p></blockquote></li></ol></li><li><p>检验多重共线性</p><ol type="1"><li><p>分析<span class="math inline">\(\rightarrow\)</span>回归<span class="math inline">\(\rightarrow\)</span>线性</p></li><li><p>输入自变量和因变量</p></li><li><p>统计<span class="math inline">\(\rightarrow\)</span>共线性诊断</p></li><li><p>关注系数表，当<span class="math inline">\(VIF\)</span>值大于等于10时，我们认为变量间存在严重的共线性。</p><p>当<span class="math inline">\(VIF\)</span>值小于10时，我们认为数据基本符合多元线性分析的假设，即不存在多重共线性问题。</p></li></ol></li><li><p>分析<span class="math inline">\(\rightarrow\)</span>回归<span class="math inline">\(\rightarrow\)</span>线性</p></li><li><p>填入自变量和因变量</p></li><li><p>统计</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622140830.jpeg" alt="img" / loading="lazy"><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>保存<span class="math inline">\(\rightarrow\)</span>预测值：未标准化，残差：学生化，学生化后删除，距离：库克，杠杆（显示异常点），包含协方差矩阵</p></li><li><p>对模型进行检验</p><ol type="1"><li>除去变量表（除去没有相关性的变量）</li><li>线性回归模型汇总表：观察调整后R方</li><li>方差分析表ANOVA：观察显著性p值（通过F检验算出）</li><li>回归系数表：得到回归模型系数和常量，以及显著性p值（通过t检验算出），以及VIF</li></ol></li><li><p>结果表述</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622143012.png" alt="image-20220622143012110" / loading="lazy"><figcaption aria-hidden="true">image-20220622143012110</figcaption></figure></li></ol><h3 id="多元线性逐步回归">多元线性逐步回归</h3><blockquote><p>逐步法结合向前法和向后法的优点，在向前引入每一个新自变量之后都要重新对已代入的自变量进行计算，以检验其有无继续保留在方程中的价值，并以此为依据进行自变量的引入和剔除交替进行，直到没有新的变量可以引入或剔除为止，此法较为准确。</p></blockquote><p>前提：同多元线性回归</p><ol type="1"><li><p>检验并去除异常值</p></li><li><p>检验是否为正态分布</p></li><li><p>检验方差齐性（莱文或者ANOVA）</p></li><li><p>检验多重共线性</p></li><li><p>分析<span class="math inline">\(\rightarrow\)</span>回归<span class="math inline">\(\rightarrow\)</span>线性</p></li><li><p>填入自变量和因变量，方法选择步进</p></li><li><p>统计：估算值，模型拟合，共线性诊断，德斌沃森残差分析</p></li><li><p>保存：学生化，杠杆值，协方差矩阵</p></li><li><p>对模型进行检验</p><ol type="1"><li>残差统计表：在满足假设后，我们还需要依据残差统计表中的库克距离（cook值）来判断数据有无强影响点，若库克距离的最大值大于1，则应检查数据是否存在的异常值；若库克距离的最大值小于1，则数据中不存在强影响点，可以进行下一步的分析。</li><li>模型纳入变量表：去除不重要的变量</li><li>模型摘要表：表下的注释可以看出逐步回归分析中每一步引入回归方程的自变量。观测调整后R方</li><li>ANOVA表：此检验的零假设是多重相关系数R=0。如果P&lt;0.05，就说明多重线性回归模型中至少有一个自变量的系数不为零。同时，回归模型有统计学意义也说明相较于空模型，纳入自变量有助于预测因变量；或说明该模型优于空模型。</li><li>回归模型系数表：显著性检验结果，当P&gt;0.05时，该自变量在本模型中没有统计学意义，应当在回归模型中删除相应变量；反之保留。</li></ol></li><li><p>表述</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622142941.png" alt="image-20220622142941884" / loading="lazy"><figcaption aria-hidden="true">image-20220622142941884</figcaption></figure></li></ol><h3 id="非线性回归">非线性回归</h3><ol type="1"><li>绘制散点图，大致确定关系</li><li>曲线估算<ol type="1"><li>分析<span class="math inline">\(\rightarrow\)</span>回归<span class="math inline">\(\rightarrow\)</span>曲线估算</li><li>填入因变量和独立（自变量）</li><li>选择可能的模型</li><li>观察模型和参数估计表，有R方和显著性p值，选择R方优越的模型</li><li>根据参数估计值得到曲线表达式</li></ol></li></ol><h2 id="参考">参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNzAxMDY5NQ==&amp;mid=2247483917&amp;idx=1&amp;sn=8c2358dbf63fa5785bc7a0d0e8937932&amp;chksm=f99fe665cee86f73a702f1552a3589d6934e5263031624964b640521c8de71bae94838eff632&amp;scene=178&amp;cur_album_id=1354525438097539072#rd">SPSS多元线性回归分析</a></p><p><a href="https://www.bilibili.com/video/BV133411K7yd">2022校赛赛前培训SPSS基础</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;福州好热，暑假又要开模了呜呜呜我的CS呜呜呜。趁着训练前终于把打了一年的MHW煌黑龙和黑龙通了，芜湖~~&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220622143315.png&quot; alt=&quot;image-20220622143314890&quot; /&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20220622143314890&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    <category term="数学建模" scheme="http://lapras.xyz/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="数学" scheme="http://lapras.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="回归" scheme="http://lapras.xyz/tags/%E5%9B%9E%E5%BD%92/"/>
    
    <category term="SPSS" scheme="http://lapras.xyz/tags/SPSS/"/>
    
  </entry>
  
  <entry>
    <title>SSH的二三事</title>
    <link href="http://lapras.xyz/2022/03/20/844ad6f8.html"/>
    <id>http://lapras.xyz/2022/03/20/844ad6f8.html</id>
    <published>2022-03-19T16:18:05.000Z</published>
    <updated>2022-03-21T04:56:29.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>来学校上了两周网课，两周线下，现在又要上网课了G！上网课就算了，我还要给学弟上网课哈哈。整一波虚拟教师V出道</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220320002327.jpg" alt="63476067_p0_master1200" style="zoom: 67%;" / loading="lazy"></p><span id="more"></span><h2 id="什么是ssh">什么是SSH</h2><blockquote><p>SSH（Secure Shell 的缩写）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。</p><p>实际使用中，它主要用于保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。</p></blockquote><p>比如我们都知道的 Github 下载源代码有两种方式，HTTPS 和 一种形如<code>git@github.com:username/repositoryname.git</code>的连接，这其实就是一种 SSH 协议。</p><p>再比如我们要操作机房里的服务器，不可能给每一台服务器都配上键盘鼠标显示器，一般都是通过网络的方式远程访问一台服务器。就类似于 TeamViewer 的远程桌面。</p><h3 id="安装ssh服务">安装SSH服务</h3><p>现在几乎所有的 Linux 发行版、Windows 以及 MacOS 基本都自带了<code>ssh</code>服务，其中绝大部分都是 OpenSSH ，这是一个关于实现 SSH-2 协议的开源项目，其中还包含了一些常用的辅助工具比如：<code>ssh-keygen</code>、<code>ssh-agent</code>、<code>scp</code>以及<code>sftp</code>。</p><p>所以绝大部分的电脑都是有<code>ssh</code>的，可以用<code>ssh -V</code>简单地查看一下。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#安装</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openssh-client<span class="token function">sudo</span> dnf <span class="token function">install</span> openssh-clients</code></pre><p>然后你就可以用<code>service</code>或者<code>systemctl</code>之类的开启<code>sshd</code>服务。</p><h2 id="ssh基础用法">SSH基础用法</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span> -p <span class="token punctuation">&#123;</span><span class="token number">22</span><span class="token punctuation">&#125;</span> <span class="token builtin class-name">command</span></code></pre><ul><li><code>remote_host</code>可以是一个 IP 地址，也可以是一个可被 DNS 解析的域名（Domain）。</li><li><code>ssh</code>除了可以登录之外，还可以在后面直接添加一条命令<code>command</code>，会返回命令的<code>STDOUT</code>。利用这个可以写一些脚本儿。</li><li><code>-p</code>制定了<code>ssh</code>服务的端口，默认都是22。</li><li>看看<code>config</code>以及<code>known_hosts</code></li></ul><h3 id="常用配置文件">常用配置文件</h3><p>SSH 客户端的全局配置文件是<code>/etc/ssh/ssh_config</code>，用户配置文件在<code>~/.ssh/config</code>，用户配置文件优先级更高</p><p>SSH 服务端的配置文件是<code>/etc/ssh/sshd_config</code></p><h4 id="config">config</h4><pre class="language-none"><code class="language-none">Host &#123;remoteserver&#125;     HostName &#123;remote_host&#125;     User &#123;username&#125;     Port 2222     IdentityFile ~&#x2F;.ssh&#x2F;id_rsa     ProxyCommand &#123;...&#125;Host *     Port 233     User root</code></pre><ul><li><code>Host *</code>匹配了所有的<code>remote_host</code>，也就是当所有匹配不成功的最后选项。后面的<code>Port</code>表示所有主机的默认连接端口都是233，<code>User</code>表示默认登录用户为 root 。</li><li><code>remoteserver</code>是<code>remote_host</code>的别名</li><li><code>IdentityFile</code>是指定用来登录验证的私钥文件，与<code>ssh -i &#123;path/to/id_rsa&#125;</code>的作用相同</li><li>还有一个<code>ProxyCommand</code>它大概有两个使用场景（原理都一样），一个是用代理进行<code>ssh</code>，另一个是使用跳板机（中转机）。这个我们后面的端口转发篇再说。 与<code>ssh -o "&#123;ProxyCommand&#125;"</code>作用相同，这里假设我要用本地的<code>Clash</code>7890端口做一个<code>socks5</code>协议的代理。</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#Windows 使用 git 自带的 connect 工具</span>ProxyCommand connect -S <span class="token number">127.0</span>.0.1:7890 %h %p<span class="token comment">#Linux 使用 netcat 也就是 nc 工具</span>ProxyCommand <span class="token function">nc</span> -X <span class="token number">5</span> -x <span class="token number">127.0</span>.0.1:7890 %h %p</code></pre><ul><li><code>%p</code>和<code>%h</code>分别是<code>ssh</code>的端口号以及<code>remote_host</code></li><li><code>connect</code><ul><li><code>-S</code>和<code>-H</code>分别是<code>socks</code>和<code>HTTPS</code>代理</li></ul></li><li><code>nc</code><ul><li><code>-X 5</code>指定代理协议为<code>socks 5</code>，如果是<code>HTTPS</code>代理则为<code>-X connect</code></li><li><code>-x</code>指定代理的主机地址和端口</li></ul></li></ul><p>登录之后可以用<code>who -a</code>查看一下登录的 IP 是否是你的代理服务器 IP。</p><p>当你用<code>ssh</code>成功登录一次后，会自动在<code>config</code>文件中生成对应的配置文件，<code>IdentityFile</code>默认缺省。这样，以后我们<code>ssh</code>一个已经在<code>config</code>中的主机的时候，可以直接<code>ssh remoteserver</code>登录，而不需要写一串命令。</p><h4 id="sshd_config">sshd_config</h4><ul><li><strong>Port</strong>：建议改为非22的LuckyNumber，防止被扫端口弱口令爆破。</li><li><strong>PermitRootLogin</strong>：是否允许 root 账号直接登录。设置为 no 可以有效防止自己<code>rm -rf /</code>的欲望</li><li><strong>PermitEmptyPasswords</strong>：是否允许空密码登录。如果设置为 yes 并且登录的用户密码为空，则可以使用这个用户免密码登录。</li><li><strong>PasswordAuthentication</strong>：是否允许密码登录。如果设置为 no 可以增加安全性。</li><li><strong>PrintMotd</strong>： 打印登录提示信息，提示信息存储在/etc/moed文件中</li><li>更改配置项后，记得重启<code>sshd</code>服务</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl restart sshd.service</code></pre><h3 id="公私钥的概念">公私钥的概念</h3><p>上面我们使用<code>ssh</code>的时候每一次登录都需要输入密码，这并不安全，其次非常麻烦。<code>ssh</code>鼓励用户使用非对称加密的<strong>公私钥验证</strong>来进行登录，而不是使用密码。所谓的<strong>公私钥验证</strong>，本质上是一套加密算法生成出的一对RSA<strong>公钥</strong>和<strong>私钥</strong>。其中<strong>私钥</strong>自行保存，而<strong>公钥</strong>可以用来放在远程的服务器上。这样当远程的服务器接收到来自由你私钥发出的命令后，会使用之前存放的公钥进行认证。免去了在网络明文使用密码传输的风险。在<code>ssh</code>中，我们可以使用<code>ssh-keygen</code>来生成一对公私钥。</p><ul><li>小试一下（使用<code>ssh-keygen</code>生成并查看）</li><li><code>ssh-keygen</code>除了用来生成密钥，还可以用来删除失效变更的公钥指纹（known_hosts），这通常发生在远程服务器出于某些原因被重置了。</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-keygen -R <span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span></code></pre><h3 id="上传ssh公钥的三种姿势">上传SSH公钥的三种姿势</h3><p>上传公钥的最终目的是在你要登录用户的<code>~/.ssh/authorized_keys</code>文件中追加你的<strong>公钥文本</strong>。如果目标用户没有这个文件，需要先自行创建，并修改对应的<strong>权限</strong>，否则<code>ssh</code>不会信任你的公钥。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token number">600</span> ~/.ssh/authorized_keys<span class="token function">chmod</span> <span class="token number">700</span> ~/.ssh</code></pre><h4 id="manualsimulation">ManualSimulation</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/.ssh<span class="token function">touch</span> ~/.ssh/authorized_keys<span class="token function">vim</span> ~/.ssh/authorized_keys<span class="token comment">#把公钥复制粘贴进去</span></code></pre><p>当然，如果你熟悉管道运算符，你还可以一句话搞定</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub <span class="token operator">|</span> <span class="token function">ssh</span> <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span> <span class="token string">"mkdir -p ~/.ssh &amp;&amp; cat >> ~/.ssh/authorized_keys"</span></code></pre><h4 id="scp">scp</h4><p><code>scp</code>是 SSH 提供的一个客户端程序，用来在两台主机之间加密传送文件（即复制文件）。其用法和<code>cp</code>类似。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> ~/.ssh/id_rsa.pub <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span>:~/<span class="token function">ssh</span> <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span> <span class="token string">"cat ~/id_rsa.pub >> ~/.ssh/authorized_keys"</span><span class="token function">rm</span> ~/id_rsa.pub<span class="token comment"># 或者</span><span class="token function">scp</span> ~/.ssh/id_rsa.pub <span class="token punctuation">&#123;</span>user<span class="token punctuation">&#125;</span>@<span class="token punctuation">&#123;</span>remote_host<span class="token punctuation">&#125;</span>:~/.ssh/authorized_keys</code></pre><h4 id="ssh-copy-id">ssh-copy-id</h4><p>OpenSSH 自带一个<code>ssh-copy-id</code>命令，可以自动将公钥拷贝到远程服务器的<code>~/.ssh/authorized_keys</code>文件。如果<code>~/.ssh/authorized_keys</code>文件不存在，<code>ssh-copy-id</code>命令会自动创建该文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-copy-id -i key_file user@host</code></pre><ul><li>注意，<code>ssh-copy-id</code>是直接将公钥添加到<code>authorized_keys</code>文件的末尾。如果<code>authorized_keys</code>文件的末尾不是一个换行符，会导致新的公钥添加到前一个公钥的末尾，两个公钥连在一起，使得它们都无法生效。所以，如果<code>authorized_keys</code>文件已经存在，使用<code>ssh-copy-id</code>命令之前，务必保证<code>authorized_keys</code>文件的末尾是换行符（假设该文件已经存在）。</li></ul><h2 id="ssh端口转发">SSH端口转发</h2><blockquote><p>SSH 除了登录服务器，还有一大用途，就是作为加密通信的中介，充当两台服务器之间的通信加密跳板，使得原本不加密的通信变成加密通信。这个功能称为端口转发（port forwarding），又称 SSH 隧道（tunnel）。</p><p>端口转发有两个主要作用：</p><p>（1）将不加密的数据放在 SSH 安全连接里面传输，使得原本不安全的网络服务增加了安全性，比如通过端口转发访问 Telnet、FTP 等明文服务，数据传输就都会加密。</p><p>（2）作为数据通信的加密跳板，绕过网络防火墙。</p></blockquote><h3 id="本地转发正向转发">本地转发（正向转发）</h3><p>把远程服务器的端口映射到本地，绕过防火墙和安全组的限制。比如我在远程服务器的8888端口运行了一个不知名的 Web 应用，如果我要在公网临时查看他的部署结果，毕竟远程服务器一般情况下是没有<code>GUI</code>的，那么我必须开防火墙和安全组让这个端口暴露在公网，完事后还得再关上，比较麻烦。那么就可以使用<code>ssh</code>本地转发。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -L <span class="token punctuation">[</span>local-remote:<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>local-port<span class="token punctuation">&#125;</span>:<span class="token punctuation">&#123;</span>target-host<span class="token punctuation">&#125;</span>:<span class="token punctuation">&#123;</span>target-port<span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>tunnel-host<span class="token punctuation">&#125;</span></code></pre><ul><li><code>local-remote</code>缺省为本机</li><li><code>tunnel-host</code>就是一句能正常登陆你的远程服务器的<code>ssh</code>连接语句</li><li><code>local-port</code>是映射到本地的某个端口</li><li><code>target-host</code>为最终的<code>remote_host</code>，如果是访问<code>tunnel-host</code>的服务，则为<code>localhost</code>，要不就是某个内网机器的 host 地址</li><li><code>target-port</code>为最终的<code>remote_host</code>的端口号，也就是服务真正所在的端口</li></ul><p>当然，你也可以使用万能的 <strong>VSCode</strong> 直接一键转发。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220319224716.png" alt="image-20220319224707914" / loading="lazy"><figcaption aria-hidden="true">image-20220319224707914</figcaption></figure><h3 id="远程转发反向转发">远程转发（反向转发）</h3><p><strong>WARNING！反向转发有一定风险</strong></p><p>把本地的某个端口映射到远程服务器，这个应用场景也很常见，比如我在宿舍的机子上跑了一个不知名的 WEB Docker 容器，但是校园网是经过 <strong>NAT</strong> 没有所谓的公网IP，这样在校外就无法访问到我的应用。那么就可以使用<code>ssh</code>远程转发，这样我就可以通过访问具有公网IP的远程服务器的某个端口访问到我的应用。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -R <span class="token punctuation">[</span>remote-host:<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>remote-port<span class="token punctuation">&#125;</span>:<span class="token punctuation">&#123;</span>target-host<span class="token punctuation">&#125;</span>:<span class="token punctuation">&#123;</span>target-port<span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>tunnel-host<span class="token punctuation">&#125;</span></code></pre><ul><li><code>remote-host</code>缺省为<code>tunnel-host</code>的<code>localhost</code>。如果你想让应用被公网任意地址访问，需要更改为<code>0.0.0.0</code>，否则只能被远程机器用<code>localhost</code>访问，就完全相当于正向转发的逆向了。</li><li><code>remote-port</code>是映射到远程服务器的某个端口，记得打开对应防火墙和安全组</li><li><code>target-host</code>是应用所在的 host ，本地就是<code>localhost</code></li><li><code>target-port</code>是服务真正所在的端口</li></ul><p>但是<code>ssh</code>默认配置的情况下，哪怕你改了<code>remote-host</code>为<code>0.0.0.0</code>也不会让你进行一个公网的访问，这是出于安全考量的。</p><p>如果你使用<code>-v</code>查看的话，就会发现一个警告<code>Remote: Forwarding listen address "192.168.1.1" overridden by server GatewayPorts</code></p><p>so，若果想要开启，需要更改<code>~/.ssh/config</code>的<code>GatewayPorts</code>为yes</p><h3 id="tips">Tips</h3><ol type="1"><li>反向转发注意安全</li><li>可以使用<code>-f</code>后台执行</li><li>可以使用<code>-N</code>不进入ssh交互命令行模式</li><li>通过<code>ssh</code>进行端口转发其实并不稳定，想要构建稳定的端口转发可以了解<code>autossh</code>或者<code>frp</code></li></ol><h2 id="参考">参考</h2><p>https://wangdoc.com/ssh/basic.html</p><p>https://kanda.me/2019/07/01/ssh-over-http-or-socks/</p><p>https://abcdabcd987.com/ssh/</p><p>https://www.cnblogs.com/bonelee/p/12511024.html</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;来学校上了两周网课，两周线下，现在又要上网课了G！上网课就算了，我还要给学弟上网课哈哈。整一波虚拟教师V出道&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220320002327.jpg&quot; alt=&quot;63476067_p0_master1200&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="项目经历" scheme="http://lapras.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="教程" scheme="http://lapras.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="网络" scheme="http://lapras.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>浅谈贝叶斯定理</title>
    <link href="http://lapras.xyz/2022/02/28/8fd34f7b.html"/>
    <id>http://lapras.xyz/2022/02/28/8fd34f7b.html</id>
    <published>2022-02-28T11:03:59.000Z</published>
    <updated>2022-06-26T13:42:13.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>恍恍惚惚，大二下开始学习概率论了，G！</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220228195301.jpg" alt="95841206_p0" / loading="lazy"><figcaption aria-hidden="true">95841206_p0</figcaption></figure><span id="more"></span><h3 id="引例">引例</h3><p>上完了九年义务制教育的朋友们大多知道什么叫概率，再不济也知道古典概型无非就是从有限的盒子里等可能地去摸球。概率嘛，无非就是可能除以总数（X）。好，那让我们来看看下面这个问题：</p><blockquote><p>假设某种疾病在所有人群中的感染率是1%，医院现有的技术对于该疾病检测的灵敏度(Sensitivity)为90%，这意味着100个确诊的人中有10名将会是误诊的。而技术的特异度（Specificity）为91%，这意味着100名健康的人群中会有9人误诊。</p><p>好的，现在请思考一下，假设我们对1000名人员进行该医学检测，而你不幸被检测为阳性（患病），请问你患病的几率大概是多少呢？</p></blockquote><ol type="A"><li><span class="math inline">\(9\over 10\)</span> B.<span class="math inline">\(8\over10\)</span> C.<span class="math inline">\(1\over 10\)</span> D.<span class="math inline">\(1\over 100\)</span></li></ol><p><strong>答案在分割线下！！！</strong></p><hr /><p>嘿嘿，答案是<strong>C</strong>。</p><p>真是奇怪，明明这么高的灵敏度，为什么患病的几率反而如此之低ne？这其实就是一种反直觉的现象。现在让我们一起算一下这题。</p><p>1000个人中的感染率为1%，也就是有10个人是真正的患者，检测的灵敏度为90%，换言之误诊率为10%。这意味着我们会检测出其中的9名真正的患者和1名误诊的。而91%的特异度将会为我们带来 <span class="math display">\[(1000-10)*(1-91\%)\approx89\]</span> 89名误诊！接着用我们都会的条件概率进行简单地计算 <span class="math display">\[P(confirm\,Patient|Patient)=\tfrac{9}{9+89}=0.091\]</span> 不到十分之一的概率为真正的患者，That's so ridiculous。其实不难发现，这里的假阳性比阳性的还要多。</p><h3 id="谬">“谬”</h3><p>这里引用<span class="math inline">\(3b1b\)</span>大佬的话，我们算出的概率并不能体现你患病的几率，正确的观点是我们算出的概率<strong>更新</strong>了你患病的几率。</p><p>这里就可以引出先验概率的概念</p><blockquote><p>先验概率（prior probability）是指根据以往经验和分析得到的概率，如全概率公式，它往往作为"由因求果"问题中的"因"出现的概率。</p></blockquote><p>显然，原本的先验概率为人群中的感染率也就是1%。而检测的值<strong>更新</strong>了这一概率，将概率增加了一个数量级。但这并不是我们想要的答案。在本题中我们只关心检测出为阳性时的情况倾向。 <span class="math display">\[\tfrac{Sensitivity}{1-Specificity}=10\]</span> 这就是似然比(likelihood ratio)，也叫做贝叶斯因子。这里有个著名的经验公式，贝叶斯推断。用于更新<strong>较小的先验概率</strong>。在本例中，先验概率为1%，乘以贝叶斯因子后结果为 0.1 接近了正确答案 0.091。</p><p>再举个例子，将上面的条件由1000人换到100人，患病率由1%换成10%。这意味着我们将有10名确诊（9名真患者，1名误诊），90名正常（8人逃脱，81名正常）。但是我们的似然比保持不变为10。 <span class="math display">\[P(confirm\,Patient|Patient)=\tfrac{9}{9+8}\approx 53\%\]</span> 显然在先验概率过大的情况下随意使用经验公式，会出问题。但事实上，之所以只能在较小的先验概率中使用，是因为他的原型为更新比率而非更新概率。比如50%的概率，他的比率为 1:1。所以真正的贝叶斯公式，<strong>是将先验概率以比率的形式被贝叶斯因子更新。</strong></p><p>回到最开始的条件，先验概率为 1%，比率形式为 1:99，然后用贝叶斯因子更新为 10:99 也就是 10/109 的概率，与我们计算的答案别无二致。</p><p>同样的，当先验概率为10%，比率形式为 1:9 ，更新后为 10:9 也就是 10/19 的概率，正好是 53%。</p><p>回到，我们一开始的问题。给予人们这种错觉的原因往往是条件概率的认知不清。当我们在说准确率为99%准确性的测试的时候，表示的是 <strong>已知一个人得病(B)的情况下检测出阳性(A)的概率</strong>。即 <span class="math inline">\(P(A|B)\)</span>，而人人往往将其等同于 <strong>一个人在检测出阳性(A)的情况下得病(B)的概率</strong>。即<span class="math inline">\(P(B|A)\)</span>。那么，有没有一种………</p><h3 id="贝叶斯">贝叶斯</h3><p>贝叶斯是一种已知结果B反求因A的思想。下面举个例子：</p><div><p>graph TB A1(A1)--&gt;B(B) A2(A2)--&gt;B(B) A3(A3)--&gt;B(B)</p></div><p>显然这里有三条路径来完成整件事情，对于第一条路径 A1-&gt;B 而言： <span class="math display">\[P_1=P(A1)*P(B|A1)\]</span> 同样的，我们可以得到 <span class="math inline">\(P2\)</span> 和 <span class="math inline">\(P3\)</span> ，而他们的求和正好就是B的全概率公式，也是贝叶斯公式的分母。</p><p>那么现在我们求的<strong>因</strong>，也就是其中一条路径在全部路径中的概率，问题就是一个简单的<strong>类古典概型</strong>了。</p><p>给出我们的通式： <span class="math display">\[P(A|B)=\frac{P(B|A)*P(A)}{P(B|A)*P(A)+P(B|A^c)*P(A^c)}\]</span></p><ul><li>这里的<span class="math inline">\(A^c\)</span>是A的对立事件</li><li>分母为<span class="math inline">\(P(B)\)</span>的全概率公式</li></ul><h3 id="参考">参考</h3><p><a href="https://zhuanlan.zhihu.com/p/22467549">Think Bayes</a></p><p><a href="https://www.youtube.com/watch?v=lG4VkPoG3ko">The medical test paradox, and redesigning Bayes' rule</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;恍恍惚惚，大二下开始学习概率论了，G！&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220228195301.jpg&quot; alt=&quot;95841206_p0&quot; /&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;95841206_p0&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    
    <category term="数学" scheme="http://lapras.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>信息茧房脱出-自建RSS</title>
    <link href="http://lapras.xyz/2021/12/15/3db8db5b.html"/>
    <id>http://lapras.xyz/2021/12/15/3db8db5b.html</id>
    <published>2021-12-15T03:37:57.000Z</published>
    <updated>2022-06-27T08:56:02.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>RSS，也就是 Rich Summary Site 。这玩意儿有点时代的眼泪的感觉了。在推荐算法大行其道的当下，RSS本身是一种逆潮流的选择。加之国区对于RSS应用的监管力度之大致使很多优秀的RSS服务在国内被和谐。</p><p>我之前一直使用的是 feeder.co 无奈他的 IPAD 应用不仅要 Dollar，还锁了国区。所以选择折腾一手，自建RSS。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216172339.jpeg" alt="img" style="zoom:67%;" / loading="lazy"></p><span id="more"></span><h2 id="miniflux">Miniflux</h2><p><a href="https://miniflux.app/">Miniflux</a> 是一个免费开源的RSS聚合源，与另一个开源的 <a href="https://tt-rss.org/">TTRSS</a> 相比，它的极简设计风格，深的我心（虽然默认UI都差不多丑）。</p><p>然后 Miniflux 是基于<code>GO</code>的，没有其他奇奇怪怪的依赖项。</p><h3 id="部署">部署</h3><p>如果你没有 Docker 以及 Docker-compose，请立即安装并学习。</p><p><a href="https://vuepress.mirror.docker-practice.com/">Docker 从入门到实践</a></p><ol type="1"><li>新建一个 miniflux 目录</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/miniflux <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> ~/miniflux</code></pre><ol start="2" type="1"><li>创建并修改 <code>docker-compose.yml</code></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.4'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">miniflux</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> miniflux/miniflux<span class="token punctuation">:</span>latest    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"&lt;181>:8080"</span>  <span class="token comment"># 端口181</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> db    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> DATABASE_URL=postgres<span class="token punctuation">:</span>//miniflux<span class="token punctuation">:</span>&lt;passWord<span class="token punctuation">></span><span class="token punctuation">,</span>.@db/miniflux<span class="token punctuation">?</span>sslmode=disable <span class="token comment"># 数据库密码</span>      <span class="token punctuation">-</span> RUN_MIGRATIONS=1      <span class="token punctuation">-</span> CREATE_ADMIN=1      <span class="token punctuation">-</span> ADMIN_USERNAME=&lt;admin<span class="token punctuation">></span>  <span class="token comment"># 登录Miniflux的用户名，可自定义</span>      <span class="token punctuation">-</span> ADMIN_PASSWORD=&lt;password<span class="token punctuation">></span>  <span class="token comment"># 登录Miniflux的密码，可自定义，至少6位</span>    <span class="token key atrule">healthcheck</span><span class="token punctuation">:</span>      <span class="token key atrule">test</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"CMD"</span><span class="token punctuation">,</span> <span class="token string">"/usr/bin/miniflux"</span><span class="token punctuation">,</span> <span class="token string">"-healthcheck"</span><span class="token punctuation">,</span> <span class="token string">"auto"</span><span class="token punctuation">]</span>  <span class="token key atrule">db</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span class="token punctuation">:</span>latest    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> POSTGRES_USER=miniflux      <span class="token punctuation">-</span> POSTGRES_PASSWORD=secret    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> miniflux<span class="token punctuation">-</span>db<span class="token punctuation">:</span>/var/lib/postgresql/data    <span class="token key atrule">healthcheck</span><span class="token punctuation">:</span>      <span class="token key atrule">test</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"CMD"</span><span class="token punctuation">,</span> <span class="token string">"pg_isready"</span><span class="token punctuation">,</span> <span class="token string">"-U"</span><span class="token punctuation">,</span> <span class="token string">"miniflux"</span><span class="token punctuation">]</span>      <span class="token key atrule">interval</span><span class="token punctuation">:</span> 10s      <span class="token key atrule">start_period</span><span class="token punctuation">:</span> 30s<span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">miniflux-db</span><span class="token punctuation">:</span></code></pre><ul><li>自行修改上述带有<code>&lt;&gt;</code>的选项</li></ul><ol start="3" type="1"><li>启动 Miniflux</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> up -d</code></pre><p>访问 <code>localhost:&lt;端口&gt;</code> 进入 Miniflux 的管理页面说明大成功，然后就可以开启相应的防火墙，让外网也可以访问。</p><h2 id="rsshub">RssHub</h2><p>Miniflux 充当的角色是个<strong>聚合的订阅源</strong>，那么源本身从哪里来呢？别人整合的固然方便，但是自定义程度肯定不如自己来得爽。但是有些网站或者博客根本没有做 RSS 订阅（<del>比如我</del>）</p><blockquote><p>RSSHub 是一个开源、简单易用、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。RSSHub 借助于开源社区的力量快速发展中，目前已适配数百家网站的上千项内容</p><p>可以配合浏览器扩展 <a href="https://github.com/DIYgod/RSSHub-Radar">RSSHub Radar (opens new window)</a>和 移动端辅助 App <a href="https://github.com/Cay-Zhang/RSSBud">RSSBud (opens new window)</a>(iOS) 与 <a href="https://github.com/LeetaoGoooo/RSSAid">RSSAid (opens new window)</a>(Android) 食用</p></blockquote><h3 id="使用">使用</h3><p>最常用的场景就是下载一个浏览器插件，他会自动嗅探当前网页，如果有符合的路由规则（来自于开源社区的支持），他会自动帮你生成一个 RSS 源，同时支持一键导入到你的聚合源（在设置界面中添加Miniflux的地址）。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216165507.png" alt="image-20211216165506944" style="zoom:67%;" / loading="lazy"></p><h3 id="部署-1">部署</h3><p>RSSHub默认可以使用官方提供的服务器服务，但出于反爬以及稳定性的考量，还是建议我们选择自建服务。</p><del>如果你没有Docker以及Docker-compose，请立即安装并学习。</del><p>运行下面的命令下载 RSSHub 镜像</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> pull diygod/rsshub</code></pre><p>然后运行</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -d --name rsshub -p <span class="token number">1200</span>:1200 diygod/rsshub</code></pre><h3 id="添加配置">添加配置</h3><p>配置运行在 docker 中的 RSSHub，最便利的方法是使用 docker 环境变量</p><p>以设置缓存时间为 1 小时举例，只需要在运行时增加参数：<code>-e CACHE_EXPIRE=3600</code></p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -d --name rsshub -p <span class="token number">1200</span>:1200 -e <span class="token assign-left variable">CACHE_EXPIRE</span><span class="token operator">=</span><span class="token number">3600</span> </code></pre><p>更多配置项请看 <a href="https://docs.rsshub.app/install/#pei-zhi">官方文档</a></p><h3 id="使用-1">使用</h3><p>同样的，在部署成功之后访问对应的地址。（记得打开防火墙）</p><p>然后就可以在 RSSHub Rader 等的设置页面，使用自定义 RSSHub域名</p><h2 id="阅读器推荐">阅读器推荐</h2><p>说了这么多，总得来点读的，考虑到我的使用场景，所以没有找IOS或者Android的阅读器。</p><h3 id="win10win11">win10&amp;win11</h3><p>推荐国人大佬 云之幻 制作的<a href="https://www.microsoft.com/zh-cn/p/rss-%E8%BF%BD%E8%B8%AA/9n85pv1rjd6v">RSS追踪</a>，界面充分体现了UWP应用一贯的极简且平滑的设计理念👍。</p><blockquote><p>集成多种主流RSS服务的原生UWP阅读器，通过在线服务，你可以实现多端同步。经过全新设计的UI与强化后的功能，是Windows端一个不错的RSS阅读选择</p></blockquote><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216170732.jpeg" alt="img" style="zoom:67%;" / loading="lazy"></p><p>这里选择Fever模式</p><p>进入Miniflux的后台，在设置中打开Fever插件，设置用户名密码后。即可用 <code>http://IP:minifluxport/fever/</code> 的方式导入</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216171232.png" alt="image-20211216171231808" style="zoom:67%;" / loading="lazy"></p><p>总之就是清爽😎</p><h3 id="ipados">ipadOS</h3><p>APPStore 个人觉得最好用的 Feeder 5 已经从国区下架了，国人团队做的 Ego Reader 体验也不错。可惜横屏适配问题一直没有解决。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216172758.jpg" alt="img" style="zoom:67%;" / loading="lazy"></p><h2 id="踩坑">踩坑</h2><h3 id="v2raya代理问题">V2rayA代理问题</h3><p>可能因为<code>/etc/resolv.conf</code>被V2rayA自动修改成本地的53端口来进行<code>redirect</code>透明代理，导致docker内容器出现ping不通，curl不了的问题。经过以下三个步骤，我把docker容器都设置为走V2rayA的代理模式了。</p><ol type="1"><li>重新用docker部署了一遍V2rayA</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># run v2raya</span><span class="token function">docker</span> run -d <span class="token punctuation">\</span>  --restart<span class="token operator">=</span>always <span class="token punctuation">\</span>  --privileged <span class="token punctuation">\</span>  --network<span class="token operator">=</span>host <span class="token punctuation">\</span>  --name v2raya <span class="token punctuation">\</span>  -e <span class="token assign-left variable">V2RAYA_ADDRESS</span><span class="token operator">=</span><span class="token number">0.0</span>.0.0:2017 <span class="token punctuation">\</span>      -v /lib/modules:/lib/modules <span class="token punctuation">\</span>  -v /etc/resolv.conf:/etc/resolv.conf <span class="token punctuation">\</span>  -v /etc/v2raya:/etc/v2raya <span class="token punctuation">\</span>  mzz2017/v2raya</code></pre><ol start="2" type="1"><li>设置<code>~/.docker/config.json</code></li></ol><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"proxies"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"default"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"httpProxy"</span><span class="token operator">:</span> <span class="token string">"http://192.168.1.5:20172"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><code>192.168.1.5</code>是我自定义的docker0 inet，请使用<code>ifconfig</code>或者<code>ip a</code>，自行查看<code>docker0</code>的inet</li><li>20172是我的V2RayA的HTTP分流端口</li></ul><ol start="3" type="1"><li>我的V2rayA的设置</li></ol><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216160732.png" alt="image-20211216160732519" style="zoom:50%;" / loading="lazy"></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216160830.png" alt="image-20211216160829968" style="zoom: 67%;" / loading="lazy"></p><h2 id="参考">参考</h2><p><a href="https://miniflux.app/">Miniflux</a></p><p><a href="https://docs.rsshub.app/">RSSHub</a></p><p><a href="https://hydrotho.github.io/Miniflux-Build-Guide/">利用 Miniflux 自建 RSS</a></p><p>​</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;RSS，也就是 Rich Summary Site 。这玩意儿有点时代的眼泪的感觉了。在推荐算法大行其道的当下，RSS本身是一种逆潮流的选择。加之国区对于RSS应用的监管力度之大致使很多优秀的RSS服务在国内被和谐。&lt;/p&gt;
&lt;p&gt;我之前一直使用的是 feeder.co 无奈他的 IPAD 应用不仅要 Dollar，还锁了国区。所以选择折腾一手，自建RSS。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211216172339.jpeg&quot; alt=&quot;img&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="分享" scheme="http://lapras.xyz/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="教程" scheme="http://lapras.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的算法-最短路问题</title>
    <link href="http://lapras.xyz/2021/12/07/adfa5e63.html"/>
    <id>http://lapras.xyz/2021/12/07/adfa5e63.html</id>
    <published>2021-12-07T09:51:02.000Z</published>
    <updated>2022-06-14T06:10:07.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>呜呜呜，考试月要来li</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211207175750.png" style="zoom:50%;" / loading="lazy"></p><span id="more"></span><h2 id="单源最短路">单源最短路</h2><p><strong>最短路径</strong>问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。</p><h3 id="形式">形式</h3><ul><li><strong>确定起点的最短路径问题</strong> - 也叫单源最短路问题，即已知起始结点，求最短路径的问题。在边权非负时适合使用<a href="https://zh.wikipedia.org/wiki/Dijkstra算法">Dijkstra算法</a>，若边权为负时则适合使用<a href="https://zh.wikipedia.org/wiki/Bellman-ford">Bellman-ford算法</a>或者<a href="https://zh.wikipedia.org/wiki/SPFA算法">SPFA算法</a>。</li><li><strong>确定终点的最短路径问题</strong> - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在<a href="https://zh.wikipedia.org/wiki/無向圖">无向图</a>中该问题与确定起点的问题完全等同，在<a href="https://zh.wikipedia.org/wiki/有向图">有向图</a>中该问题等同于把所有路径方向反转的确定起点的问题。</li><li><strong>确定起点终点的最短路径问题</strong> - 即已知起点和终点，求两结点之间的最短路径。</li><li><strong>全局最短路径问题</strong> - 也叫多源最短路问题，求图中所有的最短路径。适合使用<a href="https://zh.wikipedia.org/wiki/Floyd-Warshall算法">Floyd-Warshall算法</a>。</li></ul><h3 id="性质">性质</h3><ul><li>对于边权为正的图，最短路不会经过重复的结点与边</li><li>对于边权为正的图，最短路的结点数不会超过<span class="math inline">\(n\)</span>，边数不会超过<span class="math inline">\(n-1\)</span></li><li><strong>负圈</strong>：总边权值小于零的环，存在负圈时会导致某些算法死循环。</li></ul><h3 id="一些约定">一些约定</h3><ul><li><span class="math inline">\(n\)</span>为结点数，<span class="math inline">\(m\)</span>为边数</li><li><span class="math inline">\(s\)</span>为最短路的起始点</li><li><span class="math inline">\(dis(u)\)</span>为<span class="math inline">\(s\)</span>点到<span class="math inline">\(u\)</span>点的<strong>动态最短路长度</strong></li><li><span class="math inline">\(w(u,v)\)</span>为<span class="math inline">\((u,v)\)</span>的边权</li></ul><h3 id="松弛操作">松弛操作</h3><p>由于最短路的算法，大部分的都有用到松弛（relax）操作，所以这里先理清楚。</p><p>最短路径的估计值（<span class="math inline">\(dis\)</span>）起初是被高估的（初始化为<span class="math inline">\(INF\)</span>），就好像一个被拉长的弹簧。但事实上，我们可以找到更短的路径来替代这个弹簧，导致弹簧不再紧绷，而是放松下来，不断更新，最终找到最短路径。其实就是一种动态规划的思想。</p><p>公式：对于边<span class="math inline">\((u,v)\)</span>，有<span class="math inline">\(dis(v)=min(dis(v),dis(u)+w(u,v))\)</span></p><h2 id="floyd-warshall">Floyd-Warshall</h2><h3 id="思想">思想</h3><p>求两点<span class="math inline">\(i，j\)</span>之间的的距离，可以分成两种情况考虑。即经过某个点<span class="math inline">\(k\)</span>，或者不经过某个点<span class="math inline">\(k\)</span>，然后就取两者中的较短路径，最终得到最短路径。<del>就是动态规划</del>。那么，记<span class="math inline">\(f(x,y)\)</span>为x到y的最短路径长度，可以得到</p><p>​ <span class="math inline">\(f(x,y)=min(f(x,y),f(x,k)+f(k,y))\)</span></p><h3 id="实现">实现</h3><p>使用邻接矩阵<span class="math inline">\(G\)</span>储存图，初始化为<span class="math inline">\(INF\)</span>。</p><pre class="language-none"><code class="language-none">初始化：    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            if (i &#x3D;&#x3D; j) d[i][j] &#x3D; 0;            else d[i][j] &#x3D; INF;&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离void floyd()&#123;    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);&#125;</code></pre><h3 id="细节">细节</h3><ul><li>显然是<span class="math inline">\(O(n^3)\)</span></li><li>可以得到图上所有点到所有点的最短路<span class="math inline">\(d[i][j]\)</span></li><li>不难发现，<span class="math inline">\(d[i][i]\)</span>最后的值为，从<span class="math inline">\(i\)</span>出发到<span class="math inline">\(i\)</span>的最短路径，也就是出去绕一圈回来的路径</li><li>利用上述条件，Floyd算法可以快速判断图中是否存在<strong>负圈</strong>，也就是判断<span class="math inline">\(diag(d)\)</span>是否存在小于0的值</li></ul><h2 id="bellman-ford">Bellman-Ford</h2><h3 id="思想-1">思想</h3><p>不断尝试对图上的每一条边进行<strong>松弛操作</strong>，直到一次循环结束，没有边进行松弛操作为止。</p><h3 id="实现-1">实现</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">edges</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> v<span class="token punctuation">;</span>  <span class="token keyword">int</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>edges<span class="token operator">></span> e<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">bellmanford</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">fill_n</span><span class="token punctuation">(</span>dis<span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>INF<span class="token punctuation">)</span><span class="token punctuation">;</span>  dis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">></span> n<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"存在负圈!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> u <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> u<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">.</span>v<span class="token punctuation">]</span> <span class="token operator">></span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> i<span class="token punctuation">.</span>w<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>          dis<span class="token punctuation">[</span>i<span class="token punctuation">.</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> i<span class="token punctuation">.</span>w<span class="token punctuation">;</span>          flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="细节-1">细节</h3><ul><li>每次循环遍历边的复杂度显然是<span class="math inline">\(O(m)\)</span>。每进行一次松弛，则会让最短路的边数+1，而最短边的上限为<span class="math inline">\(n-1\)</span>，所以为<span class="math inline">\(O(nm)\)</span></li><li>Bellman算法从<span class="math inline">\(s\)</span>出发，如果抵达一个负环，松弛操作会无限进行下去，但是由于最短路边数存在上限<span class="math inline">\(n-1\)</span>，所以也可以快速判断<strong>负圈</strong></li><li>上述结论其实不大严谨</li></ul><blockquote><p>负环判断中存在的常见误区</p><p>需要注意的是，以S点为源点跑 Bellman-Ford 算法时，如果没有给出存在负环的结果，只能说明从S点出发不能抵达一个负环，而不能说明图上不存在负环。</p><p>因此如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为 0 的边，然后以超级源点为起点执行 Bellman-Ford 算法。</p></blockquote><h3 id="优化">优化</h3><p>根据前面的思想可以知道，计算和调整结点<span class="math inline">\(u\)</span>到结点<span class="math inline">\(s\)</span>的最短距离后，如果紧接着调整<span class="math inline">\(u\)</span>的邻居结点，势必会触发新的<strong>松弛操作</strong>，而Bellman算法，则在尝试大量不相关结点的边松弛操作，这显然是低效的。</p><p>因此，在计算结点<span class="math inline">\(u\)</span>之后，下一部只计算和调整它的邻居节点，这样就能大幅度加快收敛的过程。而这显然类似于<span class="math inline">\(BFS\)</span>，所以不难想到用队列进行操作，而这就是<del>被广为诟病的</del>SPFA。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">edge</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> e<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">SPFA</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">fill_n</span><span class="token punctuation">(</span>dis<span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>INF<span class="token punctuation">)</span><span class="token punctuation">;</span>  dis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> v <span class="token operator">=</span> i<span class="token punctuation">.</span>v<span class="token punctuation">,</span> w <span class="token operator">=</span> i<span class="token punctuation">.</span>w<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">></span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">;</span>        cnt<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 记录最短路经过的边数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">>=</span> n<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>          <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"存在负圈"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>          q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>SPFA并不稳定，其最坏情况同样也是O(nm)</li></ul><h2 id="dijkstra">Dijkstra</h2><h3 id="思想-2">思想</h3><p>将结点分成两个集合，<span class="math inline">\(S\)</span>（已确定最短路长度的点集）， <span class="math inline">\(T\)</span>（未确定最短路长度的点集），初始化<span class="math inline">\(dis(s)=0,dis(else)=INF\)</span></p><p>然后重复以下操作，直到<span class="math inline">\(T\)</span>为空</p><ol type="1"><li>从<span class="math inline">\(T\)</span>中，选取最短路长度最小的结点，移动到<span class="math inline">\(S\)</span>中</li><li>对刚加入<span class="math inline">\(S\)</span>的结点的所有出边进行松弛操作</li></ol><h3 id="实现-2">实现</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">edge</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> e<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">fill_n</span><span class="token punctuation">(</span>dis<span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>INF<span class="token punctuation">)</span><span class="token punctuation">;</span>  dis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mind <span class="token operator">=</span> INF<span class="token punctuation">;</span><span class="token comment">//mind为u的最短路长度</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dis<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mind<span class="token punctuation">)</span>        u <span class="token operator">=</span> j<span class="token punctuation">,</span> mind <span class="token operator">=</span> dis<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> v <span class="token operator">=</span> i<span class="token punctuation">.</span>v<span class="token punctuation">,</span> w <span class="token operator">=</span> i<span class="token punctuation">.</span>w<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">></span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span>        dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="优化-1">优化</h3><p>如果不适用任何数据结构维护，显然复杂度为<span class="math inline">\(O(n^2+m)\)</span>，考虑使用二叉堆或者优先队列进行优化</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> e<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> dis<span class="token punctuation">,</span> u<span class="token punctuation">;</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> node<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> dis <span class="token operator">></span> a<span class="token punctuation">.</span>dis<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">fill_n</span><span class="token punctuation">(</span>dis<span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>INF<span class="token punctuation">)</span><span class="token punctuation">;</span>  dis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  priority_queue<span class="token operator">&lt;</span>node<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>node<span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>node<span class="token operator">>></span> q<span class="token punctuation">;</span> <span class="token comment">//创建优先级队列</span>  q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>u<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> v <span class="token operator">=</span> i<span class="token punctuation">.</span>v<span class="token punctuation">,</span> w <span class="token operator">=</span> i<span class="token punctuation">.</span>w<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">></span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>由于二叉堆和优先队列的插入删除元素只需要<span class="math inline">\(O(logn)\)</span>，所以复杂度可以达到<span class="math inline">\(O((m+n)logn)\)</span>和<span class="math inline">\(O(mlogn)\)</span></li></ul><h2 id="打印路径问题">打印路径问题</h2><p>比较简单，用一个整形数组path，在更新距离的时候，记录点是如何转移的即可</p><p>比如 Floyd 就要记录 <code>path[i][j] = k;</code>，Bellman-Ford 和 Dijkstra 一般记录 <code>path[v] = u</code>。</p><h2 id="参考">参考</h2><p><a href="https://oi-wiki.org/graph/shortest-path/">OI-WIKI</a></p><p>《算法导论》</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;呜呜呜，考试月要来li&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211207175750.png&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="http://lapras.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="http://lapras.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="优先队列" scheme="http://lapras.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="图" scheme="http://lapras.xyz/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>小米/红米 AC2100急速刷Breed</title>
    <link href="http://lapras.xyz/2021/12/03/e5ccadb4.html"/>
    <id>http://lapras.xyz/2021/12/03/e5ccadb4.html</id>
    <published>2021-12-03T09:58:06.000Z</published>
    <updated>2021-12-03T10:54:33.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>开热点联机文明6太折磨了，于是入了一台小米AC2100，原本想整个软路由的，日后再嗦。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211203180825.jpeg" alt="小米路由器AC2100立即购买-小米商城" style="zoom: 50%;" / loading="lazy"></p><span id="more"></span><h2 id="准备工作">准备工作</h2><ol type="1"><li><p>插上电源</p></li><li><p>准备两根网线，一根连接网口和<code>WAN</code>口（确保路由器有网络），一根连接<code>LAN</code>口（三选一）和电脑</p></li></ol><h2 id="回退版本">回退版本</h2><h3 id="下载固件">下载固件</h3><p>小米AC2100的 <strong>2.0.722</strong> 版本和红米AC2100的<strong>2.0.7</strong>版本，都留下的SSH漏洞，能让我们进系统刷机。目前全球的AC2100刷机方案，似乎都是由这个漏洞来的，感觉是小米官方有意为之。<del>那你倒是给个开发者模式啊！</del></p><p>所以我们需要先回退到之前的版本，拿到权限后再刷机。</p><blockquote><p><strong>官方下载链接：</strong> 红米RM2100： http://cdn.cnbj1.fds.api.mi-img.com/xiaoqiang/rom/rm2100/miwifi_rm2100_firmware_d6234_2.0.7.bin 小米R2100：http://cdn.cnbj1.fds.api.mi-img.com/xiaoqiang/rom/r2100/miwifi_r2100_firmware_4b519_2.0.722.bin</p></blockquote><h3 id="更换固件">更换固件</h3><p>进入小米路由器的网关(192.168.31.1)</p><p>在常用设置-&gt;系统状态-&gt;升级检测-&gt;手动升级，上传上一步下载好的固件。等待路由器降级重启完成。检查版本无误即可</p><h2 id="刷breed">刷Breed</h2><p>Breed是一个不死uboot，可以方便的刷固件并且保证不会变砖</p><h3 id="漏洞注入">漏洞注入</h3><p>进入网关，可以看到地址栏的链接为</p><pre class="language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.31.1&#x2F;cgi-bin&#x2F;luci&#x2F;;stok&#x3D;&lt;STOK&gt;&#x2F;web&#x2F;home#router</code></pre><p><code>&lt;STOK&gt;</code>是每次登陆都会动态变化的，把他记录下来</p><p>接着在浏览器地址栏中输入以下代码，<strong>注意替换掉<code>&lt;STOK&gt;</code>部分</strong>：</p><pre class="language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.31.1&#x2F;cgi-bin&#x2F;luci&#x2F;;stok&#x3D;&lt;STOK&gt;&#x2F;api&#x2F;misystem&#x2F;set_config_iotdev?bssid&#x3D;Xiaomi&amp;user_id&#x3D;longdike&amp;ssid&#x3D;-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20&#39;s%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg&#39;%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B</code></pre><ul><li>返回<code>&#123;"code":0&#125;</code>代表成功</li><li>返回<code>401</code> 或者<code>404</code>请检查固件版本或者链接</li></ul><h3 id="重启路由">重启路由</h3><p>在上步刷入成功之后，路由器系统灯（下面那个）会从蓝熄灭，然后变黄，再变蓝进入系统</p><p>此时<strong>拔掉电源，按住reset键（红米用针顶住reset孔）同时接上电源</strong>，此时电源灯会经历双闪，然后网络灯（上面那个）蓝色闪烁不停，说明Breed刷机成功。</p><h3 id="访问breed后台">访问Breed后台</h3><p>地址栏输入192.168.1.1或者192.168.2.1可以进入Breed的网关。如果进入失败，请检查以太网的IP设置。</p><p>在网络适配器中更改IPv4协议属性，设置手动获取IP。</p><pre class="language-none"><code class="language-none">IP地址192.168.1.1子网掩码255.255.255.0默认网关192.168.1.1</code></pre><h2 id="刷自定义固件">刷自定义固件</h2><p>固件更新-&gt;选中固件-&gt;然后上传即可</p><p>关于固件我这里推荐老毛子也就是Padavan</p><p><a href="https://opt.cn2qq.com/padavan/">老毛子</a>（红米选择RM2100 小米选择R2100）</p><p>然后等待重启，访问192.168.123.1即可</p><blockquote><p>默认配置</p><p>固件网关：192.168.123.1</p><p>管理页面：http://my.router/</p><p>管理帐号：admin</p><p>管理密码：admin</p><p>WIFI密码：1234567890</p><p>（刷机不会恢复默认配置）</p></blockquote><p>一键更新固件脚本：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> --no-check-certificate -O- https://opt.cn2qq.com/opt-script/up.sh <span class="token operator">></span> /tmp/up.sh <span class="token operator">&amp;&amp;</span> <span class="token function">bash</span> <span class="token operator">&lt;</span> /tmp/up.sh <span class="token operator">&amp;</span></code></pre><h2 id="参考">参考</h2><p>https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=4066963&amp;extra=page%3D2%26filter%3Dtypeid%26typeid%3D43</p><p>http://openwrt.ink:88/archives/s-breed</p><p><a href="https://opt.cn2qq.com/">Breed固件</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;开热点联机文明6太折磨了，于是入了一台小米AC2100，原本想整个软路由的，日后再嗦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211203180825.jpeg&quot; alt=&quot;小米路由器AC2100立即购买-小米商城&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="折腾系列" scheme="http://lapras.xyz/categories/%E6%8A%98%E8%85%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="教程" scheme="http://lapras.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="网络" scheme="http://lapras.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="硬件" scheme="http://lapras.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>数据结构期末复习</title>
    <link href="http://lapras.xyz/2021/12/01/e7c345c1.html"/>
    <id>http://lapras.xyz/2021/12/01/e7c345c1.html</id>
    <published>2021-12-01T04:26:03.000Z</published>
    <updated>2021-12-02T17:01:10.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>好好好，cxg又让我水了一篇博客。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211203005405.gif" alt="img" style="zoom:50%;" / loading="lazy"></p><span id="more"></span><h2 id="introduction">Introduction</h2><h3 id="基本概念">基本概念</h3><h4 id="基本概念-1">1. 基本概念</h4><ol type="1"><li>数据：可被计算机识别并加工的对象</li><li>数据元素：由数据组成的具有一定意义的基本单位，也称为元素、记录。</li><li>数据项：是组成数据元素的不可分割的最小单位</li></ol><h4 id="数据结构">2. 数据结构</h4><ul><li>逻辑结构<ul><li>线性结构 -&gt; 学生信息</li><li>树形结构 -&gt; 族谱</li><li>图结构 -&gt; 地图</li><li>集合结构 -&gt; 班级团体</li></ul></li><li>储存结构<ul><li>顺序存储结构</li><li>链式存储结构</li></ul></li></ul><h3 id="抽象数据类型">抽象数据类型</h3><h4 id="数据类型">1. 数据类型</h4><p>数据类型是性质相同的<strong>值的集合</strong>以及定义在该值集上的<strong>运算集合</strong>，比如整形、字符型等等</p><h4 id="抽象数据类型adt">2. 抽象数据类型（ADT）</h4><p>抽象数据类型（ADT）是纯粹理论实体，用于简化描述抽象算法，分类与评价数据结构，形式描述程序设计语言的类型系统。</p><ul><li>与存放数据的机器无关</li><li>与数据存储的物理结构无关</li><li>与实现操作的算法和编程语言均无关</li></ul><h3 id="算法及分析">算法及分析</h3><h4 id="算法的特征">1. 算法的特征</h4><ul><li>输入：有零个或若干个输入</li><li>输出：有一个或多个输出</li><li>可行性：每一个步骤能能通过基本运算实现</li><li>确定性：不会产生二义性</li><li>有穷性：算法必须有限步骤后终止</li></ul><h4 id="判断算法优劣的标准">2. 判断算法优劣的标准</h4><ul><li>正确性</li><li>可读性</li><li>鲁棒性（健壮性）</li><li>高效性</li></ul><h4 id="算法的时间复杂度oi-wiki">3. 算法的时间复杂度（<a href="https://oi-wiki.org/basic/complexity/#_4">OI-WIKI</a>）</h4><blockquote><p>衡量一个算法的快慢，一定要考虑数据规模的大小。所谓数据规模，一般指输入的数字个数、输入中给出的图的点数与边数等等。一般来说，数据规模越大，算法的用时就越长。而在算法竞赛中，我们衡量一个算法的效率时，最重要的不是看它在某个数据规模下的用时，而是看它的用时随数据规模而增长的趋势，即 <strong>时间复杂度</strong>。</p></blockquote><p>算法的运行用时并非完全由输入规模决定，而是也与输入的内容相关。所以，时间复杂度又分为几种，例如：</p><ol type="1"><li>最坏时间复杂度，即每个输入规模下用时最长的输入对应的时间复杂度。由于输入可以在给定的数据范围内任意给定，我们为保证算法能够通过某个数据范围内的任何数据，一般考虑最坏时间复杂度。</li><li>平均（期望）时间复杂度，即每个输入规模下所有可能输入对应用时的平均值的复杂度（随机输入下期望用时的复杂度）。</li></ol><h5 id="渐进符号">渐进符号</h5><p>简单来说，渐进符号忽略了一个函数中增长较慢的部分以及各项的系数（在时间复杂度相关分析中，系数一般被称作“常数”），而保留了可以用来表明该函数增长趋势的重要部分。</p><h6 id="大-θ-符号上下界">大 Θ 符号(上下界)</h6><p>对于函数 <span class="math inline">\(f(n)\)</span> 和 <span class="math inline">\(g(n)\)</span>，<span class="math inline">\(f(n)=\Theta(g(n))\)</span>，当且仅当 <span class="math inline">\(\exists c_1,c_2,n_0&gt;0\)</span>，使得 <span class="math inline">\(\forall n \ge n_0, 0\le c_1\cdot g(n)\le f(n) \le c_2\cdot g(n)\)</span>。</p><p>也就是说，如果函数 <span class="math inline">\(f(n)=\Theta(g(n))\)</span>，那么我们能找到两个正数 <span class="math inline">\(c_1, c_2\)</span> 使得 <span class="math inline">\(f(n)\)</span> 被 <span class="math inline">\(c_1\cdot g(n)\)</span> 和 <span class="math inline">\(c_2\cdot g(n)\)</span> 夹在中间。</p><p>例如，<span class="math inline">\(3n^2+5n-3=\Theta(n^2)\)</span>,<span class="math inline">\(n\sqrt n + n\log^5 n+m\log m+nm=\Theta(n\sqrt n+m\log m+nm)\)</span>。</p><h6 id="大-o-符号渐进上界">大 O 符号（渐进上界）</h6><p><span class="math inline">\(\Theta\)</span> 符号同时给了我们一个函数的上下界，如果只知道一个函数的渐进上界而不知道其渐进下界，可以使用 <span class="math inline">\(O\)</span> 符号。<span class="math inline">\(f(n)=O(g(n))\)</span>，当且仅当 <span class="math inline">\(\exists c,n_0\)</span>，使得 <span class="math inline">\(\forall n \ge n_0,0\le f(n)\le c\cdot g(n)\)</span>。</p><p>研究时间复杂度时通常会使用 <span class="math inline">\(O\)</span> 符号，因为我们关注的通常是程序用时的上界，而不关心其用时的下界。</p><p>需要注意的是，这里的“上界”和“下界”是对于函数的变化趋势而言的，而不是对算法而言的。算法用时的上界对应的是“最坏时间复杂度”而非大 <span class="math inline">\(O\)</span> 记号。所以，使用 <span class="math inline">\(\Theta\)</span> 记号表示最坏时间复杂度是完全可行的，甚至可以说 <span class="math inline">\(\Theta\)</span> 比 <span class="math inline">\(O\)</span> 更加精确，而使用 <span class="math inline">\(O\)</span> 记号的主要原因，一是我们有时只能证明时间复杂度的上界而无法证明其下界（这种情况一般出现在较为复杂的算法以及复杂度分析），二是 <span class="math inline">\(O\)</span> 在电脑上输入更方便一些。</p><h6 id="大-ω-符号渐进下界">大 Ω 符号（渐进下界）</h6><p>同样的，我们使用 <span class="math inline">\(\Omega\)</span> 符号来描述一个函数的渐进下界。<span class="math inline">\(f(n)=\Omega(g(n))\)</span>，当且仅当 <span class="math inline">\(\exists c,n_0\)</span>，使得 <span class="math inline">\(\forall n \ge n_0,0\le c\cdot g(n)\le f(n)\)</span>。</p><h6 id="小-o-符号">小 o 符号</h6><p>如果说 <span class="math inline">\(O\)</span> 符号相当于小于等于号，那么 <span class="math inline">\(o\)</span> 符号就相当于小于号。</p><p><span class="math inline">\(f(n)=o(g(n))\)</span>，当且仅当对于任意给定的正数 <span class="math inline">\(c\)</span>，<span class="math inline">\(\exists n_0\)</span>，使得 <span class="math inline">\(\forall n \ge n_0,0\le f(n)&lt; c\cdot g(n)\)</span>。</p><h6 id="小-ω-符号">小 ω 符号</h6><p>如果说 <span class="math inline">\(\Omega\)</span> 符号相当于大于等于号，那么 <span class="math inline">\(\omega\)</span> 符号就相当于大于号。</p><p><span class="math inline">\(f(n)=\omega(g(n))\)</span>，当且仅当对于任意给定的正数 <span class="math inline">\(c\)</span>，<span class="math inline">\(\exists n_0\)</span>，使得 <span class="math inline">\(\forall n \ge n_0,0\le c\cdot g(n)&lt; f(n)\)</span>。</p><h5 id="主定理-master-theorem">主定理 (Master Theorem)</h5><p>我们可以使用 Master Theorem 来快速求得关于递归算法的复杂度。 假设我们有递推关系式</p><p><span class="math display">\[ T(n) = a T\left(\frac{n}{b}\right)＋f(n)\qquad \forall n &gt; b \]</span></p><p>那么</p><p><span class="math display">\[ T(n) = \begin{cases}\Theta(n^{\log_b a}) &amp; f(n) = O(n^{\log_b a-\epsilon}) \\ \Theta(f(n)) &amp; f(n) = \Omega(n^{\log_b a+\epsilon}) \ \\Theta(n^{\log_b a}\log^{k+1} n) &amp; f(n)=\Theta(n^{\log_b a}\log^k n),k\ge 0 \end{cases} \]</span></p><h2 id="线性表">线性表</h2><p><a href="https://lapras.xyz/2021/03/28/c335c6ca.html">从零开始的数据结构-线性结构</a></p><h2 id="数组和字符串coming-soon">数组和字符串(coming soon)</h2><h2 id="树和二叉树">树和二叉树</h2><p><a href="https://lapras.xyz/2021/03/28/389e8dec.html">从零开始的数据结构-树（上）</a></p><p><a href="https://lapras.xyz/2021/04/01/8022ea89.html">从零开始的数据结构-树（下）</a></p><h2 id="搜索">搜索</h2><p><a href="https://lapras.xyz/2021/04/07/170718db.html">从零开始的数据结构-堆</a></p><p><a href="https://lapras.xyz/2021/10/24/db7ea760.html">搜索算法小整理（上）</a></p><h2 id="散列表coming-soon">散列表(coming soon)</h2><h2 id="图coming-soon">图(coming soon)</h2><h2 id="排序coming-soon">排序(coming soon)</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;好好好，cxg又让我水了一篇博客。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211203005405.gif&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="http://lapras.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="http://lapras.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="http://lapras.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>微软三件套安装以及配置</title>
    <link href="http://lapras.xyz/2021/10/26/f77b55e6.html"/>
    <id>http://lapras.xyz/2021/10/26/f77b55e6.html</id>
    <published>2021-10-26T09:27:59.000Z</published>
    <updated>2021-10-27T08:56:33.410Z</updated>
    
    <content type="html"><![CDATA[<h3 id="section"><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211026174036.jpg" alt="cxdxhh2f9r071" style="zoom:50%;" / loading="lazy"></h3><span id="more"></span><h2 id="windows-terminal">Windows Terminal</h2><blockquote><p>Windows 终端是一个面向命令行工具和 shell（如命令提示符（cmd）、PowerShell 和适用于 Linux 的 Windows 子系统 (WSL)）用户的新式终端应用程序。 它的主要功能包括多个选项卡、窗格、Unicode 和 UTF-8 字符支持、GPU 加速文本呈现引擎，你还可用它来创建你自己的主题并自定义文本、颜色、背景和快捷方式。</p></blockquote><del>好看才是第一生产力，所以别在用cmd的黑框还有powershell的蓝框了</del><h3 id="安装">安装</h3><p>方法一 <a href="https://aka.ms/terminal">微软商店</a>（推荐方式）</p><p>方法二 Windows Terminal 的 <a href="https://github.com/microsoft/terminal/releases">Github Releases</a> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211026175219.png" alt="image-20211026175219873" style="zoom:67%;" / loading="lazy"></p><ul><li>选择完版本（preview是预览版），选择后缀为<code>.msixbundle</code>的文件下载安装即可</li></ul><p>方法三 winget</p><p>首先你得微软商店（搜索应用安装程序）通过<a href="https://github.com/microsoft/winget-cli/releases">Github Releases</a> 安装winget，然后打开你的powershell 输入</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell">winget install <span class="token operator">--</span>id=Microsoft<span class="token punctuation">.</span>WindowsTerminal <span class="token operator">-</span>e<span class="token comment">#安装成功后查看版本</span>winget <span class="token operator">-</span>v</code></pre><ul><li><p>如果提示没有这个命令，考虑重启终端或者重启电脑</p></li><li><p>推荐安装一下，因为后续的 powershell7 配置（美化）还会用到这个东西</p></li></ul><p>安装成功之后</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211026180656.png" alt="image-20211026180655833" style="zoom: 50%;" / loading="lazy"></p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211026180900.png" alt="image-20211026180900388" style="zoom: 50%;" / loading="lazy"></p><p>你会发现你的界面和我的不大一样，问题不大，下面开始配置</p><h3 id="配置">配置</h3><p>选择<strong>设置</strong>可以进行一些基础功能的设置，比较明了，不作介绍。所有的配置项都在<code>setting.json</code>（点击设置后，选择打开JSON文件）中保存。</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211026184621.png" alt="image-20211026184621095" / loading="lazy"><figcaption aria-hidden="true">image-20211026184621095</figcaption></figure><ul><li>最外层都是一些全局设置，具体的配置选项可以去<a href="https://docs.microsoft.com/zh-cn/windows/terminal/json-fragment-extensions">微软文档</a>中看</li><li><code>defaultProfile</code>：值是一个UUID，也就是<code>profiles</code>的<code>guid</code></li><li><code>keybindings</code>：自定义一些快捷键</li><li><code>profiles</code>的默认选项是对所有配置文件生效的<ul><li><code>acrylicOpacity</code>：亚克力面板效果</li><li><code>fontFace</code>：选择安装含有PL（powerline）且等宽（Mono）的字体（推荐https://www.nerdfonts.com/font-downloads）</li><li><code>list</code>：含有众多配置的单独设置，如果你自己新建的话，注意<code>guid</code>别自己写。然后如果配置要连接你的服务器<code>commandline</code>就可以写成ssh之类的</li></ul></li><li><code>schemes</code>：配色方案</li></ul><h2 id="powershell-7">PowerShell 7</h2><blockquote><p>Windows PowerShell 5.1 是在 .NET Framework v4.5 基础上构建的。 随着 PowerShell 6.0 的发布，PowerShell 成为基于 .NET Core 2.0 构建的开源项目。 PowerShell 7.0 是在 .NET Core 3.1 基础上构建的。 随着 PowerShell 7.2 的发布，将在 .NET 6.0 基础上构建 PowerShell。 从 .NET Framework 转换到 .Net Core 使 PowerShell 成为可跨平台的解决方案。 PowerShell 在 Windows、macOS 和 Linux 上运行。</p></blockquote><h3 id="安装-1">安装</h3><p>方法一 微软商店<del>连Powershell都上了VSCode呢？</del></p><p>方法二 PowerShell的<a href="https://github.com/PowerShell/PowerShell/releases/">Github Releases</a> windows选择<code>.msi</code>后缀即可</p><p>方法三 winget</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell">winget install <span class="token operator">--</span>name PowerShell <span class="token operator">--</span>exact <span class="token operator">--</span>source winget</code></pre><h3 id="配置-1">配置</h3><p>首先是要让之前安装的 windows terminal 默认开启 powershell 7 而不是原装的 windows powershell</p><p>打开之前的<code>Profile</code>在如下位置添加<code>commandline</code></p><pre class="language-json" data-language="json"><code class="language-json"><span class="token property">"profiles"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"defaults"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"commandline"</span><span class="token operator">:</span> <span class="token string">"pwsh.exe"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span></code></pre><h4 id="安装gsudo">安装gsudo</h4><p>在命令行中提供管理员权限，而无需另起管理员powershell</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell">winget install <span class="token operator">--</span>name gsudo <span class="token operator">--</span>source winget<span class="token comment">#安装成功后查看版本</span>sudo <span class="token operator">-</span>v<span class="token comment">#使用</span>sudo yourcommand</code></pre><ul><li>后续的命令中有一些需要管理员权限</li></ul><h4 id="安装oh-my-posh-3">安装Oh-My-Posh 3</h4><p>有的人应该知道oh-my-zsh，都是懒癌福音，一键解锁终端主题。</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">Install-Module</span> oh-my-posh <span class="token operator">-</span>Scope AllUsers</code></pre><p>安装中基本一直y即可</p><p>安装完成之后，可以查看现有的主题，然后选择一个更换。</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#查看主题</span><span class="token function">Get-PoshThemes</span><span class="token comment">#设置主题</span><span class="token function">Set-PoshPrompt</span> <span class="token operator">-</span>Theme ThemeName</code></pre><ul><li>如果你发现主题中有大量方框乱码，请回到上文考虑修改默认字体</li></ul><p>当然如果你想要自定义主题的话可以导出主题配置文件，然后修改其json文件再重新设置</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#导出主题</span><span class="token function">Export-PoshTheme</span> <span class="token operator">-</span>FilePath ~<span class="token operator">/</span><span class="token punctuation">.</span>mytheme<span class="token punctuation">.</span>omp<span class="token punctuation">.</span>json<span class="token comment">#设置主题</span><span class="token function">Set-PoshPrompt</span> <span class="token operator">-</span>Theme ~<span class="token operator">/</span><span class="token punctuation">.</span>mytheme<span class="token punctuation">.</span>omp<span class="token punctuation">.</span>json</code></pre><p>但是你会发现重启终端之后就失效了，这是为什么嘞？，其实是要修改 PowerShell 自身的配置文件（类似于.zshrc或者.bashrc）。</p><h4 id="安装psreadline">安装PSReadLine</h4><p>PSReadLine会根据你的历史记录来进行预测和补全命令</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">Install-Module</span> PSReadLine <span class="token operator">-</span>Scope AllUsers</code></pre><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 显示所有可以配置的选项</span><span class="token function">Get-PSReadLineOption</span>  <span class="token comment"># 显示所有可以配置的快捷键</span><span class="token function">Get-PSReadLineKeyHandler</span>  </code></pre><h4 id="配置profile">配置Profile</h4><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">Test-Path</span> <span class="token operator">-</span>Path <span class="token variable">$PROFILE</span><span class="token punctuation">.</span>AllUsersCurrentHost<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">New-Item</span> <span class="token operator">-</span>ItemType File <span class="token operator">-</span>Path <span class="token variable">$PROFILE</span><span class="token punctuation">.</span>AllUsersCurrentHost <span class="token operator">-</span>Force<span class="token punctuation">&#125;</span></code></pre><ul><li>一个简单的脚本判断你是否已经创建了配置文件</li></ul><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#使用vscode编辑</span>code <span class="token variable">$Profile</span> <span class="token comment">#使用记事本编辑 （呜呜呜别再用记事本了）</span>notepad <span class="token variable">$Profile</span></code></pre><p>在<code>$Profile</code>中添加：</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 设置 oh-my-posh</span><span class="token function">Import-Module</span> oh-my-posh<span class="token comment"># 设置 ps-read-line</span><span class="token function">Import-Module</span> PSReadLine<span class="token comment"># 设置主题</span><span class="token function">Set-PoshPrompt</span> paradox<span class="token comment"># 设置预测文本来源为历史记录</span><span class="token function">Set-PSReadLineOption</span> <span class="token operator">-</span>PredictionSource History<span class="token comment"># 每次回溯输入历史，光标定位于输入内容末尾</span><span class="token function">Set-PSReadLineOption</span> <span class="token operator">-</span>HistorySearchCursorMovesToEnd<span class="token comment"># 设置 Tab 为菜单补全和 Intellisense</span><span class="token function">Set-PSReadLineKeyHandler</span> <span class="token operator">-</span>Key <span class="token string">"Tab"</span> <span class="token operator">-</span><span class="token keyword">Function</span> MenuComplete<span class="token comment"># 设置向上键为后向搜索历史记录</span><span class="token function">Set-PSReadLineKeyHandler</span> <span class="token operator">-</span>Key UpArrow <span class="token operator">-</span><span class="token keyword">Function</span> HistorySearchBackward<span class="token comment"># 设置向下键为前向搜索历史纪录</span><span class="token function">Set-PSReadLineKeyHandler</span> <span class="token operator">-</span>Key DownArrow <span class="token operator">-</span><span class="token keyword">Function</span> HistorySearchForward</code></pre><p>最后重启终端即可！</p><h2 id="wsl">WSL</h2><blockquote><p>适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。</p><p>您可以：</p><ul><li><a href="https://aka.ms/wslstore">在 Microsoft Store</a> 中选择你偏好的 GNU/Linux 分发版。</li><li>运行常用的命令行软件工具（例如 <code>grep</code>、<code>sed</code>、<code>awk</code>）或其他 ELF-64 二进制文件。</li><li>运行 Bash shell 脚本和 GNU/Linux 命令行应用程序，包括：</li><li>工具：vim、emacs、tmux</li><li>语言：<a href="https://docs.microsoft.com/zh-cn/windows/nodejs/setup-on-wsl2">NodeJS</a>、Javascript、<a href="https://docs.microsoft.com/zh-cn/windows/python/web-frameworks">Python</a>、Ruby、C/ C++、C# 与 F#、Rust、Go 等。</li><li>服务：SSHD、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">MySQL</a>、Apache、lighttpd、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">MongoDB</a>、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">PostgreSQL</a>。</li><li>使用自己的 GNU/Linux 分发包管理器安装其他软件。</li><li>使用类似于 Unix 的命令行 shell 调用 Windows 应用程序。</li><li>在 Windows 上调用 GNU/Linux 应用程序。</li><li>现已支持CUDA！一起来炼丹吧！</li></ul></blockquote><h3 id="安装-2">安装</h3><pre class="language-powershell" data-language="powershell"><code class="language-powershell">wsl <span class="token operator">--</span>install</code></pre><ul><li>此命令将启用所需的可选组件，下载最新的 Linux 内核，将 WSL 2 设置为默认值，并默认安装 Ubuntu</li><li>而后会新建用户并设置密码</li></ul><p>然后重启电脑。在终端就看见一个新的选项卡</p><p>而后的Linux配置可以参考组内另一名讲师（莫非）的<a href="https://closed-linen-ea9.notion.site/Ubuntu-cb4d33bdbcc2400b9b04cc56ba21d080">虚拟机安装Ubuntu教程</a></p><h2 id="参考">参考</h2><p><a href="https://docs.microsoft.com/en-us/">微软官方文档</a></p><p><a href="https://zhuanlan.zhihu.com/p/137595941">Windows Terminal 完美配置 PowerShell 7.1</a></p><p><a href="https://zhuanlan.zhihu.com/p/351281543">Window Terminal 安装以及使用</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;section&quot;&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211026174036.jpg&quot; alt=&quot;cxdxhh2f9r071&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/h3&gt;</summary>
    
    
    
    
    <category term="工具" scheme="http://lapras.xyz/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="分享" scheme="http://lapras.xyz/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>搜索算法小整理（上）</title>
    <link href="http://lapras.xyz/2021/10/24/db7ea760.html"/>
    <id>http://lapras.xyz/2021/10/24/db7ea760.html</id>
    <published>2021-10-24T06:19:22.000Z</published>
    <updated>2021-10-25T09:29:21.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>10月24日，程序猿节？昨天招新结束，做了一下午牢还行。。。刚好cxg讲到搜索了，写个水博客摸摸鱼。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024174654.jpg" alt="93565599_p0" style="zoom: 50%;" / loading="lazy"></p><span id="more"></span><h2 id="一些概念">一些概念</h2><p><strong>平均搜索长度</strong>（<span class="math inline">\(ASL\)</span>）：确定一个键值在表中的位置，需要进行若干次比较，比较次数的期望值就是所谓的<span class="math inline">\(ASL\)</span></p><p><strong>搜索成功的平均长度</strong>（<span class="math inline">\(ASL_s\)</span>）：字面意思</p><p><strong>搜索失败的平均长度</strong>（<span class="math inline">\(ASL_f\)</span>）：字面意思</p><h2 id="顺序查找暴力">顺序查找（暴力）</h2><h3 id="思路">思路</h3><del>暴力要什么思路？</del><p>将线性表从头至尾遍历一次。</p><h3 id="代码">代码</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">SeqSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>      <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><p><span class="math inline">\(O(N)\)</span></p></li><li><p><span class="math inline">\(ASL_s\)</span>：<span class="math inline">\(\frac{1}{n}\sum^{n}_{i=1}i=\frac{(n+1)}{2}\)</span></p></li><li><p><span class="math inline">\(ASL_f\)</span>：<span class="math inline">\(\frac{1}{n+1}\sum^{n+1}_{i=1}i=1+\frac{n}{2}\)</span></p><ul><li>可以理解为成功版本的插空，如果程序中使用<span class="math inline">\(inf\)</span>哨兵判断遍历到数组末尾，则还需再加1</li></ul></li></ul><h2 id="二分查找binarysearch">二分查找（BinarySearch）</h2><h3 id="思路-1">思路</h3><p>经典二分法，给定一个<strong>有序</strong>的线性表，校验其中间值，然后分成左右两个线性表，继续递归地寻找答案</p><h3 id="代码-1">代码</h3><h4 id="递归版">递归版</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binSearch_rec</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> r<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>    <span class="token keyword">return</span> mid<span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">binSearch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token function">binSearch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="循环版">循环版</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binSearch_loop</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>      <span class="token keyword">return</span> mid<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>      l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>      r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="极简板">极简板</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span>      r <span class="token operator">=</span> mid<span class="token punctuation">;</span> <span class="token comment">// check()判断mid是否满足性质</span>    <span class="token keyword">else</span>      l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><span class="math inline">\(O(log_2N)\)</span></li><li><code>int mid = l + (r - l) / 2;</code>是防止数据溢出</li><li>极简版本只适用于确定答案在数组中的题目</li></ul><h3 id="二叉搜索树">二叉搜索树</h3><p>(具体见<a href="https://lapras.xyz/2021/04/01/8022ea89.html">从零开始的数据结构-树</a>)</p><p>也称为 二叉查找树 、二分搜索树 、有序二叉树或排序二叉树。</p><p>满足以下几个条件：</p><ul><li>若它的左子树不为空，左子树上所有节点的值都小于它的根节点。</li><li>若它的右子树不为空，右子树上所有的节点的值都大于它的根节点。</li></ul><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024203611.png" alt="image-20211024203611557" / loading="lazy"><figcaption aria-hidden="true">image-20211024203611557</figcaption></figure><p>显然地，如果我们对这颗树进行中序遍历，就会得到一个有序的线性表。那么反之，我们之前的二分查找的过程，也可以用这颗树来表示。</p><ul><li>每一个根节点都是中点(偶数个为左)</li><li>左子数为左边的线性子表，右子树为右边的线性子表</li></ul><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024204318.gif" alt="GIF 2021-10-24 20-42-50" / loading="lazy"><figcaption aria-hidden="true">GIF 2021-10-24 20-42-50</figcaption></figure><p>来计算一下<span class="math inline">\(ASL_s\)</span>，显然地第一层只需要对比1次，第二次需要两次，以此类推<span class="math inline">\(ASL_s=(1*1+2*2+3*4+4*3)/10\)</span>。</p><p>计算<span class="math inline">\(ASL_f\)</span>我们只需要将图上的二叉搜索树的每个结点用空白结点进行补齐。那么这些空白结点就代表着失败的区间。</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024210117.png" alt="graph (7)" style="zoom:67%;" / loading="lazy"></p><p><span class="math inline">\(ASL_f=(4*4+5*6)/10\)</span></p><h2 id="插值查找interpolationsearch">插值查找（InterpolationSearch）</h2><h3 id="思路-2">思路</h3><p>插值查找的核心思想确实和翻字典差不多。毕竟没人翻字典是二分查找的吧。它和二分查找唯一的区别就在于<code>mid</code>的更新。</p><p>二分查找的<code>mid</code>只是简单地取了中点，而插值查找则有一点按照比例分配的感觉。</p><p><span class="math inline">\(mid = l+ [\frac{key - a[l]}{a[r]-a[l]}](r-l)\)</span></p><p>可以看到，原来的系数<span class="math inline">\(\frac{1}{2}\)</span>被替换为了<span class="math inline">\([\frac{key - a[l]}{a[r]-a[l]}]\)</span>，我们假定一个完全平均分配的数组<code>[1,2,3,4,5,6,7,8,9,10]</code>使用插值查找7，</p><p>则<span class="math inline">\(mid = 0+ \frac{7 - 1}{10-1}(9-0)=6\)</span>直接 <span class="math inline">\(O(1)\)</span> 获得了7的下标。但同样的，如果数组分布非常不均匀，则会退化成<span class="math inline">\(O(N)\)</span>。</p><p>比如<code>[0, 99, 100, 100, 100, 100, 100]</code>使用插值查找99，则<span class="math inline">\(mid\)</span>会依次更新为5，3，1反而比直接二分来的慢了。</p><h3 id="代码-2">代码</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binSearch_inp</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>target <span class="token operator">-</span> a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">-</span> a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>      <span class="token keyword">return</span> mid<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>      l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>      r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>期望<span class="math inline">\(O(loglogN)\)</span></li><li>最坏<span class="math inline">\(O(N)\)</span></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;10月24日，程序猿节？昨天招新结束，做了一下午牢还行。。。刚好cxg讲到搜索了，写个水博客摸摸鱼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024174654.jpg&quot; alt=&quot;93565599_p0&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="http://lapras.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="http://lapras.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="http://lapras.xyz/tags/C/"/>
    
    <category term="搜索" scheme="http://lapras.xyz/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>记frp实现内网穿透</title>
    <link href="http://lapras.xyz/2021/09/12/dae1adad.html"/>
    <id>http://lapras.xyz/2021/09/12/dae1adad.html</id>
    <published>2021-09-12T07:30:53.000Z</published>
    <updated>2021-10-24T06:21:09.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>啊，服务器配置太低，只能把服务配置在本地，但是校园网哪来的公网IP，无奈只能穿透了捏~</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210912153717.webp" alt="img" style="zoom:50%;" / loading="lazy"></p><span id="more"></span><h2 id="简介">简介</h2><p><code>frp</code> 是一个可用于内网穿透的高性能的反向代理应用，支持 <code>tcp</code>, <code>udp</code> 协议，为<code>http</code>和 <code>https</code>应用协议提供了额外的能力，且尝试性支持了点对点穿透。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p><h2 id="工具">工具</h2><blockquote><p>提供服务的客户端（我这里是Win10）</p><p>拥有公网ip的服务端（我这里是CentOS8）</p><p>一个@解析到服务端ip的域名</p><p>frp</p></blockquote><h2 id="服务端篇">服务端篇</h2><h3 id="下载">下载</h3><p><a href="https://github.com/fatedier/frp/releases">FRP 下载地址</a></p><p>选择你服务器内核对应的压缩包即可，下载完成后解压</p><h3 id="配置">配置</h3><p>可以看到软件目录一共有两个程序、四个配置文件</p><blockquote><p>frps 表示frp server</p><p>frpc 表示frp client</p><p>frps.ini是服务端配置文件</p><p>frpc.ini是客户端配置文件</p><p>frps_full.ini是服务端的配置文件模板</p><p>frpc_full.ini是客户端的配置文件模板</p></blockquote><p>配置服务端文件<code>frps.ini</code>：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>common<span class="token punctuation">]</span><span class="token comment">#监听的ip，通常为0.0.0.0，意为监听所有的地址</span>bind_addr <span class="token operator">=</span> <span class="token number">0.0</span>.0.0<span class="token comment">#与客户端绑定端口须一致</span>bind_port <span class="token operator">=</span> <span class="token number">7000</span><span class="token comment">#监听 HTTP 请求端口</span>vhost_http_port <span class="token operator">=</span> <span class="token number">5089</span><span class="token comment">#域名设置</span>subdomain_host <span class="token operator">=</span> yourdomain.com <span class="token comment">#dashboard 用户名</span>dashboard_user <span class="token operator">=</span> username<span class="token comment">#dashboard 密码</span>dashboard_pwd <span class="token operator">=</span> <span class="token function">passwd</span><span class="token comment">#dashboard 端口，启动成功后可通过浏览器访问如http://ip:23333</span>dashboard_port <span class="token operator">=</span> <span class="token number">23333</span> <span class="token comment">#设置服务端token，对应客户端也需要配置相同</span>token <span class="token operator">=</span> <span class="token number">1145141818</span>     </code></pre><h3 id="运行">运行</h3><pre class="language-bash" data-language="bash"><code class="language-bash">./frps -c ./frps.ini</code></pre><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210912160616.png" / loading="lazy"></p><ul><li>记得打开相应的防火墙以及安全组</li></ul><h3 id="设置服务">设置服务</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/systemd/system/frps.service</code></pre><p>添加以下内容：</p><pre class="language-none"><code class="language-none">[Unit]Description&#x3D;frps daemonAfter&#x3D;syslog.target  network.targetWants&#x3D;network.target [Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;frp&#x2F;frps -c &#x2F;usr&#x2F;local&#x2F;frp&#x2F;frps.iniRestart&#x3D; alwaysRestartSec&#x3D;1min [Install]WantedBy&#x3D;multi-user.target</code></pre><ul><li><code>ExecStart</code>根据frp安装目录自行更改</li></ul><p>现在就可以<code>systemctl</code>来控制frp啦</p><h2 id="客户端篇">客户端篇</h2><h3 id="下载-1">下载</h3><p><a href="https://github.com/fatedier/frp/releases">FRP 下载地址</a></p><p>选择你服务器内核对应的压缩包即可，下载完成后解压</p><h3 id="配置-1">配置</h3><p>配置客户端文件<code>frpc.ini</code>：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>common<span class="token punctuation">]</span><span class="token comment"># 服务器IP或者地址</span>server_addr <span class="token operator">=</span> address or domain<span class="token comment"># 服务器提供的端口号(需与客户端一致)</span>server_port <span class="token operator">=</span> <span class="token number">7000</span>           <span class="token comment">#设置客户端token(需与客户端一致)</span>token <span class="token operator">=</span> <span class="token number">1145141818</span><span class="token punctuation">[</span>Asoul<span class="token punctuation">]</span><span class="token builtin class-name">type</span> <span class="token operator">=</span> httplocal_ip <span class="token operator">=</span> <span class="token number">127.0</span>.0.1<span class="token comment">#内网服务放置的端口</span>local_port <span class="token operator">=</span> <span class="token number">8080</span><span class="token comment">#二级域名设置</span>subdomain <span class="token operator">=</span> <span class="token builtin class-name">test</span></code></pre><ul><li><p>这里我只配置了一个web应用的穿透，更多的比如ssh登录，远程桌面等等见参考</p></li><li><p>访问服务的方式是：<code>subdomain.domain.com:vhost_http_port</code></p></li></ul><h3 id="运行-1">运行</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">\</span>frpc.exe -c .<span class="token punctuation">\</span>frpc.ini</code></pre><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210912162600.png" alt="image-20210912162600590" / loading="lazy"><figcaption aria-hidden="true">image-20210912162600590</figcaption></figure><h3 id="设置服务-1">设置服务</h3><p>新建一个<code>vbs</code>：</p><pre class="language-vbscript" data-language="vbscript"><code class="language-vbscript">Copyset ws&#x3D;WScript.CreateObject(&quot;WScript.Shell&quot;)ws.Run &quot;&#123;yourpath&#125;\frpc.exe -c &#123;yourpath&#125;\frpc.ini&quot;,0</code></pre><p><code>win</code>+<code>R</code>运行打开<code>shell:startup</code>把该文件放进去即可嘞。</p><h2 id="window服务">Window服务</h2><p>介绍个好用的玩意儿<a href="https://github.com/kohsuke/winsw">winsw</a>，它可以将Windows上的任何一个程序注册为服务，这比<code>shell:startup</code>方便多嘞，它的使用类似于Linux平台上的<code>systemctl</code>，只不过其的配置文件是用xml格式写的</p><h3 id="下载-2">下载</h3><p>https://github.com/winsw/winsw/releases/</p><p>如果电脑有安装<code>.NET Framework 4.6.1</code>以上版本就可以选择<code>WinSW-net461.exe</code>，反之选择x64或者x86版本</p><h3 id="配置-2">配置</h3><ol type="1"><li>将下载好的exe文件改个名字<code>winsw.exe</code></li><li>新建一个<code>winsw</code>目录，移动<code>winsw.exe</code>并将其添加进系统环境变量中</li><li>在该目录下新建一个<code>frp.xml</code>文件</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 该服务的唯一标识 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>frp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 该服务的名称 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>frpc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 该服务的描述 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>frpc客户端 这个服务用 frpc 实现内网穿透<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 要运行的程序路径 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executable</span><span class="token punctuation">></span></span>&#123;yourpath&#125;\frpc.exe<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executable</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 携带的参数 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arguments</span><span class="token punctuation">></span></span>-c &#123;yourpath&#125;\frpc.ini<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>arguments</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 第一次启动失败 60秒重启 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onfailure</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>restart<span class="token punctuation">"</span></span> <span class="token attr-name">delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>60 sec<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token comment">&lt;!-- 日志模式 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logmode</span><span class="token punctuation">></span></span>append<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>logmode</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 指定日志文件目录(相对于executable配置的路径) --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logpath</span><span class="token punctuation">></span></span>frplogs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>logpath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>service</span><span class="token punctuation">></span></span></code></pre><ol start="4" type="1"><li>安装服务</li></ol><pre class="language-powershell" data-language="powershell"><code class="language-powershell">winsw install <span class="token punctuation">&#123;</span>yourpath<span class="token punctuation">&#125;</span>\winsw\frp<span class="token punctuation">.</span>xml</code></pre><ol start="5" type="1"><li>启动服务</li></ol><pre class="language-powershell" data-language="powershell"><code class="language-powershell">winsw <span class="token function">start</span> <span class="token punctuation">&#123;</span>yourpath<span class="token punctuation">&#125;</span>\winsw\frp<span class="token punctuation">.</span>xml</code></pre><pre class="language-none"><code class="language-none">&#x2F;&#x2F;全部命令：&#x2F;&#x2F;注册服务winsw.exe install xxx&#x2F;&#x2F;卸载服务winsw.exe uninstall xxx&#x2F;&#x2F;启动服务winsw.exe start xxx&#x2F;&#x2F;停止服务winsw.exe stop xxx&#x2F;&#x2F;重启服务winsw.exe restart xxx&#x2F;&#x2F;查看状态winsw.exe status xxx</code></pre><h2 id="参考">参考</h2><p>http://kan.lol/posts/c067e7e3/</p><p>https://blog.csdn.net/nextyu/article/details/78284663</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;啊，服务器配置太低，只能把服务配置在本地，但是校园网哪来的公网IP，无奈只能穿透了捏~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210912153717.webp&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="项目经历" scheme="http://lapras.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="分享" scheme="http://lapras.xyz/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="网络" scheme="http://lapras.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>记录在linux上的武当梯云纵</title>
    <link href="http://lapras.xyz/2021/08/24/a04e8961.html"/>
    <id>http://lapras.xyz/2021/08/24/a04e8961.html</id>
    <published>2021-08-24T08:43:49.000Z</published>
    <updated>2021-09-03T03:43:09.074Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>手机和PC上都是直接V2ray+机场直接走了，一直没认真配过，没想到一搞就是一天……</p><p>买的腾讯云学生机git速度感人 –&gt; V2ray客户端 –&gt; git V2速度感人 –&gt; ……-&gt; 白嫖Azure大失败 –&gt; ……–&gt;trojan真好用</p><span id="more"></span><h3 id="工具">工具</h3><blockquote><p>一台ip在国外的VPS（我用的<a href="https://my.vultr.com/">vultr</a>，支持小时计费还有支付宝，一个人用最便宜的都绰绰有余）</p><p>一台ip在国内想要学武当梯云纵的VPS</p><p>一个能正常使用的终端（Windows Terminal好用的很）</p><p>一个闲置的域名（最好别备案，国内国外皆可）</p><p>DNS服务商（免费的<a href="https://www.cloudflare.com/zh-cn/">cloudflare</a>，当然你顺手在国内解析也行，不过大概率会被叫去实名）</p></blockquote><h3 id="服务端篇">服务端篇</h3><h4 id="购买篇">购买篇</h4><p>因为只买过vultr，所以只聊聊vultr的购买选项</p><p><strong>地区</strong></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210824195804.png" alt="image-20210824195804260" / loading="lazy"><figcaption aria-hidden="true">image-20210824195804260</figcaption></figure><ul><li>有些地区会有2.5刀的only ipv6 版（考虑到目前中国的ipv6发展水平，最好别选），有些地区有3.5刀的青春版</li></ul><p><strong>镜像</strong></p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210824200139.png" alt="image-20210824200139053" / loading="lazy"><figcaption aria-hidden="true">image-20210824200139053</figcaption></figure><ul><li>一般来说就选 CentOS和Ubuntu/Debian 即可（别的我也没怎么用过）</li></ul><p><strong>可选项（）</strong></p><ul><li>Enable IPv6：分配个IPv6的地址给你</li><li>Enable Auto Backups：增值服务，自动备份。</li><li>Enable DDOS Protection：增值服务，防范DDOS攻击。</li><li>Enable Private Networking：分配个内网IP给你</li></ul><p>总结：如果只是为了上武当学艺，这四个都可以不用</p><p>然后是<strong>Startup Script</strong>和 <strong>SSH Keys</strong>。我选择朴实无华的自己ssh，故也不填</p><p>最后<strong>Server Hostname</strong>随便填个名儿就行</p><p>返回主页，就可以看见自己的服务器正在加载，加载成功之后记住他的IP和root密码就行，vultr默认没有防火墙，要是设置过防火墙记得打开80（ssh）和443（代理）端口</p><h4 id="域名解析篇">域名解析篇</h4><p>我们需要有一个域名作为伪装域名</p><p><strong>国内</strong></p><p>我们随便买完域名之后，如果是在腾讯云（阿里云）阿里云买的，则去其对应的后台</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210824201801.png" alt="image-20210824201801267" / loading="lazy"><figcaption aria-hidden="true">image-20210824201801267</figcaption></figure><p>然后填写自己的服务端IP即可</p><p><strong>国外</strong></p><p>在成功注册cloudflare之后会让你填写解析记录，如图所示填写即可，内容是服务端的IP，注意代理状态一定要选仅限DNS</p><figure><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210824202529.png" alt="image-20210824202529566" / loading="lazy"><figcaption aria-hidden="true">image-20210824202529566</figcaption></figure><p>弄好之后可以在https://dns.tech/l检验一下基本就没有问题li</p><h4 id="上机篇">上机篇</h4><p>随便打开个终端用ssh连接你的服务器</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> root@<span class="token string">'your IP or Domain'</span></code></pre><p>如果是初次登录，会提示在本地生成ssh key，yes即可</p><p>然后输入密码，成功进入服务器</p><p>安装前置软件 curl</p><p>Debian/Ubuntu：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> -y <span class="token function">curl</span></code></pre><p>CentOS：</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> -y <span class="token function">curl</span></code></pre><p>然后执行一键安装脚本</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">bash</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">curl</span> -sL https://s.hijk.art/trojan.sh<span class="token punctuation">)</span></code></pre><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210824204000.png" alt="image-20210824204000807" style="zoom:67%;" / loading="lazy"></p><ul><li>trojan端口：443貌似是最快的，但是最近好像有些不稳定，一堆人被封掉了</li><li>伪装站：是真的能上2333</li><li>允许搜索引擎or爬取网站：建议选择允许，耗不了几个流量，但是能给你的网站带来多元的正常流量，大大的良民</li><li>然后就一路enter即可</li></ul><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210824204510.png" alt="image-20210824204510388" style="zoom:67%;" / loading="lazy"></p><p>可喜可贺！记住下面四行信息即可。</p><h3 id="客户端篇">客户端篇</h3><h4 id="安装篇">安装篇</h4><p>官方客户端过于“简约”，windows客户端建议使用V2rayN或者Clash for Windows，mac客户端建议使用ClashX，安卓客户端建议使用V2rayNG。</p><p>欧可，重点是linux客户端上的配置，因为连接github太慢了，只能放弃舒服的一键脚本（我要是能一键脚本，我还配个der）</p><p>自行找个镜像站下载</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/src <span class="token operator">&amp;&amp;</span> <span class="token function">wget</span> https://d2.netfiles.pw/trojan/trojan-1.16.0-linux-amd64.tar.xz</code></pre><p>解压</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> xvf trojan-1.16.0-linux-amd64.tar.xz</code></pre><p>修改配置文件</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/src/trojan<span class="token function">vim</span> config.json</code></pre><p>其配置文件很多，但我们只需要关注如下几个</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token string">"run_type"</span><span class="token builtin class-name">:</span> <span class="token string">"client"</span>,<span class="token string">"local_addr"</span><span class="token builtin class-name">:</span> <span class="token string">"127.0.0.1"</span>,//0.0.0.0也可<span class="token string">"local_port"</span><span class="token builtin class-name">:</span> <span class="token number">1080</span>,//0~65535 挑个不会被占用的即可<span class="token string">"remote_addr"</span><span class="token builtin class-name">:</span> <span class="token string">"xxx.xxx"</span>,//您的域名<span class="token string">"remote_port"</span><span class="token builtin class-name">:</span> <span class="token number">443</span>,//国外服务器trojan的端口<span class="token string">"password"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"xxxxxxxxxxx"</span><span class="token punctuation">]</span>,//密码 可以有多个</code></pre><ul><li>[FATAL] fatal: load_verify_file: No such file or director，这时ssl中的verify和verify_hostname需要设置成false，好像是证书的问题，选择一种懒人危险法</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token string">"verify"</span><span class="token builtin class-name">:</span> false,<span class="token string">"verify_hostname"</span><span class="token builtin class-name">:</span> false,<span class="token string">"cert"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,</code></pre><p>接着配置trojan service</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/systemd/system/trojan.service</code></pre><p>复制如下代码进去</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span><span class="token assign-left variable">Description</span><span class="token operator">=</span>trojan<span class="token assign-left variable">After</span><span class="token operator">=</span>network.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span><span class="token assign-left variable">Type</span><span class="token operator">=</span>simple<span class="token assign-left variable">PIDFile</span><span class="token operator">=</span>/usr/src/trojan/trojan.pid<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/src/trojan/trojan -c /usr/src/trojan/config.json -l /usr/src/trojan/trojan.log<span class="token assign-left variable">ExecReload</span><span class="token operator">=</span>/bin/kill -HUP <span class="token punctuation">\</span><span class="token variable">$MAINPID</span><span class="token assign-left variable">Restart</span><span class="token operator">=</span>on-failure<span class="token assign-left variable">RestartSec</span><span class="token operator">=</span>1s<span class="token punctuation">[</span>Install<span class="token punctuation">]</span><span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>multi-user.target</code></pre><p>这样之后就可以用<code>systemctl start trojan</code>来启动trojan了，除此之外</p><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl restart trojan 重启trojansystemctl stop trojan 停止trojansystemctl status trojan 查看当前trojan状态systemctl status trojan -l查看当前trojan完整状态systemctl <span class="token builtin class-name">enable</span> trojan设置开机启动<span class="token function">cat</span> /usr/src/trojan/server.conf 查看trojan配置<span class="token function">cat</span> /usr/src/trojan/trojan.log 查看trojan日志</code></pre><p>输入<code>curl cip.cc --socks5 127.0.0.1:&#123;you_local_port&#125;</code>检测结果</p><h4 id="其他小技巧">其他小技巧</h4><p>linux下代理一般是通过<code>http_proxy</code>和<code>https_proxy</code>这两个环境变量，但是很多软件并不使用这两个变量，导致流量无法走代理（这又是另一个悲伤的故事了）。 而且直接更改这两个环境变量总是会导致某些奇奇怪怪的错误产生。所以在不使用vpn的前提下，linux并没有转发所有流量的真全局代理。但是可以用<strong>proxychains-ng</strong>为程序指定走代理，从而变相达到全局代理。</p><p><strong>安装</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/rofl0r/proxychains-ng<span class="token builtin class-name">cd</span> proxychains-ng./configure --prefix<span class="token operator">=</span>/usr --sysconfdir<span class="token operator">=</span>/etc<span class="token function">make</span> <span class="token function">make</span> <span class="token function">install</span><span class="token function">make</span> install-config<span class="token builtin class-name">cd</span> <span class="token punctuation">..</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -rf proxychains-ng</code></pre><p><strong>配置</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/proxychains.conf<span class="token comment">#socks4         127.0.0.1 9050 </span>socks5 <span class="token number">127.0</span>.0.1 <span class="token punctuation">&#123;</span>you_local_port<span class="token punctuation">&#125;</span></code></pre><p>注释或删除掉最后一行的默认配置，然后添加你的代理端口，现在你只需要在程序前面加上<code>proxychains4</code>就可以走代理执行命令。</p><p>比如<code>proxychains4 curl cip.cc</code></p><p><strong>别名</strong></p><p><code>proxychains4</code>也太长了吧。所以给它取个别名把</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#bash</span><span class="token function">vim</span> ~/.bashrc<span class="token comment">#zsh</span><span class="token function">vim</span> ~/.zshrc</code></pre><p>在末尾追加</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">pxy</span><span class="token operator">=</span>proxychains4</code></pre><p>然后退出</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#bash</span><span class="token builtin class-name">source</span> ~/.bashrc<span class="token comment">#zsh</span><span class="token builtin class-name">source</span> ~/.zshrc</code></pre><h3 id="回到心心念念的v2ray">回到心心念念的v2ray</h3><p>虽说trojan确实配置简单，但也是相对我的服务器一开始无法走代理而言的。既然现在可以走代理了，那么不如再来安装一次V2ray！</p><h4 id="v2ray-core">v2ray-core</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">bash</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">curl</span> -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh<span class="token punctuation">)</span></code></pre><p>官网的一键安装只需要用到这个脚本，无奈在没有代理的情况下，笑死，根本没有<span class="math inline">\(SPEED\)</span>​。</p><p>然后我看了一眼脚本内容，但其实这个脚本有参数可以<strong>选择使用代理下载</strong>。</p><pre class="language-bash" data-language="bash"><code class="language-bash">-p, --proxy     <span class="token comment">#Download through a proxy server, e.g., -p http://127.0.0.1:8118 or -p socks5://127.0.0.1:1080'</span></code></pre><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pxy <span class="token function">wget</span> https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh<span class="token function">sudo</span> <span class="token function">bash</span> install-release.sh -p socks5://127.0.0.1:<span class="token punctuation">&#123;</span>you_local_port<span class="token punctuation">&#125;</span></code></pre><p>不出意外的话应该就成功地安装完成了，而且官方脚本不需要我们自己写<code>systemd</code>配置，然后把<code>trojan</code>关一下。先不用管v2ray的服务。</p><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl stop trojanststemctl disable trojan</code></pre><h4 id="v2raya">v2raya</h4><p><code>v2raya</code>在web端提供了GUI，省去了切换节点修改配置文件的麻烦。能像其他客户端一样一键订阅可太方便了。</p><p>Ubuntu(Debian)</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> -qO - https://apt.v2raya.mzz.pub/key/public-key.asc <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -<span class="token builtin class-name">echo</span> <span class="token string">"deb https://apt.v2raya.mzz.pub/ v2raya main"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/apt/sources.list.d/v2raya.list<span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> v2raya</code></pre><p>CentOS</p><p>在https://github.com/v2rayA/v2rayA/releases下载对应的rpm包</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://github.com/v2rayA/v2rayA/releases/download/v1.5.1/installer_redhat_x64_v1.5.1.rpm<span class="token function">sudo</span> y -i installer_redhat_x64_v1.5.1.rpm</code></pre><p><strong>配置</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#打开2017端口</span>firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span><span class="token number">2017</span> --permanent<span class="token comment"># 启动 v2raya</span>systemctl start v2raya<span class="token comment"># 开机自启 v2raya</span>systemctl <span class="token builtin class-name">enable</span> v2raya</code></pre><p>然后可以访问<code>http://localhost:2017/</code>或者<code>http://&#123;your_vps_IP&#125;:2017/</code>进行配置</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210827185428.png" alt="image-20210827185428715" style="zoom: 50%;" / loading="lazy"></p><p>然后就可以通过导入订阅连接或者Vmess的方式（同其他端的操作一致）</p><p>最后是设置，将socks5端口改成之前的{your_local_port}这样就可以继续使用pxy进行全局代理</p><p><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20210827185616.png" alt="image-20210827185616188" style="zoom:50%;" / loading="lazy"></p><h3 id="参考">参考</h3><p><a href="https://v2raytech.com/trojan-one-click-scrip/">trojan一键脚本</a></p><p><a href="https://www.cnblogs.com/BOHB-yunying/articles/12205099.html">Centos 7安装Proxychains实现Linux 代理</a></p><p><a href="https://p4gefau1t.github.io/trojan-go/basic/full-config/">Trojan-Go Docs</a></p><p><a href="https://github.com/v2rayA/v2rayA">v2rayA</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;手机和PC上都是直接V2ray+机场直接走了，一直没认真配过，没想到一搞就是一天……&lt;/p&gt;
&lt;p&gt;买的腾讯云学生机git速度感人 –&amp;gt; V2ray客户端 –&amp;gt; git V2速度感人 –&amp;gt; ……-&amp;gt; 白嫖Azure大失败 –&amp;gt; ……–&amp;gt;trojan真好用&lt;/p&gt;</summary>
    
    
    
    <category term="项目经历" scheme="http://lapras.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="分享" scheme="http://lapras.xyz/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="网络" scheme="http://lapras.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
