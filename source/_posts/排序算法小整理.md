---
title: 搜索算法小整理（上）
tags:
  - 算法
  - 搜索
  - C++
katex: true
categories: 算法学习
abbrlink: db7ea760
date: 2021-10-24 14:19:22
---

## 前言

10月24日，程序猿节？昨天招新结束，做了一下午牢还行。。。刚好cxg讲到搜索了，写个水博客摸摸鱼。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024174654.jpg" alt="93565599_p0" style="zoom: 50%;" />

<!--more-->

## 一些概念

**平均搜索长度**（$ASL$）：确定一个键值在表中的位置，需要进行若干次比较，比较次数的期望值就是所谓的$ASL$

**搜索成功的平均长度**（$ASL_s$）：字面意思

**搜索失败的平均长度**（$ASL_f$）：字面意思

## 顺序查找（暴力）

### 思路

<del>暴力要什么思路？</del>将线性表从头至尾遍历一次。

### 代码

```cpp
int SeqSearch(int a[], int length, int target)
{
  for (int i = 0; i < length; i++)
    if (a[i] == target)
      return i;
  return -1;
}
```

+ $O(N)$

+ $ASL_s$：$\frac{1}{n}\sum^{n}_{i=1}i=\frac{(n+1)}{2}$

+ $ASL_f$：$\frac{1}{n+1}\sum^{n+1}_{i=1}i=1+\frac{n}{2}$
  + 可以理解为成功版本的插空，如果程序中使用$inf$哨兵判断遍历到数组末尾，则还需再加1

## 二分查找（BinarySearch）

### 思路

经典二分法，给定一个**有序**的线性表，校验其中间值，然后分成左右两个线性表，继续递归地寻找答案

### 代码

#### 递归版

```cpp
int binSearch_rec(int a[], int l, int r, int target)
{
  if (l > r)
    return -1;
  int mid = l + (r - l) / 2;
  if (a[mid] == target)
    return mid;
  else if (a[mid] > target)
    return binSearch(a, l, mid - 1, target);
  else
    return binSearch(a, mid + 1, r, target);
}
```

#### 循环版

```cpp
int binSearch_loop(int a[], int length, int target)
{
  int l = 0, r = length - 1;
  while (l <= r)
  {
    int mid = l + (r - l) / 2;
    if (a[mid] == target)
      return mid;
    if (a[mid] < target)
      l = mid + 1;
    else
      r = mid - 1;
  }
  return -1;
}
```

#### 极简板

```cpp
int binSearch(int l, int r)
{
  while (l < r)
  {
    int mid = l + (r - l) / 2;
    if (check(mid))
      r = mid; // check()判断mid是否满足性质
    else
      l = mid + 1;
  }
  return l;
}
```

+ $O(log_2N)$
+ `int mid = l + (r - l) / 2;`是防止数据溢出
+ 极简版本只适用于确定答案在数组中的题目

### 二叉搜索树

(具体见[从零开始的数据结构-树](https://lapras.xyz/2021/04/01/8022ea89.html))

也称为 二叉查找树 、二分搜索树 、有序二叉树或排序二叉树。

满足以下几个条件：

- 若它的左子树不为空，左子树上所有节点的值都小于它的根节点。
- 若它的右子树不为空，右子树上所有的节点的值都大于它的根节点。

![image-20211024203611557](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024203611.png)

显然地，如果我们对这颗树进行中序遍历，就会得到一个有序的线性表。那么反之，我们之前的二分查找的过程，也可以用这颗树来表示。

+ 每一个根节点都是中点(偶数个为左)
+ 左子数为左边的线性子表，右子树为右边的线性子表

![GIF 2021-10-24 20-42-50](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024204318.gif)

来计算一下$ASL_s$，显然地第一层只需要对比1次，第二次需要两次，以此类推$ASL_s=(1*1+2*2+3*4+4*3)/10$。

计算$ASL_f$我们只需要将图上的二叉搜索树的每个结点用空白结点进行补齐。那么这些空白结点就代表着失败的区间。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211024210117.png" alt="graph (7)" style="zoom:67%;" />

$ASL_f=(4*4+5*6)/10$

## 插值查找（InterpolationSearch）

### 思路

插值查找的核心思想确实和翻字典差不多。毕竟没人翻字典是二分查找的吧。它和二分查找唯一的区别就在于`mid`的更新。

二分查找的`mid`只是简单地取了中点，而插值查找则有一点按照比例分配的感觉。

$mid = l+ [\frac{key - a[l]}{a[r]-a[l]}](r-l)$

可以看到，原来的系数$\frac{1}{2}$被替换为了$[\frac{key - a[l]}{a[r]-a[l]}]$，我们假定一个完全平均分配的数组`[1,2,3,4,5,6,7,8,9,10]`使用插值查找7，

则$mid = 0+ \frac{7 - 1}{10-1}(9-0)=6$直接 $O(1)$ 获得了7的下标。但同样的，如果数组分布非常不均匀，则会退化成$O(N)$。

比如`[0, 99, 100, 100, 100, 100, 100]`使用插值查找99，则$mid$会依次更新为5，3，1反而比直接二分来的慢了。

### 代码

```cpp
int binSearch_inp(int a[], int length, int target)
{
  int l = 0, r = length - 1;
  while (l <= r)
  {
    int mid = l + (target - a[l]) * (r - l) / (a[r] - a[l]) ;
    if (a[mid] == target)
      return mid;
    if (a[mid] < target)
      l = mid + 1;
    else
      r = mid - 1;
  }
  return -1;
}
```

+ 期望$O(loglogN)$
+ 最坏$O(N)$

