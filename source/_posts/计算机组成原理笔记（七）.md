---
title: 计算机组成原理笔记（七）
tags:
  - 笔记
  - 硬件
category: 计算机组成原理
katex: true
abbrlink: 4904199e
---

## 前言

本章主要介绍机器指令系统的分类、常见的寻址方式、指令格式以及设计指令系统时应考虑的各种因素。黑神话新实机演示真不错

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%BB%91%E8%9B%87%E9%98%BF%E6%96%AF%E9%A1%BF%E9%98%BF%E4%B8%89.jpeg" alt="20220820204111" style="zoom: 40%;" />

<!--more-->

## 机器指令

指令是指示计算机执行某种操作的命令，**是计算机运行的最小功能单位**。一台计算机的所有指令的集合构成该机的指令系统，也称为 **指令集**。

### 指令的一般格式

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="image-20220813150549742" style="zoom:80%;" />

操作码：用来指明该指令所要完成的操作，如加法、减法、传送、移位、转移等。其位数往往反映了机器的操作种类，即机器允许的指令条数，如操作码占 7 位，则该机器最多包含 $2^7 = 128$ 条指令。

操作码的长度 **可以是固定的，也可以是变化的**。前者将 **操作码集中放在指令字的一个字段内**，这种格式便于硬件设计，指令译码时间短。对于操作码长度不固定的指令，其 **操作码分散在指令字的不同字段** 中。这种格式可有效地压缩操作码的平均长度。但会增加指令译码和分析的难度，使控制器的设计复杂。通常采用 **扩展操作码技术**，使操作码的长度随地址数的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。

### 按地址码数目分类

#### 零地址指令

顾名思义，只有操作码而无地址码的指令

1. 不需要操作数，如空操伤、停机、关中断等指令
2. 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶（类似后缀表达式）

#### 一地址指令

1. 只需要单操作数，如加 1、减 1、取反、求补等

   指令含义： $OP(A_1)\to A_1$ ,

2. 需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在 **ACC** )

   指令含义： $(ACC)OP(A_1)\to ACC$ 

   注： $A_1$ 指某个主存地址， $(A_1)$ 表示 $A_1$ 所指向的地址中的内容

#### 二地址指令

1. 需要两个操作数的算术运算、逻辑运算相关指令

   指令含义： $(A_1)OP(A_2)\to A_1$ 或 $(A_1)OP(A_2)\to A_2$ 

#### 三地址指令

1. 需要三个操作数的算术运算、逻辑运算相关指令

   指令含义： $(A_1)OP(A_2)\to A_3$ 

#### 四地址指令

1. 需要三个操作数的算术运算、逻辑运算相关指令，且指定下一个要执行的指令

   指令含义： $(A_1)OP(A_2)\to A_3$ ， $A_4$ 为下一条将要执行指令的地址
   正常情况下：取指令之后程序计数器 $PC+1$ ，指向下一条指令
   四地址指令：执行指令后，将 **PC** 的值修改为 $A_4$ 所指地址

> 地址码的位数决定了该指令的 **直接寻址范围**，比如 $n$ 位地址码的直接寻址范围为 $2^n$ 。
>
> 若指令总长度固定不变，则地址码数目越多，每个地址码的位数就越少，寻址能力越差

假设给定指令字长为 32 位，操作码为定长操作码 8 位。则不同地址码数目区别如下：

| 地址码 | 访存次数              | 寻址范围 |
| ------ | --------------------- | -------- |
| 零地址 | 1                     | 无地址码 |
| 一地址 | 3（结果存于 ACC 则为 2） | $2^{24}$ |
| 二地址 | 4（结果存于 ACC 则为 3） | $2^{12}$ |
| 三地址 | 4                     | $2^8$ |
| 四地址 | 4                     | $2^6$ |

### 按指令长度分类

> 指令字长：一条指令的总长度（可能会变）
>
> 机器字长：CPU 进行一次整数运算所能处理的二进制数据的位数（通常和 ALU 直接相关）
>
> 存储字长：一个存储单元中的二进制代码位数（通常和 MDR 位数相同）

显然指令字长取决于：

1. 操作码的长度
2. 操作数地址个数
3. 操作数地址长度

+ 定长指令字结构：指令系统中所有指令的长度都相等，即 **指令字长等于存储字长**
+ 变长指令字结构：指令系统中各种指令的长度不等，指令长度是机器字长的若干倍：半字长指令、单字长指令、双字长指令

### 按操作码长度分类

+ 定长操作码：指令系统中所有指令的操作码长度都相同

  如果操作码固定为 $n$ 位，则该系统最多支持 $2^n$ 条指令

+ 可变长操作码：指令系统中各指令的操作码长度可变

  通过扩展操作码指令格式实现


### 扩展操作码技术

**定长指令字结构+可变长操作码**。对于不同地址数量的指令使用长度不同的操作码

#### 保留码点法

先假设指令字长为 16 位，每个地址码占 4 位。前 4 位为基础操作码 $OP$ ，令有 3 个四位长的地址字段 $A_1\quad A_2 \quad A_3$ 

若 4 位基本操作码若全部用于三地址指令，则有 16 条。但至少须将 1111 留作扩展操作码之用，即三地址指令为 15 条；同理，将 1111 1111 留作扩展操作码只用，即二地址指令为 15 条；同理，一地址指令和零地址指令也为 15 条

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%BF%9D%E7%95%99%E9%A9%AC%E5%BA%97.png" alt="image-20220813153608821" style="zoom:80%;" />

在设计扩展操作码时，要注意以下两点：

1. 不允许短码是长码的前缀（对比哈夫曼编码），即不允许短操作码与长操作码的前面部分相同
2. 各指令的操作码不能重复

通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。

+ 不难发现，对于地址码长度为 $n$ 的指令来说，上一层留出 $m$ 种状态，下一层可以扩展出至多 $m \times 2^n$ 种状态

## 操作数类型和操作类型

### 操作数类型

机器中常见的操作数类型有地址、数字、字符、逻辑数据等

1. 地址：地址实际上也可看做是一种数据，在许多情况下要计算操作数的地址。如果是绝对地址，则可被认为
   是一个无符号整数；如果是相对地址，则可被认为是一个有符号整数
2. 数字：定点数，浮点数和十进制数
3. 字符：ASCII，BCD
4. 逻辑数：逻辑运算

### 数据在存储器中的存放方式

#### 存放次序

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF.png" alt="image-20220816172411987" style="zoom:80%;" />

这两种字节次序分别为：高字节为大端方式，低字节为小端方式

#### 存放方式

以下图所示的存储器存储字长为 64 位，可按字节、半字、字、双字访问。由于不同的机器数据字长不同，每台机器处理的数据字长也不统一，例如奔腾处理器可处理 8（字节）、16（字）、32（双字）、64（四字）；PowerPC 可处理 8（字节）、16（半字）、32（字）、64（双字）。

1. 从任意位置开始

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E5%AD%98%E6%94%BE.png" alt="image-20220816230817830" style="zoom:80%;" />

   优点：不浪费存储资源
   缺点：除了访问一个字节之外，访问其它任何类型的数据，都可能花费两个存储周期的时间。读写控制比较复杂。

2. 从一个存储字的起始位置开始

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E5%AD%97%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%BD%AE%E5%BC%80%E5%A7%8B8.png" alt="image-20220816230928672" style="zoom:80%;" />

   优点：无论访问何种类型的数据，在一个周期内均可完成，读写控制简单。
   缺点：浪费了宝贵的存储资源

3. **边界对准方式**：从地址的整数倍位置开始访问

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%BE%B9%E7%95%8C%E5%AF%B9%E5%87%86%E6%96%B9%E5%BC%8F.png" alt="image-20220816231046351" style="zoom:80%;" />

   在对准边界的 64 位字长的计算机中，半字地址是 2 的整数倍，字地址是 4 的整数倍，双字地址是 8 的整数倍。当所存数据不能满足此要求时，可填充一个至多个空白字节。

   本方案是前两个方案的折衷，在一个周期内可以完成存储访问，空间浪费也不太严重。

### 操作类型

1. 数据传送

   LOAD：把存储器中的数据放到寄存器中
   STORE：把寄存器中的数据放到存储器中

2. 算逻操作

   算术：加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算
   逻辑：与、或、非、异或、位操作、位测试、位清除、位求反

3.  移位操作

   算术移位、逻辑移位、循环移位（带进位和不带进位）

4. 转移操作
   无条件转移、条件转移、调用和返回 、陷阱与陷阱指令

5. 输入输出操作

   CPU 寄存器与 IO 端口支间的数据传送（端口即 IO 接口中的寄存器）

## 寻址方式

寻址方式是指确定本条指令的数据地址以及下一条将要执行的指令地址的方法，它与硬件结构紧密相关，而且直接影响指令格式和指令功能。寻址方式分为指令寻址和数据寻址两大类。

### 指令寻址

顺序寻址：取完一条指令后，顺序地读取下一条指令。而指令的地址保存在 $PC$ 当中。

 $(PC)+1 \to PC$ 

+ 这里的 1 并非是数字 1 ，而是根据编址方式调整的，表示一个指令字长。

跳跃寻址：跳跃寻址通过转移类指令实现，比如 JMP

### 数据寻址

数据寻址方式种类较多，在指令字中必须设一字段来 **指明属于哪一种寻址方式**。指令的地址码字段通常都不代表操作数的真实地址，把它称为 **形式地址**，记作 A 。操作数的真实地址称为 **有效地址**，记作 EA , 它是由寻址方式和形式地址共同来确定的。由此可得指令的格式应如：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%A0%BC%E5%BC%8F.png" alt="image-20220818215214674" style="zoom:80%;" />

以下寻址方式介绍，基于 **指令字长 = 存储字长 = 机器字长** 的假设前提

### 立即寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80.png" alt="image-20220818220734432" style="zoom:80%;" />

+ 形式地址 A 存放的不是地址，而是操作数本身，被称为 **立即数**，采用 **补码形式存放**
+ $\#$ 是立即寻址的特征标记
+ 优点：只要取出指令，便可立即获得操作数，这种指令在执行阶段 **不必再访问存储器**
+ 缺点：显然 A 的位数限制了这类指令所能表述的立即数的范围

### 直接寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818222404551" style="zoom:80%;" />

+ 有效地址 EA = 形式地址 A，有效地址由形式地址给出
+ 优点：寻找操作数比较简单，也不需要专门计算操作数的地址，在指令执行阶段 **对主存只访问一次**
+ 缺点：A 的位数限制了操作数的寻址范围，而且必须修改 A 的值，才能修改操作数的地址。

### 隐含寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818223757476" style="zoom:80%;" />

+ 指令字中不直接地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中
+ 优点：由于隐含寻址在指令字中少了一个地址。因此，这种寻址方式的指令有利于缩短指令字长

### 间接寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818225251882" style="zoom:80%;" />

+ 指令字中的形式地址不直接指出操作数的地址，而是指出操作数有效地址所在的存储单元地址
+ 间接寻址，可以进行若干次。
+ 优点：可扩大寻址范围（比如用存储字的首位表示是否要继续间址）；便于编写程序
+ 缺点：程序执行阶段进行最少两次（一次间址）的访存，运行较慢

### 寄存器（直接）寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818230609269" style="zoom:80%;" />

+ 指令字中，地址码字段直接指出了寄存器的编号，即 $EA = R_i$ 
+ 优点：操作数不在主存中，而在寄存器中。所以访存次数为 0；地址字段只需指明寄存器的编号（寄存器个数非常有限），故指令字长度较短。

### 寄存器间接寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image-20220818231120511" style="zoom:80%;" />

+ 有效地址保存在寄存器当中，操作数保存在存储器中。即 $EA = (R_i)$ 
+ 优点：便于循环程序的编写
+ 缺点：需要访问一次主存，但比间接寻址少访问一次

### 基址寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="image-20220818231546155" style="zoom:80%;" />

+ **隐式基址寻址** 需设有基址寄存器 $BR$ ，使用时用户无需特意指出。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9F%BA%E5%80%BC%E5%AF%BB%E5%9D%80%E9%99%90%E6%97%B6.png" alt="image-20220818232654260" style="zoom:80%;" />

+ **显式基址寻址** 是在一组通用寄存器里，由用户明确指出哪个寄存器用做基址寄存器 $R_0$ ，存放基地址。
+ 其操作数的有效地址 $EA$ 等于指令字中的形式地址与基址寄存器中的内容（称为基地址）相加，即 $EA = (BR) +A$ 

+ 优点：扩大寻址范围；有利于多道程序设计，因为用户可不必考虑自己的程序存于主存的哪一空间区域，完全可由操作系统或管理程序根据主存的使用状况，赋予基址寄存器内一个初始值（即基地址）, 便可将用户程序的逻辑地址转化为主存的物理地址（实际地址）。
+ 注意：指令执行过程中，**BR** 的内容不允许修改，只能修改 $A$ 的内容

### 变址寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="image-20220818232957427" style="zoom:80%;" />

+ 变址寻址与基址寻址极为相似。 $IX$ 为变址寄存器（专用），通用寄存器也可以作为变址寄存器。其有效地址 $EA = (IX)+A$ 
+ 优点：扩大寻址范围；有利于处理数组问题，可设定 $A$ 为数组的首地址，不断改变变址寄存器 $IX$ 的内 容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。
+ 注意：指令执行过程中，**A** 的内容不允许修改，只能修改 $IX$ 的内容

### 相对寻址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.png" alt="image-20220819170029022" style="zoom:80%;" />

+ 相对寻址的有效地址是将程序计数器 $PC$ 的内容（即当前指令的地址）与指令字中的形式地址 $A$ 相加而成，即 $EA = (PC)+A$ 
+ $A$ 是相对于当前指令的位移量，可正可负，用补码表示。又称位移量
+ 倘若位移量为 8 位，则指令的寻址范围在 $[(PC)-128, (PC)+127]$ 之间。相对寻址的最大特点是转移地址不固定，它可随 $PC$ 值的变化而变，因此，无论程序在主存的哪段区域，都可正确运行，对于编写浮动程序特别有利。

### 堆栈寻址

堆栈寻址要求计算机中设有 **堆栈**。堆栈既可用寄存器组（称为 **硬堆栈**）来实现，也可利用主存的一部分空间作堆栈（称为 **软堆栈**）。先进后出型堆栈的操作数只能从一个口进行读或写。以软堆栈为例，可用堆栈指针 SP（Stack Point）指出栈顶地址，也可用 CPU 中一个或两个寄存器作为 $SP$ 。操作数只能从栈顶地址指示的存储单元存或取。可见堆栈寻址也可视为一种隐含寻址，其操作数的地址总被隐含在 $SP$ 中。堆栈寻址其本质也可视为寄存器间接寻址，因 $SP$ 可视为寄存器，它存放着操作数的有效地址。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80.png" alt="image-20220819171018635" style="zoom:80%;" />

+ 同样的，这里的 1 要根据编址方式确定，若按照字编址，则为 1。若按照字节编址，则根据存储字长决定，比如 32 位为 4 个字节

## CISC 和 RISC

###  CISC

Complex Instruction Set Computer

 设计思路：一条指令完成一个复杂的操作

代表：x86 架构

### RISC

Reduced Instruction Set Computer

设计思路：一条指令完成一个基本操作，多条指令组合完成一个复杂操作

代表：ARM 架构

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/RISCandCise.png" alt="image-20220820202440113" style="zoom:80%;" />
