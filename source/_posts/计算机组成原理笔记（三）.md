---
title: 计算机组成原理笔记（三）
tags:
  - 笔记
  - 硬件
category: 计算机组成原理
katex: true
abbrlink: 26b9f9fa
date: 2022-06-30 22:58:07
---



## 前言

市原大輔走了，但没完全走。崛起你真的好温柔。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220630231342.jpg" alt="91953835_p0_master1200" style="zoom:80%;" />

<!--more-->

## 存储器分类

### 按存储介质分类

1. 半导体存储器（易丢失）：TTL（集成度低，功耗高），MOS（集成度高，功耗低）
2. 磁表面存储器：磁头(读/写)、载磁体(存储)
3. 磁芯存储器：硬磁材料，环状元件
4. 光盘存储器：激光(读/写)，磁光材料(存储)

### 按存取方式分类

1. 存取时间与物理地址无关 (随机访问)

   - 随机存储器（**在程序执行过程中** 可读可写）

   - 只读存储器（**在程序执行过程中** 只读）

2. 存取时间与物理地址有关(串行访问)

   - 顺序存取存储器，如磁带

   - 直接存取存储器，如磁盘

### 按在计算机中的作用分类

![按在计算机中的作用分类](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%89%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB.png)

+ Cache：高速缓冲存储器，位于 CPU 和主存之间，用于缓存主存的数据。本质上是一块集成到 CPU 的 SRAM。

+ RAM：

  - 静态 RAM(SRAM)

  - 动态 RAM(DRAM)

+ ROM：

  - MROM(掩膜 ROM)

  - PROM(可编程 ROM)

  - EPROM(电可编程 ROM)

  - EEPROM(电可编程可擦除 ROM)

+ Flash Memory（闪存）：可用于固态硬盘

## 存储器的层次结构

![image-20220628201956665](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E5%99%A8%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.png)

+ 速度：从快到慢
+ 容量：从小到大
+ 价格：从高到低
+ 寄存器：集成在 CPU 当中，I/O 端口中也存在。
  + 从体系结构的角度，供给给机器语言程序员使用的称为体系结构寄存器。
+ 缓存：一部分集成在 CPU 当中。如果 CPU 需要读取或写入数据，缓存的速度更快

![缓存 主存层次和主存 辅存层次](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BC%93%E5%AD%98%20%E4%B8%BB%E5%AD%98%E5%B1%82%E6%AC%A1%E5%92%8C%E4%B8%BB%E5%AD%98%20%E8%BE%85%E5%AD%98%E5%B1%82%E6%AC%A1.png)

+ 缓存到辅存的管理由 CPU 提供的硬件来完成，通常软件开发者不需要了解其中的细节。
+ 主存到辅存的管理由 CPU 提供的 **MMU** 以及操作系统提供的 **内存管理模块** 共同完成，不仅可以为每个进程提供 **独立的地址空间**，还可以借助辅存让那些比主存容量还要大的程序得以运行。

## 主存储器

### 概述

1. 主存的基本结构

  ![主存的基本结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png)

  + MAR：记录了我们要访问的存储单元地址
  + MDR：记录了我们要读出或者写入的数据
  +  具体的读还是写，则是由控制电路控制读写电路实现

2. 主存和 CPU 联系

  ![主存和 CPU 联系](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E8%81%94%E7%B3%BB.png)

  + MDR 和 MAR 都是集成在 CPU 上的，但属于主存
  + 数据总线完成 CPU 和主存的信息传输
  + 地址总线是单向的，CPU 给定要访问的内存单元地址
  + 控制信号：读取或者写入

3. 主存中存储单元地址的分配

   假设当前使用的存储器字长为 32 位，要存储的数为 12345678H。首先根据 8 位一个字节，每个字节都要有一个 **字地址**，那么一个存储单元就可以分为 4 个字节。**字地址的选择是当前字节的第一个地址**，所以根据数据的存放顺序，可以分为两种方式。

   ![大端和小端方式](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png)

   + 如图，每一个格子都有八位（存储两个 16 进制数），一行就是一个存储单元（字长为 32）
   + 字地址从 0 开始编号
   + **主存的寻址方式**：按字节寻址（每个地址对应一个字节）和按字寻址（每个地址对应一个字）

4. 主存的技术指标

   - 存储容量：存放二进制数据的总位数或总字节数

   - 存储速度：
     - 存取时间：存储器的访问(读/写)时间，即给出地址信号到访问完成所需的时间
     - 存取周期：**连续** 两次 **独立** 的存储器访问操作所需的 **最小** 时间间隔，通常 **大于** 存取时间
   - 存储器的带宽：单位时间内写入的位数

### 半导体芯片简述

1. 半导体芯片的存储结构

   ![半导体芯片的存储结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%8A%E5%AF%BC%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)

   + 地址线：单向，由 CPU 或 I/O 设备
   + 数据线：双向，读取向外，写入向内
   + **芯片容量**：假设地址线有 $n$ 条，数据线有 $m$ 条。则芯片容量为 $m \times 2^n$ 位，通常将 $2^n$ 表示为 $K$ 的形式，即 $2^{10}$ 为 $1K$ 。然后写为 $\alpha K \times m$ 位 ，其中 $\alpha$ 为系数
   + 片选线：传输片选信号，用来选中具体的芯片（存储器可能由多个存储芯片构成）。表示为 $\overline{CS},\overline{CE}$ 
   + 读写控制线： $\overline {WE}$ （低电平写，高电平读），或者用两根线表示： $\overline{OE},\overline{WE}$ 

2. 半导体存储芯片扩展

   ![存储芯片扩展](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E6%89%A9%E5%B1%95.png)

   首先是位扩展：将 8 片一位的并为一组，则得到 $16K \times 8$ 位存储器

   然后是字扩展：复制为 4 组即可得到 $64K \times 8$ 位存储器

   所以一共使用了 32 片存储芯片，即其存储容量的倍数关系

3. 半导体芯片的译码驱动方式

   线选法

   ![线选法](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BA%BF%E9%80%89%E6%B3%95.png)

   线选法主要是通过地址译码器，走指定字线到目标的存储单元。并且根据读写控制电路选择数据的流通方向。显然这样做系统的结构非常清晰，但是内部字线的数量会随着地址增加而变得非常臃肿。

   重合法

   ![重合法](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%87%8D%E5%90%88%E6%B3%95.png)

   重合法将所有的存储单元形成一个矩阵布局。通过行（X 地址）列（Y 地址）分别进行译码操作。

### 随机存取存储器（RAM）

#### 静态 RAM（SRAM）

SRAM 使用 **触发器** 来保存 0 和 1 这两个状态。具体的电路实现就省略了。下面开始举例：

![Intel 2114](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Intel%202114.png)

+ $\overline {WE}$ ：读写控制
+ $\overline {CS}$ ：片选信号，只有当其为低电平时，该芯片被选中
+ $A$ ：地址线，一共有 10 条，说明是地址位为 $1K$ 
+ $I/O$ ：数据线，一共有 4 条，说明数据位为 4

下面举个例子，将 2114 拼成一个 64X64 的存储阵列，通过重合法，一次 **读取同一行的四列数据**

![64X64 2114](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/64X64%202114.png)

+ 不难发现，行地址全部正常编号。列地址只使用了 4 位，即编号 16 个地址。那么将列数 64 与 16 相除，得到四组。这样一来每次就能实现选取同一行的四列数据

#### 动态 RAM（DRAM）

DRAM 使 **用电容存储电荷的方式来存储 1，0**。读数据时，当电容是高电平的时候为 1，低电平的时候为 0。写数据时，写 1 就是为电容充电，写 0 则是电容放电。由于电容会通过电路漏电，时间一久电荷就会流失，导致信息丢失，因此需要周期性的刷新电容(为电容充电)。其具体电路实现分为 **单管** 和 **三管**

![Intel1103-DRAM 三管读取数据](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220629125609.png)

+ 由图易得，是 $1K \times 1$ 位的存储器。通过重合法进行译码
+ 首先是行地址，注意这里除了 5 位行地址，还包括一位读取信号。列地址同理
+ 得到数据后，通过读写控制电路向外界传输

#### 动态 RAM 的刷新

回想动态 RAM 的操作过程，首先是行地址取出一整行的数据到某条选择线上。这时我们在选择线上加装一个刷新放大器，即可保存原本的数值。所以，**刷新只与行地址有关，每次刷新一行**

1. 集中刷新：存在死区
2. 分散刷新：无死区，但读写周期加长，性能变差
3. 异步刷新：存在小死区，但是如果安排得当。比如放置在 CPU 进行指令译码时，则无死区。

#### 动态 RAM 和静态 RAM 比较

1. 存储原理：输出 DRAM 使用电容存储数据；SRAM 使用触发器存储数据
2. 集成度：DRAM 的基本单元电路结构更简单，方便大规模集成，因此 DRAM 集成度更高
3. 引脚数量：DRAM 通常将行列地址复用引脚，因此引脚数量少(进而芯片封装的体积较小)；而 SRAM 出于速度的考虑，一般不会这样做
4. 功耗：DRAM 的功耗主要消耗在电容充放电，功耗较小；SRAM 的使用触发器存放数据，而构成触发器的管子有部分是一直导通的，也就一直消耗功率，因此功耗较大
5. 价格：同样存储一个 bit，DRAM 的单元电路简单，价格低；SRAM 的单元电路复杂，用的管子多，因此价格高
6. 速度：访问 DRAM 伴随着电容的充放电，因此速度较慢；而 SRAM 采用 chu'fa，访问速度快
7. 刷新：DRAM 需要周期性的刷新其中的电容，才能保持数据；SRAM 则没有这个需要。

### 只读存储器（ROM）

ROM 的发展历程

1. 早期的 ROM 在出厂时就会被厂家烧写好内容，且不支持用户再次对 ROM 进行编程
2. 用户可以使用专门的擦写设备对芯片进行一次擦写，**仅可擦写一次**
3. 用户可以使用专门的擦写设备对芯片进行多次擦写，比如用紫外线擦写的 EPROM，这时候擦写还比较麻烦
4. EEPROM 的出现使得用户可以多次擦写 ROM，且无需使用专门的擦写设备

#### 几种 ROM 的简介

+ MROM（掩模式只读存储器）：**行列选择线交叉处有 MOS 管则表示 1，无 MOS 管则表示 0。** 因为有无 MOS 管在芯片生产出来后就决定了，因此不可编程。
+ PROM（可编程只读存储器）：通常实现为在行列选择线之间 **添加一根熔丝**，编程时需要写 0 则加大电流让熔丝熔断，否则熔丝连通表示 1。由于熔丝熔断后不可在连接，因此 **只可进行一次编程**。
+ EPROM（可擦除可编程式只读存储器）：EPROM 可通过对芯片中的 **N 型沟道浮动栅 MOS 管** 的 D 端加电压，形成浮动栅，进而电路不导通表示 0，反之表示 1。浮动栅可由 **紫外线照射后消除**，因此可以利用紫外线实现芯片的全部擦写，从而实现芯片的多次编程。
+ EEPROM（电子式可擦除可编程只读存储器）：EEPROM 改进了芯片的擦写功能，实现了电可擦写，且既可局部擦写也可全局擦写。
+ Flash Memory（闪存）：，较 EEPROM 成本更低，单元电路更为简单，集成度高，访问速度也更快。不过寿命不如 EEPROM，因此闪存通常用于保存大量数据，而 EEPROM 则用于存放不需要经常改变的一些系统参数(数据量少)。只有少数支持片上执行(XIP)的闪存(如 NorFlash)才可以作为主存储器，存放程序(不可以随机写，因此无法存放程序运行时加工的数据)。而大部分闪存一般用作辅存。

### 存储器的扩展

#### 位扩展

电路连接时，两块或多块芯片共用地址线，数据线则分别与 CPU 的不同数据线连接，片选和读写控制连接在一起，实现同时读，同时写。

![2 片 1Kx4 组成 1Kx8](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%BD%8D%E6%89%A9%E5%B1%95.png)



#### 字扩展

电路连接时，共用低位的地址线，片选信号则通过译码器连接 CPU 地址线的高位，芯片数量少时，也可以不用译码器，直接使用非门

![2 片 1Kx8 组成 2Kx8](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%97%E6%89%A9%E5%B1%95.png)

#### 字、位扩展

先按位扩展将多个芯片组成一个位数更多的芯片组，各组之间再按照字扩展的连接方式与 CPU 连接

![8 片 1Kx4 组成 4Kx8](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/8%E7%89%871Kx4%E7%BB%84%E6%88%904Kx8.png)

### 存储器与 CPU 的连接

1. 地址线的连接
2. 数据线的连接
3. 读/写命令线的连接
4. 片选线的连接
5. 合理选择存储芯片：系统配置和系统程序使用 ROM，用户程序选择 RAM。
6. 其他 时序、负载

### 对存储器进行校验

复杂的电磁环境下，工作中的存储器受到干扰，可能导致其内部存储的 1、0 发生翻转，即 1 变成 0、0 变成 1，这样存储的信息就出错了。如果我们无法得知这一情况，而在程序中使用了错误的数据，那么就可能造成损失。

一个编码集合中，任意两个合法编码之间 **二进制位数** 的 **最少差异** 称为 **编码的最小距离**，编码的纠错和检错能力与其最小距离有关。具体关系如下：
$$
L - 1 = D + C (D >= C)
$$

+ L：编码的最小距离
+ D：能够检错的位数
+ C：能够纠错的位数

常用的检验方法有奇偶校验，海明码，CRC 循环校验

#### 奇偶校验

奇校验：使待校验 bit 串和校验位共有 **奇数** 个 1

偶校验：使待校验 bit 串和校验位共有 **偶数** 个 1

#### 海明码（汉明码）

是一种多重分组奇偶校验。将数据组织为 $k$ 个分组，每组进行奇偶校验。不仅能检验是否出错，也能定位错误，但定位代价较大，假设有 $n$ 位有效码，设置了 $k$ 位校验码，则 $n$ 与 $k$ 关系为
$$
2^k ≥ n + k + 1
$$
+ 假设有 $k$ 个校验位，一位有 0 或 1 两种情况， $k$ 位就有 $2^k$ 种排列情况，能表示 $2^k$ 种状态。其中一个状态用来表示正确（没有错误发生）的这种情况。其余的 $2^k-1$ 种状态来表示错误发生在哪一位。总共有 $n+k$ 位，所以 $2^k-1$ 要大等于 $n+k$ 。

+ 海明码的校验码总是放在 $2^i, i = 0,1,2,3...$ 

+ 把海明码（有效码和校验码的结合）从左到右，从 **1** 开始编号 $C_1C_2n_3C_4n_5n_6n_7C_8...$ 

+ 各检验码负责的部分： $C_i$ 负责检验第 $i$ 位为 1 的编号

+ 校验码的数值 = 它所负责的有效码的异或（偶校验规则下）或者凑偶数个 1
+ 海明码的纠错过程：
  1. 接收方先根据数据长度确定 $k$ 
  2. 增设检验位 $P_i$ ，比如假设此时 $k = 3$ ，则新的检验码为 $P_4P_2P_1$ 
  3. 根据检验码的规则计算 $P_i$ ，比如偶规则下， $P_1 = 1\oplus 3 \oplus 5\oplus7$ 
  4. 得到二进制表示的检验码 $P$ ，换算成 10 进制即可得到哪一位出错了。如果是全 0 则表示无错误
+ 海明距离：是字符串相对于同样长度的零字符串的汉明距离，也就是说，它是字符串中非零的元素个数：对于二进制字符串来说，就是 1 的个数，所以 11101 的汉明重量是 4。

### 提高访存速度的措施

> 1. 采用高速组件
> 2. 采用层次结构 Cache-主存
> 3. 调整主存结构

下面介绍通过调整主存结构的方式：

1. 单体多字系统

   将存储器的和 CPU 的存储控制器的位宽设置为 CPU 字长(寄存器宽度)的整数倍，一次性可以读出多条指令或数据，缺点是写的时候，如果仅写一个字的内容比较麻烦，需要相应的硬件配合。

2. 多体并行系统
   主要思想是采用多个存储器并行工作，CPU 访问第一个存储器后，在读到数据前，无需等待，直接访问下一个存储器。这样一轮下来，第一个存储器已经准备好了数据，并能够接收下一次访问(存取周期已到)，于是再来一轮。如此，CPU 和存储器都不会空闲。
