---
title: 暑假补题记录(2)
katex: true
tags:
  - C++
  - 算法
categories: 算法学习
abbrlink: 468672cb
date: 2021-07-27 00:00:00
---

### 前言

莫队真好写 在学了在学了 <del> 学完就写篇博客 </del>

<!--more-->

# I love counting

### 描述

> **Problem Description**
>
> Mr W likes interval counting.
>
> One day, Mr W constructed a sequence of length n, each position of this sequence has a weight c (c ≤ n).
>
> There are a total of Q queries, and each query is given an interval (l, r) and two parameters a, b, and ask how many kinds of weights of this interval satisfy c ⨁ a ≤ b  where ⨁ is the binary Bitwise XOR operation.
>
> **Input**
>
> There is only one test case for this question.
>
> In the first line contains a positive integer n (n ≤ 100000) represents the length of the sequence.
>
> In the second line contains n positive integers, The i-th number in the sequence represents the weight ci (1 ≤ ci ≤ n)of the i-th position.
>
> In the third line, a positive integer Q (Q ≤ 100000) represents the number of queries.
>
> In the next Q line, each line has four positive integers l, r, a, b (1 ≤ l ≤ r ≤ n, a ≤ n+1, b ≤ n+1), which represent the parameters of the query.
>
> **Output**
>
> For each query, output an integer on a line to represent the number of weights that meet the conditions.
>
> **Sample Input**
>
> ```
>5
>1 2 2 4 5
>4
>1 3 1 3
>2 4 4 2
>1 5 2 3
>4 5 3 6
>```
>
> **Sample Output**
>
> ```
>2
>1
>2
>1
>```
>
>

### 题意分析

对于一个序列的多区间的离线询问问题，就可以考虑选择莫队。用莫队维护每次询问的 **每个块内元素种类**，以及 **i 元素是否在当前询问区间内**。

分析题目的核心条件： $c ⨁ a\le b$ ​​ 。先考虑小于号的情况，二进制展开后从高到底考虑。

第 $j$ ​位：

如果 b 是 1，a 是 1，那么 c 是 1，一定小于 b

如果 b 是 1，a 是 0，那么 c 是 0，一定小于 b

如果 b 是 0，a 是 1，那么 c 只能是 1 才有可能小于 b

如果 b 是 0，a 是 0，那么 c 只能是 0 才有可能小于 b

那么，我们只需要统计一定小于的情况（使用前缀和的思想）。最后加上 $c ⨁ a = b$ 的情况（ $c = a ⨁ b$ ​）

### 算法

#### 莫队

暂时先不仔细展开了，后续如果学完莫队就更一篇博客连接。这里先简单介绍一下，这题莫队的部分

```cpp
struct Mo
{
  int l, r, a, b, id;
} q[N]; //莫队的结构体定义，其中id是来保存询问的顺序的

for (int i = 0; i < m; i++)
  {
    scanf("%d%d%d%d", &q[i].l, &q[i].r, &q[i].a, &q[i].b);
    q[i].id = i;
  }
  sort(q, q + m, [](Mo x, Mo y)
       { return x.l / k == y.l / k ? x.r < y.r : x.l < y.l; });
  //莫队核心1：对询问区间进行排序。相同块比较r，不同块比较l

for (int i = 0; i < m; i++)
  {
    while (l > q[i].l)
      add(a[--l]); //区间左端点向左扩大
    while (l < q[i].l)
      sub(a[l++]); //区间左端点向右扩大
    while (r < q[i].r)
      add(a[++r]); //区间右端点向右扩大
    while (r > q[i].r)
      sub(a[r--]); //区间右端点向左减少
    //莫队核心2：区间的移动通过加减两边元素达成
  ｝
```

#### 核心代码

```cpp
int ask(int x) //经典的分块求和
{
  int res = 0;
  for (int i = x / k * k; i <= x; i++)
    res += c[i];
  for (int i = 0; i < x / k; i++)
    res += sum[i];
  return res;
}

int s = 0;
int a = q[i].a, b = q[i].b;

    for (int j = 18; j >= 0; j--)
    {
      int t = s;
      if (b >> j & 1)
      {
        if (a >> j & 1)
          t |= 1 << j;
        else
          s |= 1 << j;
        ans[q[i].id] += ask(t + (1 << j) - 1) - ask(t - 1); //前缀和更新答案
      }
      else
      {
        if (a >> j & 1)
          s |= 1 << j;
      }
    }
    ans[q[i].id] += c[q[i].a ^ q[i].b]; //加上相等的一个或者没有
```

+ `b >> j & 1` 这是一定可以更新答案的小于情况
+ `ans[q[i].id] += ask(t + (1 << j) - 1) - ask(t - 1);`  这是更新第 j 位为 1 的答案

#### 完整程序

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#include <cmath>

using namespace std;
const int N = 150000;
const int M = 998244353;
typedef long long LL;
LL m[N], s[N]; //m储存下标为i的最大值，s储存下标为i~n的最大值
LL a[N], b[N], c[N];
inline LL Max(LL a, LL b)
{
  return a > b ? a : b;
}
int main()
{
  int t;
  cin >> t;
  while (t--)
  {
    int n;
    LL ans = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
      scanf("%d", &a[i]);
    for (int i = 0; i < n; i++)
      scanf("%d", &b[i]);

    for (int i = 0; i < n; i++)
      for (int j = 0; j < n; j++)
        m[i & j] = Max(m[i & j], a[i] * b[j]);

    s[n - 1] = m[n - 1];
    for (int i = n - 2; i >= 0; i--)
      s[i] = Max(m[i], s[i + 1]);
    for (int i = 0; i < n; i++)
    {
      ans += s[i];
      ans = ans % M;
    }
    printf("%lld", ans);
  }
  return 0;
}

```

# I love max and multiply

[原题](https://acm.hdu.edu.cn/showproblem.php?pid=6971)

### 题意分析

 $c_k = max(a_ib_j) (i\&j \ge k)$ ​​​, 求其和

这篇博客讲的很好 [HDU6971. I love max and multiply 数学推理部分](https://www.cnblogs.com/Bamboo-Wind/p/15059655.html)

