---
title: 汇编语言程序设计（三）
tags:
  - 笔记
  - 汇编
category: 汇编语言程序设计
katex: true
---

## 前言

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220927102559.png" alt="image-20220927102552370" style="zoom:67%;" />

完结，准备爽放两个实践周

<!--more-->

## 宏汇编语言基本语句

### 源程序的结构

 一个完整的源程序在结构上必须做到:

1. 用 **方式选择伪指令** 说明执行该程序的 **微处理器类型**
2. 用 **段定义语句** 定义每一个 **逻辑段**
3. 用 **ASSUME 语句** 说明 **段约定**
4. 用 **过程定义语句** 定义每一个 **子程序**
5. 程序在完成预定功能之后，应能安全 **返回 DOS**
6. 用 **汇编结束语句** 说明源程序结束

### 伪指令

1. 处理器选择伪指令

   格式：`.586`

   功能：通知汇编程序，汇编源程序汇编链接后生成对应哪一种 CPU 类型的机器指令

   注意：方式选择伪指令放在程序的头部，做为源程序的第一条语句。不设置方式选择伪指令与设置 `.8086` 是等价的

2. 段定义伪指令

   格式：

   ```asm
   段名 SEGMENT 定位参数 链接参数 '分类名' 段长度
   	...段体...
   段名 ENDS
   ```

   功能：是 **逻辑段** 的定界语句，源程序中每一个逻辑段都必须用段定义语句定界

   1. **定位参数**：通知链接程序，告诉它逻辑段的目标代码在存储器中如何存储
      1. `BYTE` 字节地址：表明该逻辑段的目标代码可以从任意地址开始依次存放
      2. `WORD` 字地址：表示该逻辑段的目标代码，从偶地址开始依次存放
      3. `PARA`（缺省值）节地址：表示该逻辑段的目标代码，从能被 16 整除（末位为 0）的地址开始存放
      4. `PAGE` 页地址：表示该逻辑段的目标代码，从一个能被 256 整除的地址开始依次存放
   2. **链接参数**：通知链接程序对逻辑段的处理方法
   3. **'分类名'**：通知链接程序，把 **分类名** 相同的同名逻辑段组合起来，放在邻近的内存区
   4. **段长度**：说明逻辑段的 **寻址方式** 的位数。若是 `USE16` ，则表示该段体积最大 64K ，单元偏移地址为 16 位，采用 16 位寻址。若为 `USE32`，则表示该段体积最大 4G ，单元偏移地址为 32 位，采用 32 位寻址

   注意：

   1. 一个逻辑段从 `SEGMENT` 语句开始，到 `ENDS` 语句结束
   2. 通常用 `DATA` 做为数据段的段名，用 `STACK` 做为堆栈段的段名，`CODE` 为代码段的段名
   3. 在 **实模式环境** 下，各逻辑段应采用 16 位寻址，所以段长度选用 `USE16`
   4. 只有在模块化程序中，才有必要考虑链接参数的选择
   5. 注意分类名记得加 **单引号**
   6. 在单一模块程序中，**定位参数**，**链接参数**，**分类名** 均选用 “缺省” 表示即可
   7. 在单一模块程序中，如果有 **堆栈段**，则堆栈段选用 **STACK** 为链接参数（因为只有 STACK 属性才表示该段是堆栈段），**'STACK'** 为分类名，由于选用 STACK 为链接参数，汇编后 DOS 将自动给 `SS:SP` 赋值

3. 段约定伪指令 `ASSUME`

   格式：`ASSUME 段寄存器:段名,...,段寄存器:段名`

   功能：`ASSUME ` 语句通知汇编程序，寻址逻辑段使用哪一个段寄存器

   注意：

   1. `ASSUME` 语句通常是放在 **代码段** 的第一条语句
   2. `ASSUME` 语句，仅仅是约定了对某个逻辑段进行寻址操作时使用哪一个段寄存器，而段寄存器的初值还必须在程序中用 `MOV` 指令设置
   3. `CS:IP` 由 DOS 自动赋初值
   4. `SS:SP` 初值由 DOS 自动赋给，或由程序员赋给

4. 过程（子程序）定义伪指令 `PROC`

   格式：

   ```asm
   过程名	PROC	属性
   	...过程实体...
   		RET
   过程名 	ENDP
   ```

   功能：定义过程（子程序）

   1. 属性：两种描述：`NEAR` 代表段内操作，`FAR` 代表段间操作

   注意：

   1. 一个子程序从 `PROC` 语句开始，到 `ENDP` 语句结束
   2. 汇编后过程名就是子程序第一条指令的入口地址

5. 返回 `DOS` 指令

   格式：

   ```asm
   MOV AH, 4CH
   INT 21H
   ```

   功能：程序在完成预定任务之后，返回 DOS

   注意：事实上是用了下文要介绍的 **系统功能调用**

6. 汇编结束伪指令 `END`

   格式：`END BEGIN`

   功能：通知汇编程序源程序到此结束

   注意：DOS 装载程序的可执行文件时，自动把标号 `BEGIN` 所在段的段基址赋给 `CS`，把 `BEGIN` 所在单元的偏移量赋给 `IP`。从而 CPU 自动从 `BEGIN` 开始的那条指令依次执行程序

### 汇编源程序的编程格式

在汇编语言中，针对于 Microsoft DOS / Windows 操作系统，为了生成 EXE 和 COM 两种不同的文件，在编写源程序时必须依据规定的格式进行，也称为编程格式。分别对应 EXE 文件的编程格式和 COM 文件的编程格式。

  1. EXE 文件的编程格式：只能生成扩展为 EXE 的可执行文件。允许源程序使用多个逻辑段 (包括数据段、堆栈段、代码段及其它逻辑段) ; 在实模式下，每个逻辑段的目标块不超过 64K ；适合编写大型程序。最终能生成 .EXE 文件 
  1.  COM 文件的编程格式：可以生成扩展为 COM 的可执行文件。源程序只能有一个逻辑段(即代码段)，不允许设置堆栈段。且代码段目标块小于 64K，适合于编写中小型程序

## 系统功能调用

DOS 的 4 个组成部分中 `IBMBIO.COM` 和 `IBMDOS.COM` 是 DOS 系统的核心模块，前者为基本 I/O 设备处理程序，与 BIOS 一起完成数据输入和数据输出的基本操作；后者是磁盘文件管理程序。这两个模块均有若干子功能可以被用户程序调用，在汇编里面要使用一些已经写好的子程序的话，我们就可以使用功能调用。有两种方式：

1. 通过操作系统内核里面提供的一些子程序。(也叫做 DOS 功能调用)
2. 绕开操作系统，直接调用主板芯片上固化的子程序。(叫做 BIOS 功能调用)

### DOS 功能调用

要条用系统功能的基本格式

```asm
MOV  AH,功能号
设置入口参数
INT  21H
分析出口参数
```

1. `01H` 键入字符

   格式：

   ```asm
   MOV AH, 1H
   INT 21H
   ```

   功能：等待键入一个字符，有回显，并用 `Ctrl + C` 结束输入

   注意：

   1. 入口参数：无
   2. 出口参数：`AL = 按键的 ASCII 码`
   3. 若 AL = 0，表明按键是功能键、光标键，需再次调用此功能，才能返回按键的扩展码

2. `02H` 显示字符

   格式：

   ```asm
   ;在文本屏幕上显示字符 A
   MOV DL, 'A'
   MOV AH, 2H
   INT 21H
   ```

   功能：显示一个字符。本功能在屏幕的当前位置显示一个字符，光标右移一格，如果是在一行末尾显示字符，则光标返回下一行的开始格。如果是在屏幕的右下角显示字符，则光标在返回时屏幕要上滚一行

   注意：

   1. 入口参数：`DL = 待显示字符的ASCII码`
   2. 出口参数：无
   3. 该功能要破坏 AL 寄存器的内容
   4. 注意：将内存中的四位二进制数打印出来时，要先将其转换为对应的`ASCII`码
      1. 数字：`+30H`
      2. 字母（A~F）：`+37H`，因为A是`41H`

3. `09H` 显示字符串

   格式：

   ```asm
   ;在屏幕上显示‘HELLO WORLD!'
   .486
   DATA SEGMENT USE16 			; 定义数据段
   MESG DB 'HELLO WORLD!', '$'
   DATA ENDS
   
   CODE SEGMENT USE16 			; 定义代码段
   ASSUME CS:CODE, DS:DATA
   	BEG: MOV AX, DATA
   		MOV DS, AX
   		LAST: MOV AH, 9
   		MOV DX, OFFSET MESG	; 把 MESG 的首地址给 DX 寄存器
   		INT 21H
   		
   		MOV AH, 4CH
   		INT 21H 			; 返回DOS
   		
   	CODE ENDS
   END BEG
   
   ```

   功能：从屏幕当前位置开始，显示字符串，遇到结束标志 `$` 时停止

   注意：

   1. 入口参数：`DS:DX` 指向字符串首地址，字符串必须以 `$`(即 ASCII 码 24H ) 为结束标志
   2. 会破坏 `AL` 寄存器的内容
   3. 一般搭配末位为`0DH,0AH,'$'`的字符串使用，达到回车换行的目的

4. `0AH` 键入字符串

   格式：

   ```asm
   .486
   
   DATA SEGMENT USE16 				; 定义数据段
   	 	 BUF DB 100
   		 DB ?
   		 DB 10 DUP(?)
   DATA ENDS
   
   CODE SEGMENT USE16 				; 定义代码段
   ASSUME CS:CODE, DS:DATA
   	BEG: MOV AX, DATA
   		MOV DS, AX
   		
   		MOV DX, OFFSET BUF	
   		MOV AH, 0AH				; 功能号 0AH 
   		INT 21H
   		MOV DX, OFFSET BUF+2	; 从"BUF+2"的位置开始键入
   		
   		MOV BX, DX				; 键入字符的个数
   		ADD BL, BUF+1
   		
   		MOV BYTE PTR [BX], '$'	; 间接寻址
   		MOV AH, 09H				; 功能号09H[显示字符串]
   		INT 21H
   		
   		MOV AH, 4CH
   		INT 21H 				; 返回DOS
   		
   	CODE ENDS
   END BEG
   ```

   功能：等待键入一串字符，送用户程序数据缓冲区

   注意：

   1. 入口参数：`DS:DX` 指向放键入字符的缓冲区
   2. 出口参数：存放于缓冲区的字符串，以回车键结尾
   3. 缓冲区定义的第二个字节（从1开始数）由系统设置为输入的字符串的长度
   4. 如果输入的字节数少于定义的字节数，缓冲区其余字节将自动补零
   5. 输入的字节数大于定义的字节数，后来输入的字符被自动被丢弃且响铃警告

### 	BIOS 功能调用

```asm
MOV AH, 功能号
设置入口参数
INT XXH (XXH为 BIOS 功能调用类型号，本课只涉及键盘输入功能调用，所以间断号 = 16H,屏幕显示间断号为10H) 
分析出口参数
```

1. `00H` 读取键入字符

   格式：

   ```asm
   MOV AH, 00H
   INT 16H
   MOV CL, AL 		; 获得键盘输入字符的 ASCII 码, 并放入 CL 寄存器
   ```

   功能：读取键入的一个字符，无回显，响应 `Ctrl+C`，无键入则等待

   注意：

   1. 入口参数：无
   2. 出口参数：`AL` = 键入字符的 ASCII 码。若 `AL` = 0，则 `AH` = 输入键的扩展码

2. `01H` 查询键盘缓冲区

   格式：

   ```
   MOV AH, 01H
   INT 16H
   MOV CL, AL 		; 获得键盘输入字符的 ASCII 码, 并放入 CL 寄存器
   ```

   注意：

   1. 入口参数：无
   2. 出口参数：
      + `Z=0`，表示有输入，键代码仍留在键盘缓冲区中，此时 `AL` = 输入字符的 ASCII 码，`AH` = 输入字符的扩展码。
      + `Z=1`，表示无输入

## 子程序与宏程序

### 子程序及其调用

子程序是相对独立的程序，当程序中要多次完成某一操作时，为了简化整体程序，增强程序可读性，常常把“完成某一操作”设计成一个子程序以供调用

1. 子程序用`PROC/ENDP`分界
2. 子程序分为：段内子程序、段间子程序、无参数子程序、有参数子程序
3. 要明确地定义出这个子程序的入口参数和出口参数，使调用者能方便地使用子程序
4. 在子程序中合理地保存主程序和子程序都用到的寄存器和存储单元，以使主程序能正确地运行
5. 对子程序传参使用`M/R/Stack`

### 宏指令及其调用

与C语言的宏命令差不多，都是在编译的时候对代码进行替换。格式如下

```asm
MacroName		MACRO		哑元表
						LOCAL Grade1,Grade2
						MacroBody
						ENDM
```

1. 含有哑元表表示该宏指令带参，用一串逗号间隔形式的参数表（无值符号，调用时用`R/M/N`替换，M无需PTR运算符）
1. `MACRO/ENDM`是宏体的定界语句
1. 在代码段中放置一条宏指令就是宏调用
1. 使用`LOCAL`伪指令解决宏指令中标号重复定义的错误，`LOCAL 标号名表`

以下是一个输入输出字符加了换行宏指令的小程序

```asm
.486
DATA SEGMENT USE16
  BUF  DB ?
DATA ENDS

CRLF MACRO
       MOV AH,2
       MOV DL,0DH
       INT 21H
       MOV DL,0AH
       INT 21H
ENDM

CODE SEGMENT USE16
       ASSUME CS:CODE, DS:DATA
  BEG: 
       MOV    AX,DATA
       MOV    DS,AX             ;赋予段基址
  
       MOV    AH,1
       INT    21H               ;调用DOS键入功能

       MOV    BUF,AL            ;传递给BUF
       MOV    DL,BUF            ;传递给DL

       MOV    AH,2
       INT    21H               ;调用DOS输出功能
       CRLF

       MOV    AH,4CH
       INT    21H               ;结束
CODE ENDS
END BEG
```



### 小结

共同点：

1. 宏指令与子程序都可以简化程序设计,增强程序的可读性

不同点：

1. 子程序调用是由CPU完成的,宏指令调用是在汇编过程中由汇编程序完成的
2. 子程序调用可以减小目标程序的体积,宏指令则不能

## 程序设计举例

### 顺序程序设计

#### 读取字符

> 从键盘输入一个字符并存储到字节变量BUF单元中并输出

分析：用DOS功能调用完成键入，输入的字符保存在`AL`寄存器中；将`AL`中的内容存到定义在数据段的变量`BUF`所指单元中，然后再用DOS 02H功能，（注意其入口参数为DL）输出到屏幕上

```asm
.486
DATA SEGMENT USE16
  BUF  DB ?
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE, DS:DATA
  BEG: 
       MOV    AX,DATA
       MOV    DS,AX             ;赋予段基址
  
       MOV    AH,1
       INT    21H               ;调用DOS键入功能

       MOV    BUF,AL            ;传递给BUF
       MOV    DL,BUF            ;传递给DL

       MOV    AH,2
       INT    21H               ;调用DOS输出功能

       MOV    AH,4CH
       INT    21H               ;结束
CODE ENDS
END BEG
```

### 分支程序设计

#### 分段函数

>根据给定分段函数实现输入输出：
>$$
>y=f(x)=\left\{\begin{array}{cc}
>1 & x>0 \\
>0 & x=0 \\
>-1 & x<0
>\end{array}\right.
>$$

分析：判定符号位$S$和全零位$Z$即可，可以用$ADD\ 0$或者$OR$自己刷新符号位

```asm
.486
DATA SEGMENT USE16
  X      DW ?
  MSG_0  DB '0$'
  MSG_1  DB '1$'
  MSG__1 DB '-1$'
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE,DS:DATA
  BEG: MOV    AX,DATA
       MOV    DS,AX              ;段基址
      
       MOV    X,12               ;设定X的初始值
       MOV    AX,X
       OR     AX,AX              ;利用位运算进行符号位判定  也可使用 ADD AX,0

       JZ     ZERO               ;全0进入
       JNS    PLUS               ;正数进入
  ;负数情况
       MOV    BL,0FFH            ;补码全F为-1
       MOV    DX, OFFSET MSG__1
       JMP    EXIT               ;结束
  ZERO:
       MOV    BL,0
       MOV    DX, OFFSET MSG_0
       JMP    EXIT
  PLUS:
       MOV    BL,1
       MOV    DX, OFFSET MSG_1
  EXIT:
       MOV    AH,09H
       INT    21H                ;字符串输出
      
       MOV    AH,4CH
       INT    21H

CODE ENDS
END BEG
```

#### 打印二进制数字

> 将BX寄存器的内容以二进制数格式显在屏幕上

思路：通过逻辑左移，每次取最高位，用标识符判定最高位，然后打印。循环数字二进制长度次即可

```asm
.486 
CODE SEGMENT USE16
       ASSUME CS:CODE

  BEG: 
       MOV    BX,5678H  ;初始化要打印的数字
       MOV    CX,16     ;16位
  LAST:
       MOV    DL,'0'    ;默认此位为0
       ROL    BX,1      ;逻辑左移一位
       JNC    NEXT      ;若C标（移出的位）为0进入
       MOV    DL,'1'    ;否则声明此位为1
  NEXT:
       MOV    AH,2H     ;打印
       INT    21H
       LOOP   LAST
       
       MOV    AH,4CH
       INT    21H

CODE ENDS
END BEG
```

### 循环程序设计

#### 求累加和

>求1-10的累加和

思路：利用`LOOP`和`CX`这个天然的整数列，变为从10加到1

```asm
.486
DATA SEGMENT USE16
  SUM  DW ?
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE,DS:DATA
  BEG: ;初始化
       MOV    AX,DATA
       MOV    DS,AX
       MOV    CX,10
       MOV    AX,0
  AGA: 
       ADD    AX,CX
       LOOP   AGA
       MOV    SUM,AX
      
       MOV    AH,4CH
       INT    21H
CODE ENDS
```

#### 禁忌的双重循环

>双重循环：外层循环次数为$N$，内层循环次数为$M$
>
>要求：将`DATA`段中的每个单词改为大写字母
>
>```asm
>data segment
>	db 'ibm             '
>	db 'dec             '
>	db 'dos             '
>	db 'vax             '
>data ends
>```

思路：

1. **小写字母改大写字母**可以用`AND 11011111B`即将$D_5$置0；反之，**大写字母变小写字母**只用`OR 00100000B`将$D_5$置1即可
2. 使用4*3的二重循环，先定位行，再定位列。例如，先定位第一行，再循环修改前三列，再定位下一行，循环修改前三列…所以这里应该要使用`[BX+SI]`这种基址变址寻址的方式，用`BX`定位字符串，用`SI`定位字符
3. :star:值得注意的是，每次开始内层循环时，必须将外层循环的`CX`保存在栈中。在执行外层`LOOP`指令前恢复`CX`

```asm
DATA SEGMENT
       DB 'IBM             '  ;长度为3+13
       DB 'DEC             '
       DB 'DOS             '
       DB 'VAX             '
DATA ENDS
STACK SEGMENT         ;定义堆栈段，容量为16BYTE
        DB 16 DUP(?)
STACK ENDS

CODE SEGMENT
        ASSUME CS:CODE,DS:DATA,SS:STACK
  START:
        MOV    AX,STACK
        MOV    SS,AX
        MOV    SP,16                     ;初始化堆栈
	
        MOV    AX,DATA
        MOV    DS,AX
        MOV    BX,0                      ;BX指向字符串首地址
	
        MOV    CX,4                      ;外层循环次数为4

  S0:   PUSH   CX                        ;外层循环的CX值压栈
        MOV    SI,0                      ;变址寄存器SI指向第一个字符
        MOV    CX,3                      ;内层循环次数为3

  S:    MOV    AL,[BX+SI]                ;变址寻址
        AND    AL,11011111B              ;将小写字母转换为大写字母
        MOV    [BX+SI],AL
        INC    SI                        ;变址寄存器SI指向下一个字符
        LOOP   S                         ;内层继续循环

        ADD    BX,16                     ;BX指向下一个字符串
        POP    CX                        ;从栈顶弹出原CX的值，恢复CX
        LOOP   S0                        ;外层循环的LOOP指令将CX中的计数值减1

        MOV    AX,4C00H
        INT    21H
	
CODE ENDS
END START
```

#### 寻找最大字符

>假设从BUF单元开始为一个字符串ASCII码，找出其中的最大数送屏幕显示

思路：

1. 由于只有一个字符串，所以寻址直接使用基址寻址`[BX]`即可
2. 统计字符串长度以确定循环次数`CX`

```asm
.486
DATA SEGMENT USE16
  BUF     DB 'QWERTYUOIOPASDFGHJKLZXCVBNM1234567890'
  BUF_LEN =  $-BUF                                    ;字符串长度
  MSG     DB 'The max number is : $'
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE,DS:DATA
  BEG: 
       MOV    AX,DATA
       MOV    DS,AX
       MOV    AL,0             ; AL存放最大字符，初始化为最小值0
       MOV    CX,BUF_LEN       ; CX存放字符串长度
       LEA    BX,BUF           ; BX指向字符串首地址

  LAST:
       CMP    AL,[BX]          ; 比较AL和字符串中的字符
       JAE    NEXT             ; 如果AL大于等于字符串中的字符，跳转到NEXT
       MOV    AL,[BX]          ; 否则将字符串中的字符赋值给AL
  NEXT:
       INC    BX               ; BX指向下一个字符
       LOOP   LAST             ; 循环

       MOV    DX,OFFSET MSG    ; 设定出口参数DX
       MOV    MSG+19,AL        ; 将最大字符存放到MSG中
       MOV    AH,09H           ;显示结果
       INT    21H
       MOV    AH,4CH
       INT    21H
CODE ENDS
END BEG
```

### 数制转换

#### 二进制数显示

要求键盘输入一位数（0~9），转换为等值的二进制数显示

```asm
.486
DATA SEGMENT USE16
  MESG1 DB 'Please Enter ! ',0DH,0AH,'$'
  MESG2 DB 'Error ! $'
DATA ENDS
CODE SEGMENT USFE16
        ASSUME CS:CODE,DS:DATA
  BEG:  MOV    AX,DATA
        MOV    DS,AX            ;段寄存器
        MOV    AH,9
        MOV    DX,OFFSET MESG1
        INT    21H              ;显示操作提示

        MOV    AH,1
        INT    21H              ;键入一个字符，存入AL

        CMP    AL,3AH
        JNC    ERROR            ;＞'9'转
        CMP    AL,30H
        JC     ERROR            ;＜'0'转

        SUB    AL,30H
        MOV    BL,AL            ;BL=0~9 的二进制数

        MOV    AH,2
        MOV    DL,'='
        INT    21H
        CALL   DISP
        MOV    AH,2
        MOV    DL,'B'
        INT    21H
        JMP    EXIT
  ERROR:MOV    AH,9
        LEA    DX, MESG2
        INT    21H
  ;显示错误信息
  EXIT: MOV    AH,4CH
        INT    21H

DISP PROC                       ;显示BL中的二进制数
        MOV    CX,8
  LAST: MOV    DL,'0'
        RCL    BL,1
        JNC    NEXT
        MOV    DL,'1'
  NEXT: MOV    AH,2
        INT    21H
        LOOP   LAST
        RET
DISP ENDP

CODE ENDS
END     BEG   
```

#### 二进制数转十六进制数显示

从内存`BNUM`单元开始，有4个16位的二进制数，要求把它们转换成16进制数，并送屏幕显示。

思路：因为每组16进制数的长度是4*4 = 16位，所以这里在大循环的时候，使用`EDX`存放每一组数字，并先令其左移16位方便后续循环操作。后续的小循环操作简而言之就是：

1. 每次循环左移4位，这样要解析的字符就到DL的低四位中，并通过一个`AND`取数值
2. 取出数制后，根据其大小进行`+30H`和`+37H`
3. 保存其值到输出缓冲区`[SI]`，如此往复，直到计数器为0

```asm
;对内存中的二进制数转换为16进制数
.486
DATA SEGMENT  USE16
  BNUM  DW 0001001000110100B  ;1234H
        DW 0101011001111000B  ;5678H
        DW 0001101000101011B  ;1A2BH
        DW 0011110001001101B  ;3C4DH
  BUF   DB 4 DUP(?), 'H$'     ;输出缓冲区
  COUNT DB 4
DATA ENDS

CODE SEGMENT  USE16
           ASSUME CS:CODE, DS:DATA
  BEG:     MOV    AX,DATA
           MOV    DS,AX             ;初始化
           MOV    CX,4              ;外层大循环为4个数
           MOV    BX,OFFSET BNUM    ;BX作为基址寄存器，指向各个二进制数的首地址
  AGA:     MOV    DX,[BX]
           SAL    EDX,16            ;算术左移(事实上随意左移即可，因为目的是将其数字位于最高位)16位，将低16位移到高16位
           CALL   N2_16ASC          ;调用函数后，缓冲区中有一组十六进制数
           MOV    AH,9
           MOV    DX,OFFSET BUF
           INT    21H               ;输出一组十六进制数

           ADD    BX,2              ;地址加 2，指向下一个二进制数
           LOOP   AGA               ;循环4（CX）次
           MOV    AH,4CH
           INT    21H
  ;二进数→十六进数ACSII码
N2_16ASC PROC
           MOV    SI,OFFSET BUF
  ;输出缓冲区地址→SI
           MOV    COUNT,4           ;重置COUNT为4，因为每组16进制数有4个字符
  LAST:    ROL    EDX,4             ;循环左移4位
           AND    DL,0FH            ;00001111B  ;取低4位置入DL
           CMP    DL,10             ;令DL与10比较
           JC     NEXT              ;如果DL<10，则跳转到NEXT
           ADD    DL,7              ;如果DL>=10，则准备+37H变为字母的ASCII
  NEXT:    ADD    DL,30H            ;DL+30H
           MOV    [SI],DL           ;将数字保存到输出缓冲区
           INC    SI                ;输出缓冲区地址加1
           DEC    COUNT             ;计数-1
           JNZ    LAST              ;如果计数不为0，则跳转到LAST
           RET
N2_16ASC ENDP
CODE ENDS
END           BEG
```

#### 二进制数转十进制数显示

思路：**比较法！**比如8位二进制数最大为$11111111B$即$255$，那么可以通过判断二进制数含有几个100，几个10，几个1来对其进行输出

```asm
.486
CMPDISP MACRO    NN         ;宏定义
          LOCAL LAST, NEXT  ;定义局部标号
          MOV   DL,0        ;DL清0
  LAST:   CMP   BEN, NN     ;比较
          JC    NEXT        ;BEN＜NN，跳转到NEXT
          INC   DL          ;DL加1
          SUB   BEN, NN     ;BEN减去NN
          JMP   LAST        ;循环
  NEXT:   ADD   DL, 30H
          MOV   AH,2
          INT   21H         ;显示
ENDM
CODE SEGMENT  USE16
       ASSUME  CS:CODE
  BEN  DB      10101110B  ;=174
  BEG: CMPDISP 100        ;调用宏判断并输出100的个数
       CMPDISP 10         ;调用宏判断并输出10的个数
       CMPDISP 1          ;调用宏判断并输出1的个数
       MOV     AH,4CH
       INT     21H
CODE ENDS
END BEG
```

### 实验内容

#### 统计字符串

从`BUF`单元开始存有一字符串（长度<255），编程实现统计该字符串中的`ASCII`在$42H～45H$之间的字符个数，并将统计结果以二进制形式显示在屏幕

```asm
.486 
DATA SEGMENT USE16
  HINT    DB 'the BUF is QWERTYUOIOPASDFGHJKLZXCVBNM1234567890',0DH,0AH,'$'
  BUF     DB 'QWERTYUOIOPASDFGHJKLZXCVBNM1234567890'
  BUF_LEN =  $-BUF                                                               ;字符串长度
  MSG     DB 'The number of char that between 42H(B) to 45H(E) =  ',0DH,0AH,'$'
DATA ENDS

CODE SEGMENT USE16
       ASSUME CS:CODE,DS:DATA
  BEG: 
       MOV    AX,DATA
       MOV    DS,AX
       MOV    DX, OFFSET HINT
       MOV    AH,09H
       INT    21H
       

       MOV    CX,BUF_LEN         ; CX存放字符串长度
       LEA    BX,BUF             ; BX指向字符串首地址
       MOV    AL,0               ; ans


  LAST:
       CMP    BYTE PTR [BX],42H  ;注意指定大小，否则BX默认为WORD
       JC     NEXT               ;低于42H则转移
       CMP    BYTE PTR [BX],45H  ;注意指定大小，否则BX默认为WORD
       JA     NEXT               ;高于45H则转移
       INC    AL                 ;答案+1
  NEXT:
       INC    BX                 ; BX指向下一个字符
       LOOP   LAST               ; 循环

       ADD    AL,30H             ;将数字转换为字符
       MOV    DX,OFFSET MSG      ; 设定出口参数DX
       MOV    MSG+51,AL          ; 将最大字符存放到MSG中

       MOV    AH,09H             ;显示结果
       INT    21H
       MOV    AH,4CH
       INT    21H
CODE ENDS
END BEG
```

#### 编写登录验证程序

程序执行后，给出提示操作，请用户键入用户名和密码；用户在键入密码时，程序不回显键入字符而是显示`*`；只有当用户键入的用户名，密码字符串和程序内定的字符串相同时，显示欢迎界面并返回DOS；否则给出提示信息，用户名或密码错误，再次输入

```asm
;编写登录验证程序
.486
DATA SEGMENT USE16
  USERNAME1    DB  30,?,30 DUP(?)                     ;定义字符串，规定第二个字节为字符串长度
  USERNAME2    DB  'B20030620'
  LEN_USERNAME EQU $-USERNAME2                        ;计算字符串长度
  PASSWORD1    DB  30 DUP(?)                          ;定义字符串
  PASSWORD2    DB  'PASSWORD'
  LEN_PASSWORD EQU $-PASSWORD2                        ;计算字符串长度
  PROMOTE1     DB  'Please input username:$'
  PROMOTE2     DB  'Please input password:$'
  PROMOTE3     DB  'Login success!$'
  PROMOTE4     DB  'Login failed!please try again!$'
  FLAG         DB  'Y'
DATA ENDS

;宏指令显示回车
CRLF MACRO
       MOV AH,2
       MOV DL,0DH
       INT 21H
       MOV DL,0AH
       INT 21H
ENDM
;宏指令显示字符串
PRINTSTR MACRO STR
           MOV AH,9
           LEA DX,STR
           INT 21H
ENDM
;宏指令显示字符
PRINTCHAR MACRO CHAR
            MOV AH,2
            MOV DL,CHAR
            INT 21H
ENDM
CODE SEGMENT USE16
         ASSUME    CS:CODE,DS:DATA,ES:DATA

  BEG:   
         MOV       AX,DATA
         MOV       DS,AX
         MOV       ES,AX                    ;INIT
         MOV       FLAG,'Y'                 ;初始化标志位
         MOV       CX,LEN_USERNAME
         PRINTSTR  PROMOTE1                 ;提示输入用户名

         MOV       AH,0AH
         MOV       DX,OFFSET USERNAME1      ;入口函数DX将字符串存入USERNAME1
         INT       21H                      ;键入字符串
         CRLF                               ;显示回车

         MOV       CL,USERNAME1+1           ;CL=字符串长度，第2个字节为输入的字符串的长度
         MOV       CH,0                     ;CH=0
         CMP       CX,LEN_USERNAME          ;比较输入的字符串长度与LEN_USERNAME

         JE        NEXT1                    ;如果相等，就不设置
         MOV       FLAG,'1'                 ;如果不相等，就设置FLAG为N
  ;  JMP       FAIL                     ;DEBUG
  NEXT1: 
         MOV       DI,OFFSET USERNAME2      ;DI指向USERNAME2
         MOV       SI,OFFSET USERNAME1+2    ;SI指向USERNAME1+2
         REPE      CMPSB                    ; 比较字符串
         JE        NEXT2                    ;如果不相等，设置FLAG为N
         MOV       FLAG,'2'                 ;如果相等，继续
  ;  JMP       FAIL                     ;DEBUG
  NEXT2: 

         PRINTSTR  PROMOTE2                 ;提示输入密码
         MOV       BX,0                     ;使用BX统计密码长度
         MOV       SI,OFFSET PASSWORD1      ;SI指向PASSWORD1
  ;使用07H功能键入密码
  GETPW: 
         MOV       AH,00H                   ; 逐个字符输入密码，遇到回车结束输入
         INT       16H
         CMP       AL,0DH                   ;回车输入完毕
         JE        NEXT
         CMP       AL,08H                   ;退格键
         JE        BACK
         MOV       [SI],AL                  ;将输入的字符存入PASSWORD1

         PRINTCHAR '*'                      ;显示*

         INC       SI
         INC       BX                       ; 统计输入密码的长度
         JMP       GETPW
  BACK:  
         CMP       BX,0                     ;如果密码长度为0，就不退格
         JE        GETPW

         MOV       AH,2
         MOV       DL,08H
         INT       21H                      ;显示退格
         MOV       AH,2
         MOV       DL,20H
         INT       21H                      ;显示空格,覆盖*
         MOV       AH,2
         MOV       DL,08H
         INT       21H                      ;显示退格,回到*之前的位置
         DEC       SI
         DEC       BX
         JMP       GETPW
  NEXT:  
         CRLF
         MOV       SI,OFFSET PASSWORD1
  ; ;DEBUG 输出密码
  ;        MOV       CX,BX
  ; DE:
  ;        PRINTCHAR [SI]
  ;        INC       SI
  ;        LOOP      DE
  ;        CRLF
  ; ;输出用户名
  ;        MOV       CL,USERNAME1+1
  ;        MOV       SI,OFFSET USERNAME1+2
  ; DE1:
  ;        PRINTCHAR [SI]
  ;        INC       SI
  ;        LOOP      DE1
  ;        CRLF
  ; ;DEBUG
         CMP       BX,LEN_PASSWORD          ;比较输入的字符串长度与LEN_PASSWORD
         JE        NEXT3
         MOV       FLAG,'3'
  ;  JMP       FAIL                     ;DEBUG
  NEXT3: 
         MOV       CX,BX
         MOV       DI,OFFSET PASSWORD2
         MOV       SI,OFFSET PASSWORD1
  CHECK: 
         MOV       BL,[SI]
         CMP       BL,[DI]
         JNE       CHECKF
         INC       SI
         INC       DI
         LOOP      CHECK

         JMP       NEXT4
  CHECKF:MOV       FLAG,'4'
  ;  JMP       FAIL                     ;DEBUG
  NEXT4: 
         CMP       FLAG,'Y'                 ;如果FLAG为Y，就显示登录成功，否则显示登录失败
         JNE       FAIL
         PRINTSTR  PROMOTE3
         CRLF
         JMP       EXIT
  FAIL:  
  ;输出flag
  ;  PRINTCHAR FLAG
         CRLF
         PRINTSTR  PROMOTE4
         CRLF
         JMP       BEG
  EXIT:  
         MOV       AH,4CH
         INT       21H
CODE ENDS
END BEG
```

