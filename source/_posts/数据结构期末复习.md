---
title: 数据结构期末复习
katex: true
tags:
  - 数据结构
  - 算法
categories: 算法学习
abbrlink: e7c345c1
date: 2021-12-01 12:26:03
---

## 前言

好好好，cxg 又让我水了一篇博客。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211203005405.gif" alt="img" style="zoom:50%;" />

<!--MORE-->

## Introduction

### 基本概念

#### 1. 基本概念

1. 数据：可被计算机识别并加工的对象
2. 数据元素：由数据组成的具有一定意义的基本单位，也称为元素、记录。
3. 数据项：是组成数据元素的不可分割的最小单位

#### 2. 数据结构

+ 逻辑结构
  + 线性结构 -> 学生信息
  + 树形结构 -> 族谱
  + 图结构     -> 地图
  + 集合结构 -> 班级团体
+ 储存结构
  + 顺序存储结构 
  + 链式存储结构

### 抽象数据类型

#### 1. 数据类型

数据类型是性质相同的 **值的集合** 以及定义在该值集上的 **运算集合**，比如整形、字符型等等

#### 2. 抽象数据类型（ADT）

抽象数据类型（ADT）是纯粹理论实体，用于简化描述抽象算法，分类与评价数据结构，形式描述程序设计语言的类型系统。

- 与存放数据的机器无关
- 与数据存储的物理结构无关
- 与实现操作的算法和编程语言均无关

### 算法及分析

#### 1. 算法的特征

+ 输入：有零个或若干个输入
+ 输出：有一个或多个输出
+ 可行性：每一个步骤能能通过基本运算实现
+ 确定性：不会产生二义性
+ 有穷性：算法必须有限步骤后终止

#### 2. 判断算法优劣的标准

+ 正确性
+ 可读性
+ 鲁棒性（健壮性）
+ 高效性

#### 3. 算法的时间复杂度（[OI-WIKI](https://oi-wiki.org/basic/complexity/#_4)）

> 衡量一个算法的快慢，一定要考虑数据规模的大小。所谓数据规模，一般指输入的数字个数、输入中给出的图的点数与边数等等。一般来说，数据规模越大，算法的用时就越长。而在算法竞赛中，我们衡量一个算法的效率时，最重要的不是看它在某个数据规模下的用时，而是看它的用时随数据规模而增长的趋势，即 **时间复杂度**。

算法的运行用时并非完全由输入规模决定，而是也与输入的内容相关。所以，时间复杂度又分为几种，例如：

1. 最坏时间复杂度，即每个输入规模下用时最长的输入对应的时间复杂度。由于输入可以在给定的数据范围内任意给定，我们为保证算法能够通过某个数据范围内的任何数据，一般考虑最坏时间复杂度。
2. 平均（期望）时间复杂度，即每个输入规模下所有可能输入对应用时的平均值的复杂度（随机输入下期望用时的复杂度）。

##### 渐进符号

简单来说，渐进符号忽略了一个函数中增长较慢的部分以及各项的系数（在时间复杂度相关分析中，系数一般被称作“常数”），而保留了可以用来表明该函数增长趋势的重要部分。

###### 大 Θ 符号(上下界)

对于函数 $f(n)$ 和 $g(n)$ ， $f(n)=\Theta(g(n))$ ，当且仅当 $\exists c_1, c_2, n_0 > 0$ ，使得 $\forall n \ge n_0, 0\le c_1\cdot g(n)\le f(n) \le c_2\cdot g(n)$ 。

也就是说，如果函数 $f(n)=\Theta(g(n))$ ，那么我们能找到两个正数 $c_1, c_2$ 使得 $f(n)$ 被 $c_1\cdot g(n)$ 和 $c_2\cdot g(n)$ 夹在中间。

例如， $3n^2+5n-3 =\Theta(n^2)$ , $n\sqrt n + n\log^5 n+m\log m+nm =\Theta(n\sqrt n+m\log m+nm)$ 。

###### 大 O 符号（渐进上界）

 $\Theta$ 符号同时给了我们一个函数的上下界，如果只知道一个函数的渐进上界而不知道其渐进下界，可以使用 $O$ 符号。 $f(n)= O(g(n))$ ，当且仅当 $\exists c, n_0$ ，使得 $\forall n \ge n_0,0\le f(n)\le c\cdot g(n)$ 。

研究时间复杂度时通常会使用 $O$ 符号，因为我们关注的通常是程序用时的上界，而不关心其用时的下界。

需要注意的是，这里的“上界”和“下界”是对于函数的变化趋势而言的，而不是对算法而言的。算法用时的上界对应的是“最坏时间复杂度”而非大 $O$ 记号。所以，使用 $\Theta$ 记号表示最坏时间复杂度是完全可行的，甚至可以说 $\Theta$ 比 $O$ 更加精确，而使用 $O$ 记号的主要原因，一是我们有时只能证明时间复杂度的上界而无法证明其下界（这种情况一般出现在较为复杂的算法以及复杂度分析），二是 $O$ 在电脑上输入更方便一些。

###### 大 Ω 符号（渐进下界）

同样的，我们使用 $\Omega$ 符号来描述一个函数的渐进下界。 $f(n)=\Omega(g(n))$ ，当且仅当 $\exists c, n_0$ ，使得 $\forall n \ge n_0,0\le c\cdot g(n)\le f(n)$ 。

###### 小 o 符号

如果说 $O$ 符号相当于小于等于号，那么 $o$ 符号就相当于小于号。

 $f(n)= o(g(n))$ ，当且仅当对于任意给定的正数 $c$ ， $\exists n_0$ ，使得 $\forall n \ge n_0,0\le f(n)< c\cdot g(n)$ 。

###### 小 ω 符号

如果说 $\Omega$ 符号相当于大于等于号，那么 $\omega$ 符号就相当于大于号。

 $f(n)=\omega(g(n))$ ，当且仅当对于任意给定的正数 $c$ ， $\exists n_0$ ，使得 $\forall n \ge n_0,0\le c\cdot g(n)< f(n)$ 。

##### 主定理 (Master Theorem)

我们可以使用 Master Theorem 来快速求得关于递归算法的复杂度。 假设我们有递推关系式

 $$ T(n) = a T\left(\frac{n}{b}\right)＋ f(n)\qquad \forall n > b $ $

那么

 $$ T(n) = \begin{cases}\Theta(n^{\log_b a}) & f(n) = O(n^{\log_b a-\epsilon}) \\ \Theta(f(n)) & f(n) = \Omega(n^{\log_b a+\epsilon}) \ \\Theta(n^{\log_b a}\log^{k+1} n) & f(n)=\Theta(n^{\log_b a}\log^k n), k\ge 0 \end{cases} $ $

## 线性表

[从零开始的数据结构-线性结构](https://lapras.xyz/2021/03/28/c335c6ca.html)

## 数组和字符串(coming soon)

## 树和二叉树

[从零开始的数据结构-树（上）](https://lapras.xyz/2021/03/28/389e8dec.html)

[从零开始的数据结构-树（下）](https://lapras.xyz/2021/04/01/8022ea89.html)

## 搜索

[从零开始的数据结构-堆](https://lapras.xyz/2021/04/07/170718db.html)

[搜索算法小整理（上）](https://lapras.xyz/2021/10/24/db7ea760.html)

## 散列表(coming soon)

## 图(coming soon)

## 排序(coming soon)

