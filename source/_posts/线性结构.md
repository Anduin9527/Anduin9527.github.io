---
title: 从零开始的数据结构-线性结构
katex: true
tags:
  - 数据结构
  - 算法
categories: 算法学习
abbrlink: c335c6ca
date: 2021-03-28 14:08:35
---

<!--more-->

## 线性表（LinearList）及其实现

**线性表**：同类型元素构成的一种有序序列。

+ 表中元素个数称为线性表的长度
+ 表中无元素时称为空表
+ 表的起始位置称为表头，末位位置则称为表尾

### 线性表的抽象数据类型描述

**类型名称**：线性表List

**数据对象集**：线性表是**n**个元素构成的有序序列

**操作集**:线性表L $\in$ List,整数**i**表示位置,元素x $\in$ ElementType

------

**具体代码见ClassDemo**

#### 存储实现(顺序存储)

```c
typedef int ElementType; // ElementType 可定义为任意类型
typedef struct LNode *List;
struct LNode
{
  ElementType Data[MAXSIZE];
  int Last; // Last 定义线性表的最后一个元素下标
};
//下标从0开始
List PtrL;

L.Data[i];
PtrL->Data[i]; // 访问下标为i的元素
Last+1 //链表长度
```

#### 存储实现(链式存储)

```c
typedef int ElementType; // ElementType 可定义为任意类型
typedef struct LNode *List;
struct LNode
{
  ElementType Data; //数据域
  List Next;        // 下一个链表的地址
};
```

## 特殊的线性表

### 堆栈（Stack）

**类型名称**：堆栈(Stack)

**数据对象集**：一个有0个或多个元素的有穷线性表。

**操作集**：长度为MaxSize的堆栈S$\in$Stack,堆栈元素item $\in$ ElementType

#### 特点

+ 只在一端(栈顶, Top)做插入、删除

+ 插入数据：入栈(Push)

+ 删除数据：出栈(Pop)

+ 后进先出：Last In First Out (LIFO)

#### 存储实现（顺序存储）

```c
typedef int ElementType; // ElementType 暂时定义为 int 类型
typedef struct SNode *Stack;
struct SNode
{
  int MaxSize;
  ElementType *Data; // 存储堆栈元素
  int top;           // 记录栈顶元素下标//从0开始
};

```

+ 值得一提的是数组可以用来同时创建两个栈，从头尾同时向中间逼近

#### 存储实现(链式存储)

```c
typedef int ElementType;
typedef struct SNode *Stack;
struct SNode
{
  ElementType Data;
  Stack Next;
};
```

### 堆栈的应用

#### 前缀表达式转为中缀表达式

+ 运算数相对顺序不变
+ 运算符号顺序发生改变

>需要存储“等待中”的运算符号
>
>要将当前运算符号与“等待中”的最后一个运算符号比较
>
>有括号的情况下需注意优先级的改变

从头到尾读取中缀表达式的每个对象,对不同对象按不同的情况处理：

+ 运算数:直接输出:
+ 左括号:压入堆栈:
+ 右括号:将栈顶的运算符弹出并输出,直到遇到左括号(出栈,不输出)
+ 运算符：
  + 若优先级大于栈顶运算符时,则把它压栈;
  + 若优先级小于等于栈顶运算符时,将栈顶运算符弹出并输出;再比较新的栈顶运算符,直到该运算符大于栈顶运算符优先级为止,然
    后将该运算符压栈;
+ 若各对象处理完毕,则把堆找中存留的运算符一输出

### 队列（Queue）

**类型名称**：队列(Queue)

**数据对象集**：一个有0个或多个元素的有穷线性表。

**操作集**：长度为MaxSize的队列Q$\in$Queue,队列元素item$\in$ElementType

#### 特点

+ 只在一端（队尾/rear）做插入
+ 只在一端（队头/front）做删除
+ 插入数据：入队（Add）
+ 删除数据：出队（Delete）
+ 先进先出：First In First Out (FIFO)

#### 存储实现（顺序存储）

```c
typedef int ElementType;
typedef int Position;
typedef struct QNode *Queue;
struct QNode
{
  ElementType *Data;
  Position front, rear; //队头，队尾指针
  int MaxSize;//只使用MaxSize-1的空间
};
```

+ 值得一提的是数组可以用来创建**循环队列**(类似约瑟夫环的处理方法)以节约空间，但是会存在队列空和满无法区分的情况。此时可以使用一个flag记录上次操作为插入还是删除，或者选择只使用其中n-1的数组空间。

#### 存储实现(链式存储)

```c
typedef int ElementType;
typedef struct QNode *Queue;
struct Node
{
  ElementType Data;
  struct Node *Next;
};
struct QNode
{
  struct Node *rear, *front; //头尾指针指向头尾元素本身
};
```