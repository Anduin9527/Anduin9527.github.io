---
title: 从零开始的数据结构-树（下）
katex: true
tags:
  - 数据结构
  - 算法
  - 树
categories: 算法学习
abbrlink: 8022ea89
date: 2021-04-01 19:21:25
---

## 清明时节雨纷纷，路上行人欲断魂。

![](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092838.jpeg)

强烈推荐配合[VISUALOGO](https://visualgo.net/zh/bst)食用

<!--more-->



## 二叉搜索树（BinarySearchTrees）

### 基本性质

+ 非空左子树的所有键值小于其根结点的键值
+ 非空右子树的所有键值大于其根结点的键值。
+ 二叉查找树的中序遍历可以得到有序的数据流。
+ 左、右子树都是二叉搜索树。
+ 最小元素一定在最左边，最大元素一定在最右边,换言之，最小值的结点一定无左子树，最大值的结点一定无右子树。

### 操作集

```c
BinTree Find(ElementType X, BinTree BST);//返回指定Data结点的指针
BinTree Findmin(BinTree BST);
BinTree Findmax(BinTree BST);
BinTree Insert(BinTree BST);
```

#### 查找

```c
BinTree Find(ElementType X, BinTree BST)
{
  if (!BST)
    return nullptr;
  if (X > BST->Data)
    return Find(X, BST->Right);
  else if (X < BST->Data)
    return Find(X, BST->Left);
  else
    return BST;
}
BinTree Findmin(BinTree BST)
{
  if (BST)
    while (BST->Left)
      BST = BST->Left;
  return BST;
}
BinTree Findmax(BinTree BST)
{
  if (BST)
    while (BST->Right)
      BST = BST->Right;
  return BST;
}
```

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092840.gif" alt="GIF 2021-4-1 20-20-50" style="zoom:50%;" />

#### 插入

```c
BinTree Insert(ElementType X, BinTree BST)
{
  if (!BST)
  {
    BST = new TreeNode;
    BST->Data = X;
    BST->Left = BST->Right = nullptr;
  }
  else
  {
    if (X < BST->Data)
      BST->Left = Insert(X, BST->Left);
    else if (X>BST->Data)
      BST->Right = Insert(X, BST->Right);    
  }
  return BST;//空则返回空，相等则不插入
}
```

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092842.gif" alt="GIF 2021-4-1 20-25-35" style="zoom:50%;" />

#### 删除

前面的查找和插入都比较容易，但是对于删除我们得分析一波：

+ 删除的结点是叶结点：EZ,直接删除，并且将其父结点的指针指向为nullptr。
+ 删除的结点有一个子结点：EZ，将其父结点的指针指向其子结点后删除。
+ 发现以上两种情况可以合并：即将父节点指向该节点的子结点（）
+ 删除的结点有两个子结点：
  + 法1：取左子树中最大值替换该结点
  + 法2：取右子树中最小值替换该节点
  + 这样我们就将二子结点变为了有0/1个子结点的情况,而后就可以递归来实现我们的操作

```c
BinTree Delete(ElementType X, BinTree BST)
{
  BinTree Temp;
  if (!BST)
    printf("要删除的元素未找到");
  else
  {
    if (X < BST->Data)
      BST->Left = Delete(X, BST->Left); //向左递归
    else if (X > BST->Data)
      BST->Right = Delete(X, BST->Right); //向右递归
    else
    {
      /* 如果被删除结点有左右两个子结点 */
      if (BST->Left && BST->Right)
      {
        Temp = Findmin(BST->Right); // 从右子树中找最小的元素填充删除结点
        BST->Data = Temp->Data;
        BST->Right = Delete(Temp->Data,BST->Right);//删除右子树中最小的结点,并将结果树接回来
      }
      else
      { /* 被删除结点有一个或无子结点 */
        Temp = BST;
        if (!BST->Left) 
          BST = BST->Right;
        else 
          BST = BST->Left;
        delete(Temp);
      }
    }
  }
  return BST;
}
```

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092844.gif" alt="GIF 2021-4-1 20-30-15" style="zoom:50%;" />

## 平衡二叉树（BalancedBinaryTree/AVL）

二叉查找树的查找效率在理想状态下是**O(lgn)**，使用该树进行查找总是比链表快得多。但是，该论点并不总是正确，因为查找效率和二叉树的形状息息相关。就像这样：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092846.jpeg" alt="img" style="zoom:50%;" />

### 基本性质

+ 平衡二叉树是二叉搜索树的子集
+ 平衡因子：**左子树高度和右子树高度的差**
+ 非空树的条件下，任意结点的左右子树高度差<=1，即平衡因子只有-1，0，1三种值。
+ 平衡二叉树的搜索期望次数是最低的，换言之他的高度能达到满二叉树的的$log_2n$：

  + 显然$N_1=1,N_2=2,N_3=4$
  + 根据平衡二叉树的定义不难发现高度为h的结点数目最少的平衡二叉树符合: $N_h=N_{h-1}+N_{h-2}+1$
  + 上述公式是不是有种斐波那契数列的既视感？通过简单的列表归纳，最终得到：$N_h=F_{h+2}-1$
  + $F_i     \approx\frac{1}{\sqrt5}(\frac{1+\sqrt5}{2}^i)$
  + $N_h\approx\frac{1}{\sqrt5}(\frac{1+\sqrt5}{2}^{h+2})-1$
+ 由上式很明显可以看出$h\approx log_2n$

### AVL的平衡

显然，当AVL树插入或者删除结点的时候，树的平衡会被打破，换言之会出现+2（插入）或者是-2（删除）的平衡因子。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092848.jpeg" alt="v2-cb3751bc5726d2664787391476e39b25_720w" style="zoom:50%;" />

#### 基本操作

##### 左旋

**逆时针**旋转AVL树的两个结点X和Y，使得父结点被自己的右子结点取代，而自己成为自己的左子结点。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092854.jpeg" alt="v2-47d498a63c57af9f8bd1e469c9f7ceef_r" style="zoom: 67%;" />

+ 左旋可以提高左子树的高度，降低右子树的高度

##### 右旋

**顺时针**旋转AVL树的两个结点X和Y，使得父结点被自己的左子结点取代，而自己成为自己的右子结点。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092852.jpeg" alt="v2-86b10ae6e319bbaadef69e8401dee163_720w" style="zoom:67%;" />

+ 右旋可以提高左子树的高度，降低左子树的高度

品：**左旋拎右左挂右，右旋拎左右挂左**

#### 应用

##### 左左情况（LL）

>不平衡结点A有一个**左**子结点B，而结点B又有一个**左**子结点C。标号1,2,3,4的三角形是各个结点的子树。
>
>在这种局面下，我们以结点A为轴，进行**右旋**操作：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092858.jpeg" alt="img" style="zoom:67%;" />

##### 右右情况（RR）

>不平衡结点A有一个**右**子结点B，而结点B又有一个**右**子结点C。
>
>在这种局面下，我们以结点A为轴，进行**左旋**操作：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092859.jpeg" alt="v2-8b05f1507e7d61a2ada9b7ff6a16dcb3_720w (2)" style="zoom:67%;" />

##### 左右局面（LR）

>不平衡结点A有一个**左**子结点B，而结点B又有一个**右**子结点C。
>
>在这种局面下，我们先以结点B为轴，进行**左旋**操作：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092904.jpeg" alt="v2-4b5478dd38a9bd8970129da504f80c75_720w" style="zoom:67%;" />

>  这样就转化成了左左局面。我们继续以结点A为轴，进行右旋操作：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092908.jpeg" alt="v2-0c207419c8861ffe5909b483aaf7bd1a_720w (1)" style="zoom:67%;" />

##### 右左局面（RL）

>不平衡结点A有一个右子结点B，而结点B又有一个左子结点C。
>
>在这种局面下，我们先以结点B为轴，进行**右旋**操作：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092910.jpeg" alt="v2-46e9e5d75fd6d6fe29681456aa52cfd6_720w" style="zoom:67%;" />

>  这样就转化成了右局面。我们继续以结点A为轴，进行左旋操作：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092913.jpeg" alt="v2-bbeec7d9e0c0b30659e580fb6b324aa7_720w" style="zoom:67%;" />

品：左左右右右左旋，左右右左依次旋

### 操作集

```c
AVLTree SingleLeftRotation(AVLTree A);  //左旋rr
AVLTree SingleRightRotation(AVLTree A); //右旋ll
AVLTree DoubleLeftRightRotation(AVLTree A);//lr
AVLTree DoubleRightLeftRotation(AVLTree A); //rl
```

```c
AVLTree SingleLeftRotation(AVLTree A)
{
  AVLTree B = A->Right;//左旋拎右
  A->Right = B->Left;//左挂右
  B->Left = A;//父变子

  A->Height = Max(getHeight(A->Left), getHeight(A->Right)) + 1;
  B->Height = Max(getHeight(B->Right), A->Height) + 1;
}
AVLTree SingleRightRotation(AVLTree A)
{ /* 注意：A必须有一个左子结点B */
  /* 将A与B做右单旋，更新A与B的高度，返回新的根结点B */
  AVLTree B = A->Left; //右旋拎左
  A->Left = B->Right;  //右挂左
  B->Right = A;        //父变子
  
  A->Height = Max(getHeight(A->Left), getHeight(A->Right)) + 1;
  B->Height = Max(getHeight(B->Left), A->Height) + 1;
  return B;
}
AVLTree DoubleLeftRightRotation(AVLTree A)
{ /* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */
  /* 将A、B与C做两次单旋，返回新的根结点C */
  /* 将B与C做左单旋，C被返回 */
  A->Left = SingleLeftRotation(A->Left);
  /* 将A与C做右单旋，C被返回 */
  return SingleRightRotation(A);
}
AVLTree DoubleRightLeftRotation(AVLTree A)
{ /* 注意：A必须有一个右子结点B，且B必须有一个左子结点C */
  /* 将A、B与C做两次单旋，返回新的根结点C */
  /* 将B与C做右单旋，C被返回 */
  A->Right = SingleRightRotation(A->Right);
  /* 将A与C做左单旋，C被返回 */
  return SingleLeftRotation(A);
}

```

## 哈夫曼树(HaffManTree)/最优二叉树

>哈夫曼树是一类带权路径最短的树。构造这种树的算法最早由哈夫曼提出，这种树在信息检索中很有用。如用于通讯及数据传送中构造传输效率最高的二进制编码（哈夫曼编码），用于编程中构造平均执行时间最短的最佳判断过程。

哈弗曼树的特征就是**带权路径长度(WPL)**最小：

设二叉树有n个叶子结点,每个叶子结点带有权值$W_k$,从根结点到每个叶子结点的长度为$L_k$,则每个叶子结点的带权路径长度之和就是: WPL=$\sum_{k=1}^{n}W_kL_k$

那么最后我们就会得到一个头重脚轻的哈弗曼树。值得一提的是哈夫曼由于没有限定左右子树的顺序，所以**不是唯一**的。

## 哈夫曼树的构建

+ 对结点按照权进行从小到大的排序
+ 选择权最小的两个结点从考虑范围内剔除并合并，产生一个父节点，父节点的权为两结点权之和
+ 把父节点纳入考虑范围 重复上一步骤

不难发现，对结点的排序可以使用 **最小堆** 来实现（最小堆部分的代码见堆）

```c
#include <iostream>
using namespace std;
typedef struct TreeNode *HuffmanTree;
struct TreeNode
{
  int Weight;
  HuffmanTree Left, Right;
};
HuffmanTree Huffman(MinHeap H)
{
  /*假设H->Size个权值已经存在H->E1ements []->Weight里*/
  int i;
  HuffmanTree T;
  BuildMinHeap(H); /*将H->Elements []按权值调整为最小堆*/
  for (i = 1; i < H->Size; i++)
  {                          /*做H->size-1次合并*/
    T = new struct TreeNode; /*建立新结点*/
    T->Left = DeleteMin(H);  /*从最小堆中删除一个结点，作为新中的左子结点*/
    T->Right = DeleteMin(H); /*从最小堆中删除一个结点，作为新中的右子结点*/
    T->Weight = T->Left->Weight + T->Right->Weight;
    Insert(H, T); /*将新插入最小堆*/
  }
  T = DeleteMin(H);
  return T;
}
```

+ O(nlogn)
+ 不存在度为1的结点（构建过程为两个子树的合并）
+ n个叶结点的哈夫曼树有2n+1个结点（$n_0=n_2+1)$

## 哈夫曼编码

上文提及过：哈夫曼编码用于通讯及数据传送中构造传输效率最高的二进制编码。

对于编码我们可以分为 **等长编码**和 **非等长编码**。

显然地，类似ASCII RGB 等等都是等长的。这样可以尽量表示更多的字符，且不会有**二义性**的困扰，但是会造成空间上的浪费，比如我使用000~111等长三位编码表示abcdefgh，但是我的字符大部分都是000代表的a，小部分为111代表h，这样就会造成编码上的冗余情况出现。

考虑非等长编码，我使用0来表示a，111来表示h。还是上述的情况，显然节省了空间，但是会造成二义性。比如010表示的是aba还是ac？对此引入个概念：

**前缀码（peifix code）：任何字符的编码都不是另一字符码的前缀。**

如何实现呢？<del>当然是哈夫曼，不然为什么叫哈夫曼编码？？？</del>

由于哈弗曼树的特点，**所有带有权值的结点只会出现在叶结点处**。规定：**左子结点编码为0，右子结点编码为1**。

这样一来，上层叶结点的权值大（频率高），字节数小、下层叶结点的权值小（频次低），字节数大。

# 参考

https://zhuanlan.zhihu.com/p/53851211

[小灰漫画算法](https://zhuanlan.zhihu.com/p/149548859)

https://blog.csdn.net/FX677588/article/details/70767446