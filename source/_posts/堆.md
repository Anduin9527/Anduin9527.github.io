---
title: 从零开始的数据结构-堆
katex: true
tags:
  - 数据结构
  - 算法
categories: 算法学习
abbrlink: 170718db
date: 2021-04-07 14:36:35
---

实习周摸鱼真不戳啊真不戳

<!--more-->

## 堆（Heap）

## 二叉堆(Binary Heap)

### 基本性质

+ 二叉堆是一棵 **完全二叉树**
+ 每个节点的键值都大于等于/小于等于其父结点的键值。
  + 每个节点的键值都大于等于其父结点键值的堆叫 **小根堆/最小堆**，
  + 每个节点的键值都小于等于其父结点键值的堆叫 **大根堆/最大堆**。
  + [STL 中的 `priority_queue`](https://oi-wiki.org/lang/csl/container-adapter/#_13) 其实就是一个大根堆。

#### 存储实现

选择的是静态数组创建树的方式

```c
typedef int ElementType;
typedef struct HeapNode *MaxHeap;
struct HeapNode
{
  ElementType *Data; //储存堆键值的数组
  int Size;          //堆的当前元素
  int Capacity;      //堆的最大容量
};
```

### 操作集

```c
MaxHeap CtreatHeap(int maxSize);          //创建空堆
void Insert(MaxHeap H, ElementType item); //插入一个元素
ElementType DeleteMax(MaxHeap H);         // 从最大堆H中取出键值为最大的元素，并删除一个结点
void BuildHeap(MaxHeap H);                //建堆
```

#### 插入

以大根堆为例，插入操作要保证插入后的二叉堆也是一颗 **完全二叉树**。显然，我们选择最底层的最右边进行插入，然后令其与其父节点比较，**向上调整**。 值得一提的是，如果当前插入的元素大于堆中的任意元素则需要特判，或者在定义堆时建立了 **哨兵 0**（大于取值范围的最大值）。

```c
void Insert(MaxHeap H, ElementType item)
{
  int i;
  if (IsFull(H)) //堆满
  {
    printf("Heap is Fulled!");
    return;
  }
  for (i = ++H->Size; H->Data[i] < item; i /= 2) //在最小处开始，向上调整
    H->Data[i] = H->Data[i / 2];                 //父结点向下
  H->Data[i] = item;                             //插入
}
```

+ O(logn)

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092927.gif" alt="GIF 2021-4-7 23-19-52" style="zoom:67%;" />

#### 删除

> 删除操作指删除堆中最大的元素，即删除根结点。
>
> 但是如果直接删除，则变成了两个堆，难以处理。
>
> 所以不妨考虑插入操作的逆过程，设法将根结点移到最后一个结点，然后直接删掉。
>
> 然而实际上不好做，我们通常采用的方法是，把根结点和最后一个结点直接交换。
>
> 于是直接删掉（在最后一个结点处的）根结点，**但是新的根结点可能不满足堆性质**……
>
> **向下调整**：在该结点的儿子中，找一个最大的，与该结点交换，重复此过程直到底层。
>
> 可以证明，删除并向下调整后，没有其他结点不满足堆性质。

```c
ElementType DeleteMax(MaxHeap H)
{
  int Parent, Child;
  ElementType MaxItem, X;

  if (IsEmpty(H))
  {
    printf("最大堆已为空");
    return ERROR;
  }

  MaxItem = H->Data[1]; // 取出根结点
  /* 用最大堆中最后一个元素与根节点交换后从根结点开始向下调整 */
  X = H->Data[H->Size--]; // 记录最小值X注意当前堆的规模要减小
  for (Parent = 1; Parent * 2 <= H->Size; Parent = Child)
  {
    Child = Parent * 2;
    if ((Child != H->Size) && (H->Data[Child] < H->Data[Child + 1]))
      Child++; // Child指向左右子结点的较大者

    if (X >= H->Data[Child])
      break; /* 找到了合适位置 */
    else
      H->Data[Parent] = H->Data[Child];//向下调整
  }
  H->Data[Parent] = X;

  return MaxItem;
}
```

+ O(logn)

![GIF 2021-4-7 23-21-02](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092930.gif)

#### 建堆

如果用插入建堆，显然是 O(nlogn)。<del> 那么有没有一种 </del>

再来观察一波插入和删除的操作。发现向上调整和向下调整是两个算法的核心，单独抽象出来看看：

```c
void up(int x) {
  while (x > 1 && h[x] > h[x / 2]) {
    swap(h[x], h[x / 2]);
    x /= 2;
  }
}//自下而上同插入
void down(int x) {
  while (x * 2 <= n) {
    t = x * 2;
    if (t + 1 <= n && h[t + 1] > h[t]) t++;
    if (h[t] <= h[x]) break;
    	std::swap(h[x], h[t]);
    x = t;
  }
}//自上而下同删除
```

+ 考虑使用向上调整：显然复杂度为： $log1+log2+......+logn = O(nlogn)$ <del>(留给读者自证)</del> 证明见 oiwiki
+ 考虑使用向下调整：不是很显然的得出复杂度为： $nlogn-log1-log2......-logn\le O(n)$ 

具体地说明一下：

+ 考虑现在读入一个无序的二叉堆
+ 从最后一个具有子结点的结点开始，向下调整建立子堆
+ 向左移动，重复上述过程

```c
/*----------- 建造最大堆 -----------*/
void PercDown(MaxHeap H, int p)
{ /* 下滤：将H中以H->Data[p]为根的子堆调整为最大堆 */
  int Parent, Child;
  ElementType X;

  X = H->Data[p]; /* 取出根结点存放的值 */
  for (Parent = p; Parent * 2 <= H->Size; Parent = Child)
  {
    Child = Parent * 2;
    if ((Child != H->Size) && (H->Data[Child] < H->Data[Child + 1]))
      Child++; /* Child指向左右子结点的较大者 */
    if (X >= H->Data[Child])
      break; /* 找到了合适位置 */
    else
      H->Data[Parent] = H->Data[Child];
  }
  H->Data[Parent] = X;
}

void BuildHeap(MaxHeap H)
{ /* 调整H->Data[]中的元素，使满足最大堆的有序性  */
  /* 这里假设所有H->Size个元素已经存在H->Data[]中 */
  int i;
  /* 从最后一个结点的父节点开始，到根结点1 */
  for (i = H->Size / 2; i > 0; i--)
    PercDown(H, i);
}
```

<img src="C:%5CUsers%5CAdministrator%5CDesktop%5CGIF%202021-4-7%2023-23-44.gif" alt="GIF 2021-4-7 23-23-44" style="zoom:67%;" />

向上调整 O(nlogn)

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092933.gif" alt="GIF 2021-4-7 23-24-45" style="zoom:67%;" />

向下调整 O(n)

## 参考

https://oi-wiki.org/ds/heap/