---
title: 提高爬虫效率
tags:
  - 爬虫
  - Python
categories: 爬虫学习
abbrlink: ee385c19
date: 2022-07-10 20:54:00
---



## 前言

爬都可以爬

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/xigua.png" alt="99586772_p0" style="zoom: 50%;" />

<!--more-->

## 线程？进程？

简单地来说，**进程** 是 **系统进行资源调度和分配的的基本单位**，是 **资源单位**。比如任务管理器里面管理的就是一堆进程。而 **线程** 则是进程的子任务，**是 CPU 调度和分派的基本单位**，是 **执行单位**。显然一个进程可以有多个线程。

### 线程与进程的小栗子

`Python` 中最简单的一个多线程例子：

```python
from threading import Thread

def func():
  for i in range(500):
    print("Hello new World")

def main():
  t = Thread(target=func)  # 创建新线程并安排任务
  t.start()  # 标记线程为可以启动状态，但具体启动时间由系统决定
  for i in range(500):
    print("Main thread")

if __name__ == '__main__':
  main()
```

或者也可以像 `Java` 中常做的那样，重写一下 `run` 方法

`Python` 中最简单的一个多线程例子：

```
from multiprocessing import Process

def func():
  for i in range(500):
    print("Hello new World")

def main():
  p = Process(target=func)
  p.start()
  for i in range(500):
    print("Main process")

if __name__ == '__main__':
  main()

```

+ 不难发现，API 长得几乎一样
+ 如果想要对函数传参的话，需要使用 `p = Process(target=func,args=(tuple))` 的形式，线程同理

### 线程池和进程池

一次性开辟若干个线程（进程），用户只需要给线程池（进程池）提交任务即可。对于具体的线程调度不需要关心

`Python` 的线程池

```python
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

def fn(name):
  for i in range(1000):
    print(name, i)


if __name__ == '__main__':
  # 创建线程池
  with ThreadPoolExecutor(max_workers=10) as t:
    for i in range(100):
      t.submit(fn, "Thread-" + str(i))
  # 等待所有线程结束，才继续执行守护
  print("ThreadPoolExecutor done")
```

+ 进程池的话，就换成 `ProcessPoolExecutor` 即可

### 使用线程池进行爬取

对 [北京新发地的菜价](http://xinfadi.com.cn/priceDetail.html) 进行一个爬取。首先要分析一下网页，发现他的数据来源是通过更改 `id="current"` 标签的 `value` 值实现的，然后使用网络工具抓包，发现其数据是请求另一个 URL 后进行渲染的。所以我们请求数据页后将数据记录于 csv 文件中。

```python
import requests
import csv
import time

f = open('xinfadi.csv', mode='w', encoding='utf-8')
csvw = csv.writer(f)

def get_one_page(value):
  proxy = {'http': 'http://127.0.0.1:7890',
           'https': 'http://127.0.0.1:7890'}
  url = "http://xinfadi.com.cn/getPriceData.html"
  headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',
    'referer': "http://xinfadi.com.cn/priceDetail.html"}
  data = {
    'current': value}
  resp = requests.post(url, proxies=proxy, headers=headers, data=data)
  resp.encoding = 'utf-8'
  res = resp.json()['list']
  for i in res:
    # 写入csv
    csvw.writerow(i.values())
  print(f'the {value} page done')


if __name__ == '__main__':
  # 计算时间
  start = time.time()
  for i in range(1, 100):
    get_one_page(i)
  end = time.time()
  print(f'总共用时{end - start}')
```

试着爬取 100 页的数据，发现耗时为 68.33s，而数据库有 16000 页。这显然太慢了。所以使用线程池的方式进行一个改写。

```python
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
if __name__ == '__main__':
  # 计算时间
  start = time.time()
  # 使用线程池
  with ThreadPoolExecutor(max_workers=50) as t:
    for i in range(1, 100):
      t.submit(get_one_page, i)
  end = time.time()
  print(f'总共用时{end - start}')
```

使用了 50 个线程的表现为 12s，显然有质的提升

## 协程？

众所周知，当程序处于 I/O 操作时，线程往往会处于堵塞状态。比如用 requests 发请求，或者读写数据库。如果我们能在堵塞状态时也能执行别的事情，那么效率就会提高。协程就是可以当线程堵塞时，选择性地切换到别的任务，提高 CPU 的利用率。所以即使在 **单线程** 的条件下，我们也能看到多个任务 "同时" 进行的现象。

>协程，英文叫作 coroutine，又称微线程、纤程，它是一种用户态的轻量级线程。
>
>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态，即所有局部状态的一个特定组合，每次过程重入时，就相当于进入上一次调用的状态。
>
>协程本质上是个单进程，它相对于多进程来说，无须线程上下文切换的开销，无须原子操作锁定及同步的开销，编程模型也非常简单。
>
>我们可以使用协程来实现异步操作，比如在网络爬虫场景下，我们发出一个请求之后，需要等待一定时间才能得到响应，但其实在这个等待过程中，程序可以干许多其他事情，等到响应得到之后才切换回来继续处理，这样可以充分利用 CPU 和其他资源，这就是协程的优势。

### 多任务异步协程

在`Python`中实现协程，我们需要用到 `asyncio`这个库。下面先介绍一下这个库的一些基本概念

- `event_loop`：事件循环，相当于一个无限循环，我们可以把一些函数**注册**到这个事件循环上，当满足条件发生的时候，就会调用对应的处理方法
- `coroutine`：中文翻译叫协程，在 Python 中常指代**协程对象类型**，我们可以将协程对象注册到时间循环中，它会被事件循环调用。我们可以使用 `async` 关键字来定义一个方法，这个方法在调用时不会立即被执行，而是返回一个协程对象
- `task`：任务，它是对协程对象的进一步封装，包含了任务的各个状态，比如 `running`、`finished` 等，我们可以用这些状态来获取协程对象的执行情况
- `future`：代表将来执行或没有执行的任务的结果，实际上和 `task` 没有本质区别
- 另外，我们还需要了解 `async`/`await` 关键字，它是从 Python 3.5 才出现的，专门用于定义协程。其中，`async` 定义一个协程，`await` 用来挂起阻塞方法的执行

下面举个经典例子来说明协程的含金量

```python
import asyncio
import time

async def func1():
  print('func1')
  await asyncio.sleep(1)
  print('func1')


async def func2():
  print('func2')
  await asyncio.sleep(2)
  print('func2')


async def func3():
  print('func3')
  await asyncio.sleep(3)
  print('func3')


if __name__ == '__main__':
  start = time.time()
  loop = asyncio.get_event_loop()
  tasks = [func1(), func2(), func3()]
  loop.run_until_complete(asyncio.wait(tasks))
  loop.close()
  end = time.time()
  print(f'总共用时{end - start}')
```

1. 将任务声明为协程对象，即使用 `async def` 的方式定义函数。任何调用该函数的行为返回的都是一个 `coroutine object`，而非运行其中的代码。如果想要运行其中的函数，则需要满足进入 `async` 模式且 `coroutine` 变为 `task`
2. 正常的 Python 代码都是 `sync` 也就是同步模式，想要切换到 `async` 模式。我们通常使用 `asyncio.run()`（Python >= 3.7），其参数为一个 `coroutine`，它会自动建立 `event loop` 并把参数 `coroutine` 变为其中的第一个 `task` 开始运行 
3. 能被 `await` 的对象有 3 种：`coroutine`、`task` 和 `future`
4. 当你 `await coroutine` 时， $Don't \ do\  that$ 。直接这样做就与同步别无二致。
5. 所以我们需要直接 `await task`，`event loop` 就直接给出控制权，并在结束时记录返回值。这也就需要我们提前使用 `task = asyncio.create_task(coroutine obj)` 注册一个 `task`
6. 除了上述的`asyncio.run()`的方式，通常的流程应该如下
   1. 使用`loop = asyncio.get_event_loop()`注册事件循环
   2. 使用`task = asyncio.create_task(coroutine obj)`注册任务
   3. 使用`loop.run_until_complete(task)`开始执行

7. 那么如果有很多 `task` 需要注册呢？
   1. 如案例中的`asyncio.wait()`，其返回值是一个元组，包括两个集合，分别表示已完成和未完成的任务。wait第二个参数为一个超时值，达到这个超时时间后，未完成的任务状态变为pending
   2. 或者可以用 `asyncio.gather()`。其会返回一个 `future`，参数为若干个可 `await` 的对象的`list`。`task` 会被注册到 `event loop` 中，如果是 `coroutine` 则首先会被包装成 `task` 再注册到 `event loop` 中。然后返回的 `future` 其目的是告知 `event loop` 需要完成其中所有的 `task` 后才能继续执行。最后返回其中所有 `task` 的 `return` 值按照顺序返回到一个 `list` 中。其与`wait()`的主要区别就在于其任务无法取消，返回值是按照传入参数的顺序返回的结果列表


#### 绑定回调

另外，我们也可以为某个 `task` 绑定一个回调方法

```python
import asyncio
import requests

async def request():
    url = 'https://www.baidu.com'
    status = requests.get(url)
    return status

def callback(task):
    print('Status:', task.result())

coroutine = request()
task = asyncio.ensure_future(coroutine)
task.add_done_callback(callback)
print('Task:', task)

loop = asyncio.get_event_loop()
loop.run_until_complete(task)
print('Task:', task)
```

>这里我们定义了一个 `request` 方法，请求了百度，获取其状态码，但是这个方法里面我们没有任何 `print` 语句。
>
>随后我们定义了一个 `callback` 方法，这个方法接收一个参数，是 `task` 对象，然后调用 `print` 方法打印了 `task` 对象的结果。这样我们就定义好了一个 `coroutine` 对象和一个回调方法。我们现在希望的效果是，当 `coroutine` 对象执行完毕之后，就去执行声明的 `callback` 方法。
>
>那么它们两者怎样关联起来呢？很简单，只需要调用 `add_done_callback` 方法即可。我们将 `callback` 方法传递给封装好的 `task` 对象，这样当 `task` 执行完毕之后，就可以调用 `callback` 方法了。同时 `task` 对象还会作为参数传递给 `callback` 方法，调用 `task` 对象的 `result` 方法就可以获取返回结果了。

### aiohttp

我们仅仅将涉及 IO 操作的代码封装到 `async` 修饰的方法里面是不可行的，必须使用支持异步操作的请求方式才可以实现真正的异步，所以需要使用 `aiohttp`，下面是稍加改动后的官网的例子

```python
import aiohttp
import asyncio

async def fetch(session, url):
  async with session.get(url) as response:
    return await response.text(), response.status

async def main():
  async with aiohttp.ClientSession() as session:
    text, status_code = await fetch(session, "http://httpbin.org/get")
    print(f"text:{text[:100]}")
    print(f"code:{status_code}")

if __name__ == '__main__':
  asyncio.run(main())
```

大体上与 `request.session` 的操作方式相同。首先用 `async with aiohttp.ClientSession() as session:` 注册一个支持异步的上下文客户端会话管理器 `session`，用 `session` 去异步地发送请求 `  async with session.get(url) as response:` 此时可以添加 `params,headers,data,cookies`。最后使用 `await resp.json() or .text() or .read() ` 来得到数据

下面给出一个常用框架：

```python
import aiohttp
import asyncio


def get_tasks(session):
  """
  获取任务列表
  :param 客户端会话
  :return: 任务列表
  """
  tasks = []
  for i in range(30):
    tasks.append(fetch(session))
  return tasks


async def fetch(session):
  """
  异步获取网页的具体过程
  :param 客户端会话
  :return: 网页的数据
  """
  async with session.get('http://httpbin.org/get') as resp:
    # 断言，如果状态码不是 200，则抛出异常
    assert resp.status == 200
    return await resp.json()


async def main():
  results = []
  async with aiohttp.ClientSession() as session:
    tasks = get_tasks(session)
    responses = await asyncio.gather(*tasks)
    print(responses)


asyncio.run(main())
```



## 参考

https://www.kingname.info/2020/03/23/insert-sprit/

https://www.bilibili.com/video/BV1oa411b7c9

https://cuiqingcai.com/202271.html