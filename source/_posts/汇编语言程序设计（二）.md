---
title: 汇编语言程序设计（二）
tags:
  - 笔记
  - 汇编
category: 汇编语言程序设计
katex: true
abbrlink: cdaa62af
---



## 前言

太吾绘卷正式版出了！准备小溜一手！再次推荐王爽老师的《汇编语言》

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220922105447.png" alt="image-20220922105447471" style="zoom:67%;" />

<!--more-->

## 指令概述

>   指令是 CPU 操作的基本单位，每条指令执行一个特定的操作。CPU 全部指令的集合，称为指令集。

+ 机器指令：二进制格式编码的序列（一串 0，1 代码书写）注意：硬件只能识别，存储，运行机器指令
+ 符号指令：用字符串形式的序列（包含字符串形式的操作码以及操作数助记符）表示

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908094246.png" alt="image-20220908094238953" style="zoom:80%;" />

+ 操作码 ：计算机要执行的操作，如：加、减、逻辑与等

+ 操作数 ： 执行操作过程所要操作的数，如加运算的两个加数

+ 标号：标号表示该条指令的 **符号地址**。当该条指令被作为分支或循环等指令的转移目标或作为程序开始执行的首条语句时，需要设置标号，其他情况下则可以忽略，其命名必须以字母开头，与操作码用“:”分隔

+ 注解：以“ ;”开头，不执行

指令的长度：指令在存储器中占用的 **字节数** 称为指令长度。 80X86 指令长度（机器指令长度）为 $1\sim 16$ 字节

指令的地址：多字节指令占用连续的内存单元，存放指令第一字节的内存单元地址，称为 **指令地址**

指令的存放：首先存放操作码，然后存放操作数。多字节操作数连续存放，顺序依据 **小端规则**（Little Endian）即 : 低位字节存放在低地址单元，高位字节存放在相邻的高地址单元

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908095202.png" alt="image-20220908095202646" style="zoom:80%;" />

#### 标志寄存器

> 指令的操作对象除了数据外还包括状态。在大多数情况下，使用标志寄存器中的 **标志位** 来存储状态。标志位分为两种类型：**状态标志** 和 **控制标志**。状态标志用于作为某些指令操作的 **前提状态** 以及指令操作完成后的 **结果状态**。控制标志可以 **设定 CPU 的某些功能**，例如中断；或者设定指令的操作功能，例如串操作指令。控制标志值可以用相应指令进行设定。

80486 作为 32 位微处理器，其有 32 位的 CPU 标志寄存器，但实际只使用 15 位

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908095454.png" alt="image-20220908095454647" style="zoom: 67%;" />

### 状态标志

1. `C(Carry Flag)` 标志：进位\借位标志

   字节/字/双字加减，最高位产生进位\借位时。`C` 标志置 1，否则置 0

   除此之外，无符号数乘法指令、求补指令、移位指令和一部分逻辑运算指令在执行后对 `C` 标志也会产生影响

2. `A(Auxitiary Flag)` 标志：辅助进位\借位标志

   字节/字/双字加减，`D3` 向 `D4` 产生进位\借位时。`A` 标志置 1，否则置 0

   > 从 0 开始数！！！

3. `S(Sign Flag)` 标志：符号标志

   字节/字/双字运算，结果的最高位为 1 时。`S` 标志置 1，否则置 0

   > 这里的最高位，有符号数里是符号位，无符号数是所谓的 $D_{15},D_{7}$，而非进位产生的位

4. `Z(Zero Flag)` 标志：零标志

   运算结果为全 0 时，`Z` 标志置 1，否则置 0

5. `P(Parity Flag)` 标志：奇偶标志

   结果低 8 位中，$1$ 的个数为偶数，则 `P` 标志置 1，否则置 0

6. `O(Overflow Flag)` 标志：溢出标志

   则加数与被加数的最高位相同，却与结果的最高位相异，则 `O` 标志置 1，否则置 0

   > 有符号数运算，判 o 标志，O 标志为 1, 有溢出。
   > 无符号数加/减，判 C 标志，C 标志为 1, 有溢出。

### 控制标志

1. `D(Direction Flag)` 标志：方向标志

   `D` 标志用于在串操作指令中控制字符申指针的调整方向，`D` = 0 时，为增址型调整，即指针由低位地址向高位地址移动；`D` = 1 时，为减址型调整，即指针由高位地址向低地址移动。在执行串操作指令前，使用处理机控制指令 CLD 将 `D` 标志设置为 0，或使用 STD 将 `D` 标志设置为 1

2. `I(Interrupt—enable Flag)` 标志：中断允许标志

   `I` 标志用于控制 CPU 是否响应来自引脚 INTR 的可屏蔽中断请求。`I` 标志为 0 时，CPU 不响应可屏蔽中断请求；`I` 标志为 1 时，CPU 响应可 **屏蔽中断请求**。使用处理机控制指令 CLI 和 STI 设置 `I` 标志，CLI 将 `I` 标志设置为 0，STI 将 `I` 标志设置为 1

3. `T(Tracc Flag)` 标志：陷阱（追踪）标志

   `T` 标志用于控制 CPU 是否以 **单步方式** 执行指令。`T` 标志为 0，CPU 以连续方式执行指令；`T` 标志为 1，CPU 以单步方式执行指令，即每执行一条指令后产生一次单步中断，自动调用中断类型号为 1 的单步中断服务子程序。`T` 标志默认值为 0，需要启动单步操作时，可以通过逻辑运算指令将标志寄存器中的 T 标志位设置为 1

## 寻址方式

>​    操作数是指令的操作对象，寻址方式就是在指令中，**使用特定的助记符**（地址表达式），告知 CPU 如何计算出操作数的地址，从而正确地取出操作数进行后继的指令操作。

1. 操作数包含在 **指令** 中，这种操作数称为 **立即数**
2. 操作数存放在 CPU 的某个 **寄存器** 中，这种操作数称为 **寄存器操作数**
3. 操作数存放在 **存储器** 中，这种操作数称为 **存储器操作数**
4. 操作数存放在 **I/O 端口** 中，这种操作数称为 **I/O 端口操作数**

### 立即寻址方式

​    立即寻址方式所提供的操作数直接放在指令中，紧跟在操作码的后面，与操作码一起放在代码段区域中

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908102207.png" alt="image-20220908102207431" style="zoom:67%;" />

+ 立即寻址的特点就在于其操作数是 **立即数**

  > 所谓 **立即数**，包括常用的 2 进制（后缀 B），8 进制（后缀 Q），16 进制数（后缀 H，若前缀是字母则需补前缀 0），带符号的真值，带单引号的字符（ASCII），简单的算术表达式

### 寄存器操作数寻址

寄存器寻址即将操作数存放在寄存器中，寄存器的名称在指令中的操作数中给出。在寄存器中存取操作数，可以获得较快的访问速度

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908102644.png" alt="image-20220908102644381" style="zoom:67%;" />

### 存储器操作数寻址

存储器操作数寻址也称为 **内存操作数寻址**，操作数存放在存储器中。物理地址是存储器单元在物理空间中的编号，逻辑地址是存储器单元在分段式管理中的逻辑编号。由于程序被装载入存储器中的位置由操作系统在程序载入的时候决定在编写程序时无法确定指令中使用的存储单元在程序载入存储器后的物理地址，**只能使用逻辑地址来描述指令中用到的存储单元**。CPU 在分析指令时使用内部的 **段页式管理部件** 将指令中的逻辑地址转换为对应的物理地址，再通过总线系统访问实际的物理存储单元

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908103013.png" alt="image-20220908103013429" style="zoom:67%;" />

+ 段寄存器名称也称为 **段超越前缀**，表示存放操作数的存储单元所在的逻辑段

  + **代码段** 存放当前正在运行的程序的机器指令，段寄存器为 `CS`

  + **数据段** 存放当前程序中使用的数据，段寄存器为 `DS`

  + **堆栈段** 存放需要具有先进后出特性的数据，段寄存器为 `SS`

  + **附加段** 也用于存放当前程序中使用的数据，段寄存器为 `ES`

+ 在实模式下，CPU 将逻辑地址中的段基址乘以 16 后加上偏移地址就得到了操作数的物理地址，从对应的物理存储单元中存取操作数

根据不同的应用场景，逻辑地址中的偏移地址表达式有 5 种不同的格式，分别对应 5 种存储器操作数寻址方法：直接寻址、寄存器间接寻址、基址寻址、变址寻址和基址加变址寻址。

#### 直接寻址

1. 段寄存器：[偏移地址]

   偏移地址表达式直接给出存储单元的偏移地址值。这种格式允许操作数存放在不同的逻辑段，**段寄存器名称不可以省略**。但手工计算比较烦琐容易出错，一般情况下不建议使用这种书写格式

   比如：`MOV AL, ES:[2CH]`

2. 段寄存器：变量名

   汇编语言中可以使用 **伪指令** 为存储单元命名，即存储单元的变量名，也称为 **符号地址**。汇编器将自动计算出该存储单元的偏移地址。由于变量名中本身蕴涵了其所在逻辑段的名称，因此在书写逻辑地址时，**段寄存器名称可以省略不写**

   比如：`MOV AX, ES:YY ` 可以简写为 `MOV AX, YY`

#### 寄存器间接寻址

​    寄存器间接寻址又称间接寻址，间址。操作数在内存单元，该单元的段基址在 **段寄存器** 中，偏移地址在 **间址寄存器** 中，CPU 首先进行地址计算。

1. 段寄存器：[间址寄存器]

   偏移地址表达式给出的间址寄存器用于存放操作数的 **偏移地址**。注意：只有一些特别指定的通用寄存器能够作为间址寄存器使用

   | 间址寄存器         | 约定访问的逻辑段 | 寻址位数 |
   | ------------------ | ---------------- | -------- |
   | BP                 | 堆栈段           | 16 位     |
   | BX，SI，DI         | 数据段           | 16 位     |
   | EBP，ESP           | 堆栈段           | 32 位     |
   | EAX～EDX，ESI，EDI | 数据段           | 32 位     |

2. [间址寄存器]

   当间址访问的操作数位于的逻辑段就是间址寄存器 **约定访问的逻辑段** 时，逻辑地址中的段寄存器的名称可以省略不写；反之，不可以省略

   > 比如，设数据段 `BUF` 字节单元的内容为 $55H$，取出该数 $\to$ `AL`
   >
   > ```asm
   >mov DS, 数据段段基址
   >mov BX, BUF单元的偏移地址
   >mov AL, DS:[BX]
   >;由于BX间址，约定访问的是数据段，所以DS:可以省略，如下
   >mov AL, [BX]
   >```

#### 基址寻址

该寻址方式的偏移地址由两部分组成。一部分在 **基址寄存器** 中，另一部分为常量

1. 段寄存器：[基址寄存器+位移量]

   偏移地址表达式由基址寄存器和位移量的 **和** 构成。注意：只有一些特别指定的通用寄存器能够作为基址寄存器使用

   | 基址寄存器         | 约定访问的逻辑段 | 寻址位数 |
   | ------------------ | ---------------- | -------- |
   | BP                 | 堆栈段           | 16 位     |
   | BX                 | 数据段           | 16 位     |
   | EBP，ESP           | 堆栈段           | 32 位     |
   | EAX～EDX，ESI，EDI | 数据段           | 32 位     |

2. [基址寄存器+位移量]

   与寄存器间址寻址一样，访问约定的逻辑段时，可以省略段寄存器

   > 比如，设数据段 **BUF** 单元按照地址从低到高依次存放 $78H,56H,34H,12H$，观察下列代码给出 `DH` 和 `DX` 的值
   >
   > ```asm
   >mov DS, 数据段段基址
   >mov BX, BUF单元偏移地址
   >mov DH, [BX+1]; DH = 56H
   >mov DX, [BX+2]; DX = 1234H
   >```

#### 变址寻址

变址寻址，根据有无 **比例因子** 可以分为两种形式

1. 段寄存器：[比例因子*变址寄存器+位移量]

   偏移地址表达式由“比例因子*变址寄存器+位移量”构成。注意：只有一些特别指定的通用寄存器能够作为变址寄存器使用，且比例因子只能是$1,2,4,8$中的一个数

   | 变址寄存器         | 约定访问的逻辑段 | 适用于           |
   | ------------------ | ---------------- | ---------------- |
   | SI，DI             | 数据段           | 无比例因子，16 位 |
   | EBP                | 堆栈段           | 有比例因子，32 位 |
   | EAX～EDX，ESI，EDI | 数据段           | 有比例因子，32 位 |

2. [比例因子*变址寄存器+位移量]

   同样的，访问约定的逻辑段时，段寄存器可以省略

   比如，`mov AH, DS:[4*EBX+3]`，也可以写作 `mov AH, [4*EBX+3]`

3. 段寄存器：[变址寄存器+位移量]

   注意，无比例因子时，只有 `SI` 和 `DI` 能作为变址寄存器使用

4. [变址寄存器+位移量]

   同样的，访问约定的逻辑段时，段寄存器可以省略

   比如，`mov AH, SS:[SI+3]`，也可以写作 `mov AH, [SI+3]`

#### 基址加变址寻址

基址加变址寻址方式也称为 **基加变寻址方式**，是基址寻址和变址寻址两种寻址方式的结合，根据是否带有比例因子，也有两种书写格式。实际编程中，基址加变址寻址方式由于有基地址和变址地址两个参数，特别适合表示 **二维下标**，对二维数组进行访问。使用了位移量的基址加变址寻址方式，常用于对 **结构体数据** 进行访问，此时用基地址定位结构体，用位移量定位结构体中的数据项，用变址地址定位数据项中的每个元素

1. 段寄存器：[基址寄存器+比例因子*变址寄存器+位移量]
2. [基址寄存器+比例因子*变址寄存器+位移量]
3. 段寄存器：[基址寄存器+变址寄存器+位移量]
4. [基址寄存器+变址寄存器+位移量]

## 汇编语言语法规则

### 语句类型和格式

汇编语言源程序包括的语句类型为：**指令性语句** 和 **指示性语句**，指令性语句即 **符号指令**，指示性语句包括 **伪指令** 和 **宏指令**（比较特殊，第四章介绍）

符号指令：即经汇编后，转换为对应的机器指令供 CPU 读取并解析执行，其格式为：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220913102114.png" alt="image-20220913102107685" style="zoom: 67%;" />

伪指令：是非机器指令，是在汇编链接期间进行操作的。为汇编程序，链接程序提供汇编链接信息，其格式为：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220913102142.png" alt="image-20220913102142468" style="zoom:67%;" />

> 标号名、变量名命名规则：以除数字以外的字母或符号开头, 后跟字母、数字…长度 $\le 31$ 个字符

### 常用伪指令

1. 数据定义伪指令

   1. 字节定义伪指令 `DB`（Define Byte）
      格式：变量名+`DB`+一个或多个用逗号间隔的单字节数

      > 可以使用长度符合的立即数
      >
      > 可以使用字符串，等效于多个字符型的立即数
      >
      > 可以使用随机数或者使用重复器 `DUP`
      >
      > `DUP` 前面是重复的次数，括号内为生成的数据（可以为?）
      >
      > ```asm
      >N1 DB ?,?,?; 生成三个随机单字节数
      >N2 DB 3DUP('A');生成三个以逗号分隔的'A'
      >```

   2. 字定义伪指令 `DW`（Define Word）
      格式：变量名+`DW`+一个或多个用逗号间隔的双字节数

      > 注意多字节存入内存时的顺序：先低位再高位
      >
      > 注意传入的立即数如果长度过短，会自动补前缀 0
      >
      > 注意如果传入的立即数使用 16 进制表示且前缀为字母，需要手动添加前缀 0，防止与变量混淆

   3. 双字定义伪指令 `DD`（Define Double）

      格式：变量名+`DD`+一个或多个用逗号间隔的四字节数

      > 变量名 DF 一串用逗号间隔的 6 字节数
      > 变量名 DQ 一串用逗号间隔的 8 字节数
      > 变量名 DT 一串用逗号间隔的 10 字节数

2. 符号定义伪指令

   源程序中使用到表达式时，直接用符号名即可，**汇编** 后符号名将替换为表达式的常数值

   1. 等值伪指令 `EQU`

      格式：符号常数 + `EQU` + 表达式

   2. 等号伪指令 `=`

      格式：符号常数 + `=` + 表达式

   > 两个指令的区别：
   >
   > 用 `EQU` 定义的符号常数，其值在后继语句中 **不能更改**
   >
   > 用 `=` 定义的符号常数，其值在后继语句中 **可以重新定义**

### 常用运算符

1. `$` 运算符

   功能：`$` 运算符可以返回汇编地址计数器的当前值，通常使用 `$` 运算符计算变量在逻辑段中占用的字节总数

   ```asm
   BUF DB 'THE  QUICK  BROWN  FOX';字符串长度19
   LLL EQU $-BUF;汇编后符号常数LLL的值即为19
   ```

2. `SEG` 运算符

   格式：`SEG`+段名/变量名/标号名

   功能：计算某一逻辑段的 **段基址**

   ```asm
   MOV AX,SEG BUF;变量BUF是堆栈段中的存储单元，假设堆栈段的段基址为2000H，则(AX) = 2000H
   ```

   > 注意：段名本身含有段基址的信息，所以如果是提取段名的段基址可以省略 `SEG`

3. `OFFSET` 运算符

   格式：`OFFSET`+变量名/标号名

   功能：算出逻辑段中某个变量或标号所在单元相对于段首的 **偏移地址**

   ```asm
   MOV AX,SEG DATA  ;获取数据段段基址，本处SEG可省略
   MOV DS,AX        ;指定数据段段基址
   MOV BX,OFFSET BUF;获取变量BUF的偏移地址，假设为12H
   MOV AL,[BX]      ;用[]提取偏移地址内容，此处省略了DS:
   ```

4. `PTR` 运算符

   > 汇编语言规定在读写存储器操作数时，**指令中的源操作数和日标操作数的类型属性必须一致**，在出现不一致的情况下，可以使用 `PTR` 运算符临时修改其中的存储器操作数，即变量的属性，**使源目两个操作数类型属性一致**。另外，PTR 运算符也可用于修改标号的类型属性。
   >
   >> 操作数类型：BYTE（字节）、WORD（字）、DWORD（双字）
   >>
   >> 标号类型：FAR（远）、NEAR（近）
   >
   > 特别注意：这样的强制修改是临时性的，仅在使用 `PTR` 运算符的指令中发挥作用，指令执行完毕后变量的类型属性仍然保持原有的属性不变。

   格式：类型说明符+`PTR`+地址表达式 

   功能：

   1. 指令的操作数至少有一个类型属性要确定，否则必须用 PTR 运算符说明其中的内存操作数的类型

   2. 若两个操作数的类型属性都确定，则必须保持一致。否则必须用 PTR 运算符改变其中的内存操作数的类型，以保持前后属性一致

      > 类型属性确定的操作数：寄存器（长度固定），变量名直接寻址的操作数（变量定义的时候长度固定）
      >
      > 类型属性不确定的操作数：立即数，非变量名直接寻址的操作数（间址、基址、变址、变基、偏移地址的直接寻址）

   ```asm
   BUF DB 11H,22H,33H,44H
   WBUF DW ?,?
   XX DB 0FFH,0
   
   MOV AX,BUF ;原目操作数类型都确定，源为字，目为字节，不一致X
   MOV AL,BUF ;原目操作数类型都确定，源为字节，目为字节，一致
   MOV AX,WORD PTR BUF    ; AH=22H，AL=11H
   
   MOV BUF,1234H ;源操作数类型为字节，目标操作数为字，不一致
   MOV WORD PTR BUF,1234H  ;BUF单元为34H，BUF+1单元为12H
   
   ```

   

## 80486 基本指令集

> 为了说明方便，作出以下约定
>
>+ N 代表立即数，N8、N16、N32 代表 8、16、32 位立即数
>
>+ R 代表寄存器操作数，R8、R16、R32 代表 8、16、32 位寄存器操作数
>
>+ M 代表内存操作数，M8、M16、M32 代表 8、16、32 位内存操作数
>
>+ S 代表段寄存器
>+ OP 代表操作数
>+ DO 代表目标操作数
>+ SO 代表源操作数

注意：

1. 对于双操作数指令
   1. 源、目操作数不可同为 `M` 或 `S`
   2. 源、目操作数属性（长度）一致
   3. 当目标操作数为间址、变址、基址、基+变址的内存操作数，而源操作数为单字节/双字节立即数，则目标操作数必须用 `PTR` 说明类型
2. 对于单操作数指令
   若操作数为间址、变址、基址、基+变址的内存操作数，则必须用 PTR 说明类型

### 传送类指令

​    传送类指令执行后，不影响状态标志，主要包括通用传送类指令和堆栈操作指令

#### 通用传送类指令

1. `MOV` 数据传送指令

   格式：`MOV DO, SO`

   功能：将 `SO` $\to $ `DO`，`SO` 不变

   `MOV` 指令指令支持的类型还是比较宽泛的，但注意：

   1. 不允许向 `S` 写入 `N`（需要寄存器中转）
   2. 不允许向 `S` 写入 `S`
   3. 不允许向 `M` 写入 `M`
   4. `CS`（指令段寄存器）不允许作为 `DO`

2. `MOVSX` 符号扩展指令

   格式：`MOVSX R, SO`

   功能：将 `SO` $\to $ `DO`，将源操作数向高位进行扩展，**用符号位进行填补**，使其与目标操作数的字长相
   同后再传送到目标操作数，源操作数不变

   注意：`SO` 只能为 `R`，`DO` 只能为 `R/M`

3. `MOVZX` 符号扩展指令

   格式：`MOVZX R, SO`

   功能：将 `SO` $\to $ `DO`，将源操作数向高位进行扩展，**用 0 进行填补**，使其与目标操作数的字长相
   同后再传送到目标操作数，源操作数不变

   注意：`SO` 只能为 `R`，`DO` 只能为 `R/M`

4. `LEA` 有效地址传送指令

   格式：`LEA R16/R32, M`

   功能：计算内存单元的有效地址 $\to$ `DO`

   注意：有效地址其实就是其偏移地址，所以 `LEA BX, BUF` 等价于 `MOV BX, OFFSET BUF`

5. `XCHG` 交换传送指令

   格式：`XCHG OP1, OP2`

   功能：完成两个操作数的互换

   注意：`OP1` 和 `OP2` 只能同为 `R` 或者 `R+M`

#### 堆栈操作指令

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220915104649.png" alt="image-20220915104642074" style="zoom: 67%;" />

+ 堆栈段寄存器 `SS`：存放堆栈段段基址
+ 堆栈指针 `SP`：存放栈顶单元的偏移地址
+ 堆栈指针 `SP` 的初值决定了堆栈的大小，SP 始终指向堆栈的顶部，即始终指向最后压入堆栈的信息所在的单元
+ 8086 的堆栈是向低地址方向延伸的，栈顶是 **浮动** 的，且一次进栈、出栈的数据至少是 2 字节。与正常的写入内存一直，保证高字节对（内存）高地址，低字节对（内存）低地址

1. `PUSH` 进栈指令

   格式：`PUSH SO`

   功能：将 `SO` 压入堆栈。操作过程是 **先将堆栈指针向低地址方向进行调整，然后将操作数送入堆栈指针指向的栈顶单元中**。当 `SO` 是字时，`SP` 的调整方法为 $(SP)-2\to (SP)$，放入堆栈中的字占用堆栈的 2 个字节单元

   注意：

   1. `SO` 可以是 `N16/32, R16/32, M16/32 S`（除了 `CS`）
   2. 当 `SO` 是 `M` 时，根据需要加上 `PTR` 运算符

2. `POP` 出栈指令

   格式：`POP DO`

   功能：从堆栈中弹出一个字或双字，将其送入 `DO`。操作过程是 **先将堆栈中取出的字或双字送入 `DO`，然后将堆栈指针向高地址方向进行调整**。当 `DO` 是字时，从堆栈中取出一个字，即 2 个字节，`SP` 的调整方法为 $(SP)+2\to (SP)$

   注意：

   1. `DO` 可以是 `R16/32, M16/32 S`（除了 `CS`）
   2. 当 `DO` 是 `M` 时，根据需要加上 `PTR` 运算符

### 算术运算类指令

| 分类           | 名称           | 格式         | 功能           | O S Z A P C   |
| -------------- | -------------- | ------------ | -------------- | ------------- |
| 加法指令       | 加法指令       | ADD   DO, SO | 加法           | O S Z   A P C |
|                | 带进位加法指令 | ADC   DO, SO | 带进位加法     | O S Z   A P C |
|                | 加 1 指令      | INC   OP     | 加 1           | O S Z   A P   |
| 减法指令       | 减法指令       | SUB   DO, SO | 减法           | O S Z   A P C |
|                | 带借位减法指令 | SBB   DO, SO | 带借位减法     | O S Z   A P C |
|                | 减 1 指令      | DEC   OP     | 减 1           | O S Z   A P   |
|                | 比较指令       | CMP DO, SO   | 比较           | O S Z   A P C |
|                | 求补指令       | NEG   OP     | 求补码         | O S Z   A P C |
| 乘法指令       | 无符号数乘法   | MUL   SO     | 不带符号数乘法 | O        C    |
|                | 带符号数乘法   | IMUL   SO    | 带符号数乘法   | O        C    |
| 除法指令       | 无符号数除法   | DIV   SO     | 不带符号数除法 | 不影响        |
|                | 带符号数乘法   | IDIV   SO    | 带符号数除法   | 不影响        |
|                | 符号扩展指令   | CBW（了解）  | 扩展 AL 中的符号 | 不影响        |
|                | 符号扩展指令   | CWD（了解）  | 扩展 AX 中的符号 | 不影响        |
| 十进制调整指令 | DAA、AAD       | 十进制数调整 |                | S Z   A P C |

#### 加减运算类指令

1. 二进制加减

   `ADD DO, SO` 二进制加法

   `SUB DO, SO` 二进制减法

   `ADC DO, SO` 二进制加进位

   `SBB DO, SO` 二进制减进位

   注意：

   1. 这四种操作影响全部标志
   2. 所谓加/减进位，指上条（影响 `C` 标）指令的 `C` 也参与运算，`ADC` 为加上 `C`，`SBB` 为减去 `C`
   3. `SO` 可以为 `N/R/M`，`DO` 可以为 `R/M`，但同样的，双 `S` 或者 `M` 都是不允许的
   4. 根据需要 `PTR`

2. 二进制自增，自减

   `INC DO` 二进制自增

   `DEC DO` 二进制自减

   注意：

   1. 这两种操作影响除了 `C` 之外的标志
   2. `DO` 可以为 `R/M`
   3. 根据需要 `PTR`，对多字节自增时，注意拼接后再自增，而非每个字节都自增

3. `NEG` 二进制求补指令

   格式：`NEG DO`

   功能：将 `DO` 变为其负值

   注意：`DO` 为 `R/M`

4. `CMP` 比较指令

   格式：`CMP DO, SO`

   功能：将目标操作数减去源操作数，但保持目标操作数不变，依据减法运算的情况 6 个状态标志位

   注意：

   1. `DO` 为 `R/M`，`SO` 为等长 `R/M` 或者不超过 `DO` 长度的 `N`
   2. 该指令一般用于后续条件转移指令

#### 乘除运算类指令

1. `MUL` 无符号二进制数乘法

   格式：`MUL 乘数`

   功能：将同为 **无符号数** 并且 **字长相等** 的被乘数与乘数相乘，乘积送入指定寄存器

   注意：

   1. 乘数显式给定（`R/M`），被乘数和乘积均为隐含操作数
   2. 字节乘法，被乘数默认放 `AL`，中，得到的 16 位乘积送入 `AX` 中
   3. 字乘法，被乘数默认放 `AX` 中，得到的 32 位乘积的低 16 位送入 `AX` 中，高 16 位送入 `DX` 中
   4. 对标志位的影响：如果乘积的高半部分为 0，则 `C` 标和 `O` 标都置 0，否则置 1

2. `IMUL` 有符号二进制数乘法

   格式：`IMUL` 有三种格式，分别为：`IMUL 乘数`（同 `MUL`），`IMUL DO, SO`，`IMUL DO, OP1, OP2`

   功能：第一种格式同 `MUL`，第二种格式为 $DO \times SO \to DO$，第三种格式为 $OP_1 \times OP2 \to DO$

3. `DIV` 无符号二进制数除法

   格式：`DIV 除数`

   功能：将同为无符号数并且 **字长为除数的双倍长度的被除数与除数相除**，运算得到的商和余数送入指定寄存器

   注意：

   1. 除数显式给定（`R/M`），被乘数，商和余数均为隐含操作数
   2. 字节除法：除数为 8 位 `R/M`，16 位被除数默认放在 `AX` 中，得到的 8 位商送入 `AL` 中，8 位余数送入 `AH` 中
   3. 字除法：除数为 16 位 `R/M`，32 位被除数的高 16 位默认放在 `DX` 中，低 16 位默认放在 `AX` 中，得到的 16 位商送入 `AX` 中，16 位余数送入 `DX` 中
   4. 对标志位：无定义
   5. 当除数为 0，或者运算后的商超过定义字长，会溢出产生 **0 型中断**

3. `IDIV` 有符号二进制数除法

   格式：`IDIV 除数`

   注意：

   1. 对标志位：无定义
   2. 当除数为 0，或者运算后的商超过定义字长，会溢出产生 **0 型中断**

### BCD 码调整指令

+ 组合 BCD 码（紧凑型）：一个字节含有 2 位 BCD 码

+ 未组合 BCD 码（非紧凑型）：一个字节含有 1 位 BCD 码

> BCD 码数是用 4 位二进数代表 1 位十进数，运算法则应是：“逢十进一，借一当十”

使用二进制加法运算指令对用 BCD 码表示的十进制数进行运算，需要进行相应的修正，修正依据二进制加法运算完成后 C 标志和 A 标志的值以及运算结果中的高 4 位（低 4 位）是否大于 9，相应地将运算结果加上 `06H`、`60H` 或 `66H` 进行修正得到正确的 BCD 码结果

修正：在加法运算中：加 6（0110）

+ `A` 标志为 1（低四位向高位进位）：加上 `06H`
+ `C` 标志为 1（高四位向更高位进位）：加上 `60H`
+ 高四位或者第四位的值$\ge 9$，对应四位加 `0110`
+ 修正可能发生两次

##### 组合 BCD 码十进制数的算术运算调整指令

1. `DAA` 压缩的 BCD 加法十进制调整指令

   格式：`DAA`

   功能：对存放在 `AL` 中的由两个组合 BCD 码数相加的和进行修正，得到正确的组合 BCD 码结果

   1. 如果 `AL` 低 4 位大于 9 或者 `A` 标志 = 1，则 $(AL)+06H\to(AL)$，并将 `A` 标志置 1
   2. 如果 `AL` 高 4 位大于 9 或者 `C` 标志 = 1，则 $(AL)+60H\to(AL)$，并将 `C` 标志置 1
   3. 如果以上条件均不满足，则不需要对 AL 寄存器中的和进行修正

   注意：

   1. 对标志位的影响：DAA 指令执行后，影响除了 `O` 标以外的五个标志位

### 传送和调用类指令

| 分类           | 指令             | 功能                                 |
| -------------- | ---------------- | ------------------------------------ |
| 无条件转移指令 | JMP OP           | 无条件转移                           |
| 条件转移指令   | JNZ OP（等）     | 根据上一条指令设置的标志位的情况转移 |
| 循环指令       | LOOP OP          | 计数非零循环                         |
|                | LOOPE/LOOPZ OP   | 计数非零循环且结果为 0 循环            |
|                | LOOPNE/LOOPNZ OP | 计数非零循环且结果不为 0 循环          |
| 子程序调用指令 | CALL OP          | 调用子程序                           |
| 子程序返回指令 | RET              | 从子程序返回                         |
| 中断指令       | INTN             | 软中断                               |
|                | INTO             | 溢出时中断                           |
|                | IRET             | 中断返回                             |

+ 按照转移条件分：无条件转移和有条件转移

+ 按照转移范围分：段内转移和段间转移

+ 按照获取转移地址的方法分：直接转移和间接转移

#### 无条件转移指令

`JMP`

格式：`JMP 标号`

功能：无条件转移指令在执行时，无须任何前提条件，将控制转移到 **目标指令** 处

注意：

1. 格局转移范围和获取转移地址的方法来分，`JMP` 一共有四种类型操作。只要掌握其中的 **段内直接转移** 即可
2. 在标号的前面加上 `SHORT` 运算符，则转移变成短转移，此时转移的范围为相对 JMP 指令地址 $-126\sim +129B$，如果目标指令的地址超过这一范围，汇编程序将给出错误

#### 条件转移指令

功能：根据上一条指令影响的状态位判断是否转移

注意：

1. 条件转移指令全部为 **段内转移**

2. 目标地址在当前指令的 $-126\sim +129B$ 范围内。

3.  目标地址由操作数 `OP` 确定

单个条件标志的设置情况转移：

| 指令          | 功能                     | 转移条件 |
| ------------- | ------------------------ | -------- |
| JZ / JE  OP   | 结果为 0 / 相等则转移     | Z = 1      |
| JNZ / JNE  OP | 结果不为 0 / 不相等则转移 | Z = 0      |
| JS   OP       | 结果为负则转移           | S = 1      |
| JNS   OP      | 结果不为负则转移         | S = 0      |
| JO   OP       | 溢出则转移               | O = 1      |
| JNO   OP      | 不溢出则转移             | O = 0      |
| JP / JPE OP   | 奇偶位为 1 则转移          | P = 1      |
| JNP / JPO OP  | 奇偶位为 0 则转移          | P = 0      |
| JCXZ   OP     | CX = 0 则转移              | CX = 0     |

根据组合条件标志设置的情况转移（主要用来比较两个数大小）

无符号数大小比较：

| 指令     | 功能                         | 转移条件   |
| -------- | ---------------------------- | ---------- |
| JC   OP  | 低于/不高于等于/有借位则转移 | C = 1        |
| JNC   OP | 不低于/高于等于/无借位则转移 | C = 0        |
| JNA   OP | 低于或等于/不高于则转移      | C $\lor$ Z = 1 |
| JA   OP  | 不低于或等于/高于则转移      | C $\lor$ Z = 0 |

有符号数大小比较：

| 指令     | 功能                    | 转移条件            |
| -------- | ----------------------- | ------------------- |
| JL    OP | 小于/不大于等于则转移   | S $\oplus$ O = 1 且 Z = 0 |
| JGE   OP | 不小于/大于或等于则转移 | S $\oplus$ O = 0 或 Z = 1 |
| JLE   OP | 小于或等于/不大于则转移 | S $\oplus$ O = 1 或 Z = 1 |
| JG    OP | 不小于等于/大于则转移   | S $\oplus$ O = 0 且 Z = 0 |

#### 循环指令

`LOOP` 循环指令

格式： `LOOP 标号` 

功能：判断 `CX` 中的值，不为 0 则转至标号处执行程序，如果为 0 则向下执行

注意：

1. 每次执行都会自动执行 $CX - 1 \to CX$

栗子：数出长度为 10 的，以 STRING 为首地址的字符串中的空格个数

```asm
				LEA  SI, STRING			  ; 获得其偏移地址
				MOV  CX, 0AH				  ; 指定循环次数为10次
				MOV  AL, 20H          ; 空格的ASCII码为20H
				MOV  AH, 0H           ; 结果在AH中
AGAIN:  CMP  AL, [SI]					; 比较大小
				JZ  ADDA							; JZ判断是否相等（z=0），是的话说明为空格，跳到ADDA执行答案自增
				JMP CONT							; 不相等继续运行，跳转到CONT，SI自增
ADDA:   INC AH
CONT:   INC SI
				LOOP  AGAIN						; 继续循环


```

##### 子程序调用及返回指令

在汇编语言中子程序也称为过程，使用过程定义语句进行定义，**过程的名称即为子程序的名称**，在子程序定义中，用属性来标明子程序与主程序是否处于同一个代码段，**如果子程序和主程序位于同一个代码段，则子程序的属性定义为 NEAR** 属性，对该子程序的调用称为 **段内调用**；**如果子程序和主程序分别位于不同的代码段，则子程序的属性定义为 FAR** 属性，对子程序的调用称为 **段间调用**

汇编语言的过程定义语句

```asm
PName	PROC NEAR/FAR
			...
			RET
PName	ENDP
```

+ PName：子程序名，以字母开头，长度≤ 31。经汇编之后, 过程名就是子程序第一条指令的地址
+ PROC/ENDP 是子程序的定界语句
+ 属性
  + NEAR（缺省值）代表近过程，即该子程序和调用它的那条指令在同一个代码段
  + FAR 代表远过程，即该子程序和调用它的那条指令不在同一个代码段
  + RET 子程序返回指令

1. `CALL` 子程序调用指令

   格式：段内直接调用：`CALL 程序名`，段内间接调用：`CALL R/M`

   功能： 调用子程序，即无条件转到子程序的第一条指令

   注意：

   1. `CALL` 命令其实就是 **保存现场** 并 **JMP 跳转**

   1. 段内调用 `CALL`，首先，调整堆栈指针，$(SP) -2 \to (SP) $；然后，将 `CALL` 指令的下一条指令的地址，即 **断点的偏移地址** 压入堆栈中保存，$(IP) \to (SP)$；最后，将子程序的入口的偏移地址 $\to(IP)$，同时 $(CS)$ 保持不变，程序控制由主程序转到子程序
   2. 段间调用 `CALL`，首先，调整堆栈指针 $(SP) -4 \to (SP) $；然后，将 `CALL` 指令的下一条指令的地址，即 **断点的段基址和偏移地址** 依次压入堆栈中保存 $(IP) \to (16*(SS)+SP)$；最后，将子程序的入口的段基址 $\to(CS)$，偏移地址 $\to(IP)$，程序控制由主程序转到子程序

2. `RET` 子程序返回指令

   格式：`RET `

   功能：从子程序中返回主程序需要执行返回指令。**返回指令是子程序中最后一条指令**，对应于段内调用和段间调用，返回指令分为段内返回和段间返回，此外，返回指令有无参数和有参数两种形式

   注意：

   1. `RET` 命令其实就是 **恢复现场**
   2. 段内调用 `RET`，从堆栈的栈顶弹出之前保存的断点指令地址，$(SP) \to (IP)$，恢复堆栈 $(SP)+2\to(SP)$，同时 `CS` 内容保持不变。
   3. 段间调用 `RET`，从堆栈的栈顶弹出之前保存的断点指令的偏移地址，$(SP) \to (IP)$，然后弹出断点指令的段地址，$(SP) \to (CS)$，恢复堆栈 $(SP +4) \to (SP)$
      

### 逻辑运算和移位指令

| 分类         | 名称           | 格式            | 功能           | O S Z   A P C |
| ------------ | -------------- | --------------- | -------------- | ------------- |
| 逻辑运算指令 | 逻辑与指令     | AND   DO, SO    | 与             | O S Z    P C  |
|              | 逻辑或指令     | OR   DO, SO     | 或             | O S Z    P C  |
|              | 逻辑非指令     | NOT   OP        | 非             | 不影响        |
|              | 逻辑异或指令   | XOR DO, SO      | 异或           | O S Z    P C  |
|              | 测试指令       | TEST   DO, SO   | 测试           | O S Z    P C  |
| 移位指令     | 逻辑左移指令   | SHL   OP, COUNT | 逻辑左移       | O S Z   P C   |
|              | 算术左移指令   | SAL   OP, COUNT | 算术左移       | O S Z   P C   |
|              | 逻辑右移指令   | SHR   OP, COUNT | 逻辑右移       | O S Z    P C  |
|              | 算术右移移指令 | SAR   OP, COUNT | 算术右移       | O S Z    P C  |
| 循环移位指令 | 循环左移指令   | ROL   OP, COUNT | 循环左移       | O        C    |
|              | 循环右移指令   | ROR   OP, COUNT | 循环右移       | O        C    |
|              | 带进位循环左移 | RCL   OP, COUNT | 带进位循环左移 | O        C    |
|              | 带进位循环右移 | RCR   OP, COUNT | 带进位循环右移 | O        C    |

#### 逻辑运算类指令

1. `NOT` 逻辑非指令

   格式：`NOT DO`

   功能：实现操作数的按位取反运算，并将结果赋予 `DO`

   注意：该操作不影响标志位

2. `AND` 逻辑与指令

   格式：`AND DO,SO`

   功能：实现两个操作数的按位与运算，并将结果赋予 `DO`

   注意：

   1. 该操作影响操作位 $C=0,O=0$，以及 $P,S,Z$
   2. 可以用于某些位置置 0，或者检测某些位置是否为 1

3. `OR` 逻辑或指令

   格式：`OR DO,SO`

   功能：实现两个操作数的按位与运算，并将结果赋予 `DO`

   注意：

   1. 该操作影响操作位 $C=0,O=0$，以及 $P,S,Z$
   2. 可以用于某些位置置 1，或者检测某些位置是否为 0

4. `XOR` 异或指令

   格式：`XOR DO,SO`

   功能：实现两个操作数的按位异或，并将结果赋予 `DO`

   注意：

   1. 该操作影响操作位 $C=0,O=0$，以及 $P,S,Z$
   2. 异或自己可以全置 0，或者用于将某些位数 **取反**（1 取反，0 不变）

5. `TEST` 测试指令

   格式：`TEST DO,SO`

   功能：实现两个操作数的按位与运算，结果不保存，**只影响标志位**

#### 移位指令

1. `SAL/SAR` 算术移位指令

   格式：`SAL/SAR OP, COUNT`

   功能：左移与逻辑移位相同，右移时用原本最高位补位（正数用 0，负数用 1）

2. `SHL/SHR` 逻辑移位指令

   格式：`SHL/SHR OP, COUNT`

   功能：正常移位

3. `ROL/ROR` 循环移位指令

   格式：`ROL/ROR OP, COUNT`

   功能：移位后，使用被移出的进行补位

4. `RCL/RCR` 带进位的移位指令

   格式：`RCL/RCR OP, COUNT`

   功能：移位后，使用之前的 `CF` 进行补位

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220922103609.png" alt="image-20220922103609444" style="zoom:67%;" />

### 处理控制机类指令

| 名称              | 格式 | 功能（对标志位的影响）   |
| ----------------- | ---- | ------------------------ |
| 进位标志清 0 指令 | CLC  | C = 0                    |
| 进位标志置 1 指令 | STC  | C = 1                    |
| 进位标志取反      | CMC  | C = C                      |
| 方向标志清 0 指令 | CLD  | D = 0                    |
| 方向标志置 1 指令 | STD  | D = 1                    |
| 中断标志清 0 指令 | CLI  | I = 0                    |
| 中断标志置 1 指令 | STI  | I = 1                    |
| 处理器等待指令    | WAIT | 处理器等待               |
| 处理器交权指令    | ESC  | 处理器交权               |
| 总线封锁前缀      | LOCK | 封锁总线                 |
| 处理器暂停指令    | HLT  | 使处理器暂时处于停机状态 |
