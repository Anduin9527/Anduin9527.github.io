---
title: 从零开始的数据结构-树（上）
katex: true
tags:
  - 数据结构
  - 算法
  - 树
categories: 算法学习
abbrlink: 389e8dec
date: 2021-03-28 14:10:35
---

### 智慧树上智慧果，智慧树下平衡树，划分树，归并树，k-d树，pq树，主席树，树套树。

<!--more-->

## 树的定义

+ n 个结点构成的有限集合。

+ 当n=0时,称为空树。

+ 对于任一棵非空树(n>0) ,它具备以下性质:

  + 树中有一个称为“根(Root) ”的特殊结点,用r表示。

  + 其余结点可分为m个互不相交的有限集T, T2, .., , Tm,其中每个集合本身又是一棵树,称为原来树的"子树"(SubTree)。 
  + 子树是不相交的,除了根结点外,每个结点有且仅有一个父结点。
  + 一棵N个结点的树有N-1条边。

### 一些术语

+ 结点的**度**(Degree) ：结点的子树（子结点）个数
+ 树的**度**：树的所有结点中最大的度数
+ 叶结点(Leaf)/外部节点：度为0的结点
+ 父结点(Parent)：有子树的结点是其子树的根结点的父结点
+ 子结点(Child)：若A结点是B结点的父结点,则称B结点是A结点的子结点;子结点也称孩子结点。
+ 兄弟结点(Sibling)：具有同一父结点的各结点彼此是兄弟结点。
+ 路径和路径长度：从结点$n_1$到$n_k$的路径为一个结点序列$n_1,n_2,\cdots,n_k$,并且$n_i是n_{i+1}$父结点。则路径所包含边的个数为路径的长度。
+ 祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。
+ 子孙结点(Descendant)：某一结点的子树中的所有结点是这个结点的子孙。
+ 结点的层次(Level)：规定根结点在1层,其它任一结点的层数是其父结点的层数加1.
+ 深度(Depth)：树中所有结点中的最大层次是这棵树的深度。根的深度为0。
+ 高度(height)：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有叶结点的高度为0；
+ 无序树：树中结点的各子树之间的顺序无关，可以交换位置
+ 有序树：树种结点的各棵子树从左到右顺序相关

## 树的表示

自然而然地，我们会想到用指针来存放一棵树。但毫无疑问地是指针域要按照**树的度**的决定，这样势必就会造成指针域的浪费。

于是我们引入了一种方法：**左子-右兄弟表示法(left-child right-sibling representation)**：可以将任意树转变为二叉树链表。

**左子-右兄弟表示法**包含的信息：

+ 结点数据（ElementType Data）

+ 节点n的父节点（Parent）//基础情况可省略

+ 节点n**最左侧**的子结点（Left）

+ 节点n**右侧紧邻**的兄弟节点（Right）

  ![image-20210328152116810](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092755.png)

可以和一开始的想法进行对比：

假设一棵度为 m的树有n个节点。若每个节点直接用m个链指向相应的儿子，则表示这个树所需要的总空间是**n*(m+1)** (假定每个链以及表示节点的数据域都是一个单位空间).。当采用**左子-右兄弟表示法(left-child right-sibling representation)**表示法时，所需的总空间是**3n**。

## 二叉树(BinaryTree)

作为最基本也是最重要的树结构，请务必能倒写二叉树。

+ 二叉树是一个有穷的结点集合。
+ 这个集合可以为空
+ 若不为空,则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。
+ 二叉树具有五种基本形态

![image-20210328155942742](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092753.png)

### 二叉树的性质

+ 第i层的最大结点数为：$2^{i-1}$$(i\ge1)$
+ 深度为k的二叉树的最大结点总数：$2^k-1(k\ge1)$ （显然最大时为满二叉树）
+ 包含n个结点的的二叉树的高度**最矮**为：$[log_2(n+1)]$（最矮的情况为完全二叉树）
+ 对于任何非空的二叉树T，若$n_0$表示叶结点的个数，$n_1$是度为1的非叶结点的个数,$n_2$是度为2的非叶结点的个数，那么满足公式：$n_0=n_2+1$。
+ 二叉树边的个数：$n_0+n_1+n_2-1=0\times n_0+1\times n_1+2\times n_2$

### 特殊的二叉树

#### 斜二叉树

只有左子结点或只有右子结点的二叉树称为斜二叉树

#### 满二叉树

满二叉树除了叶结点外所有节点都有两个子节点，且叶结点都在同一层。

换句话说，除了最后一层的叶结点，以上所有父结点必须有且只有两个子结点。

![img](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092748.webp)

#### 完全二叉树

对一棵具有n个结点的二叉树按层序编号，则编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点位置完全相同

换句话说，从根结点开始往下数，除了最下层外都是全满（都有两个子节点），而最下层所有叶结点都向左边靠拢填满。

![img](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092747.webp)

+ 完全二叉树的高度：$log_2(n+1)$
+ 从0开始按照层序遍历对结点编号：
  + i = 0：根结点
  + i > 0：父结点为 $[(i-1)/2]$
  + 2i +1 < n：则该节点的左子结点为 $2i+1$
  + 2i +2 < n：则该节点的右子结点为 $2i+2$



#### 扩充二叉树

除叶结点外，其余结点都必须有两个子结点



### 二叉树的实现

#### 存储实现（数组）

首先来看完全二叉树的数组实现（这里选择从1开始编号）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092744.png" alt="image-20210328170317981" style="zoom:50%;" />

+ 非根结点的父结点的序号是**[i/2]**（[]表示向下取整）
+ 结点的左子结点的序号是**2i**（2i$\le$n）
+ 结点的右子结点的序号是**2i+1**（2i+1$\le$n）

那么考虑一般的二叉树，是否也可以通过补全为完全二叉树的方式来进行数组的存储实现呢？

来看这样一个普通的二叉树：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092742.png" alt="graph" style="zoom:50%;" />

将其补全为完全二叉树：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092737.png" alt="graph (2)" style="zoom:50%;" />



| 结点名称 | A    | B    | C    | 1    | 2    | D    | 3    | 4    | 5    | 6    | 7    | E    | 8    |
| :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | ---- | ---- | ---- | ---- | ---- |
| 数组序号 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   |

显然也符合完全二叉树的规律。但毫无疑问，这会造成空间的浪费。比如十个结点的树，考虑最坏情况就得开1024+5的数组。

```c
void createTree(int n, int *BinTree)
{
  int Data;
  int index;
  for (int i = 0; i < n; i++)
  {
    cin >> Data;
    index = 1;//index从1开始避免后续奇怪的麻烦
    while (BinTree[index] != 0)//父节点不为空
    { // 寻找插入点
      if (Data >= BinTree[index])//右子结点
        index = index * 2 + 1;
      else//左子结点
        index *= 2;
    }
    BinTree[index] = Data;
  }
}
```



#### 存储实现（链表）

先说说比较简单的**静态链表：**

```c
struct TreeNode
{
  ElementType Data;
  int Left;
  int Right;
}T[MaxN];
```

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092811.png" alt="image-20210331202227774" style="zoom:50%;" />

+ -1表示空节点

+ 可以通过建立一个flag数组，在记录二叉树时的左右结点时修改flag，最后遍历flag数组，就可以发现根节点。

  

以下是**动态链表：**

```c
typedef struct TreeNode *BinTree;
struct TreeNode
{
ElementType Data;
BinTree Left;		//指向左子结点
BinTree Right;	//指向右子结点
(BinTree Parent;	//指向父结点)
}
```

```c
BinTree Insert(ElementType Data)
{
  BinTree BT;
  BT = (BinTree)malloc(sizeof(struct TreeNode));
  BT->Data = Data;
  BT->Left = nullptr;
  BT->Right = nullptr;
  return BT;
}
// 初始化二叉树
BinTree CreatBinTree()
{
  BinTree BT;
  BT = (BinTree)malloc(sizeof(struct TreeNode));
  BT->Data = 1;
  BT->Left = Insert(2);
  BT->Right = Insert(3);
  BT->Left->Left = Insert(4);
  BT->Left->Right = Insert(6);
  BT->Left->Right->Left = Insert(5);
  BT->Right->Left = Insert(7);
  BT->Right->Right = Insert(9);
  BT->Right->Left->Right = Insert(8);
  return BT;
}
```

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092813.png" alt="graph (3)" style="zoom:50%;" />

通过以上初始化，我们就创建了一个如图所示的二叉树，现在我们康康怎么遍历他们。

### 二叉树的遍历

#### 1）先/前序遍历

遍历过程为:

①访问根结点
②先序遍历其左子树
③先序遍历其右子树

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092815.png" style="zoom:50%;" />

遍历顺序：A(BDFE)(CGHI)

```c
void PreOrderTraversal(BinTree BT)
{
  if (BT)
  {
    cout << BT->Data;//***
    PreOrderTraversal(BT->Left);
    PreOrderTraversal(BT->Right);
  }
}
```

#### 2）中序遍历

遍历过程为：

①中序遍历其左子树
②访问根结点
③中序遍历其右子树

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092818.png" alt="image-20210328191833131" style="zoom:50%;" />

遍历顺序：（DBFE)A(GHCI)

```c
void InOrderTraversal(BinTree BT)
{
  if (BT)
  {
    InOrderTraversal(BT->Left);
    cout << BT->Data;//***
    InOrderTraversal(BT->Right);
  }
}
```

#### 3）后序遍历

遍历过程为：

①后序遍历其左子树
②后序遍历其右子树
③访问根节点

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092820.png" style="zoom:50%;" />

遍历顺序：(DEFB)(HGIC)A

```c
void PostOrderTraversal(BinTree BT)
{
  if (BT)
  {
    PostOrderTraversal(BT->Left);
    PostOrderTraversal(BT->Right);
    cout << BT->Data;//***
  }
}
```

#### 4）非递归（利用堆栈）实现遍历

前三种遍历方法都是利用**递归**，其本质是**堆栈**。下面开始尝试直接使用堆栈进行对树的遍历。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092821.png" alt="image-20210328191833131" style="zoom:50%;" />

以这张中序遍历的图为例，假设我们现在有一个堆栈，我们的目的就是制造一个出栈序列为DBFEAGHCI的堆栈

OK，开始遍历左子树，中途遇见的结点全部push进栈中，一直到左子树为空，也就是遍历到了D。

此时pop(D)，然后开始遍历右子树，发现也为空。

此时回到栈顶元素B，pop掉，然后遍历B的右子树的左子树……

通过简单的模拟，我们可以得到规律如下：

+ 遇到一个结点,就把它压栈,并去遍历它的左子树
+ 当左子树遍历结束后,从栈顶弹出这个结点并访问它
+ 然后按其右指针再去中序遍历该结点的右子树，如此循环往复

```c
void InOrderTraversal(BinTree BT)//非递归中序遍历
{
  BinTree T = BT;
  stack<BinTree> S;//初始化栈
  while (T || !S.empty())
  {
    while (T)//一路向左遍历左子树
    {
      S.push(T);//沿途压栈
      T = T->Left;
    }
    if (!empty(S))//压无可压
    {
      T = S.top();//访问
      S.pop();//出栈
      cout << T->Data;
      T = T->Right;//开始遍历右子树
    }
  }
}
```

```c
void PreOrderTraversal(BinTree BT)//非递归先序遍历
{
  BinTree T = BT;
  stack<BinTree> S;//初始化栈
  while (T || !S.empty())
  {
    while (T)//一路向左遍历左子树
    {
      cout << T->Data;//前序和先序的差别只在这
      S.push(T);//沿途压栈
      T = T->Left;
    }
    if (!empty(S))//压无可压
    {
      T = S.top();//访问
      S.pop();//出栈
      T = T->Right;//开始遍历右子树
    }
  }
}
```

+ 关于中序和先序只需调换打印语句的位置这件事，可以这么理解：

对于先序来说，打印一个结点的时机是第一次访问该节点时；

对于中序来说，打印一个结点的时机是第二次访问该结点时；

但是！对于后序来说，打印一个结点是第三次访问该节点时（开始访问，左子树遍历完，右子树遍历完）难点在于：**需要判断上次访问的节点是位于左子树，还是右子树。**若是位于左子树，则需跳过根节点，先进入右子树，再回头访问根节点；若是位于右子树，则直接访问根节点。总结：

- 当前结点是叶结点。
- 当前结点的右子结点是上一次访问的结点。

```c
void PostOrderTraversal(BinTree BT)//非递归后序遍历
{
  stack<BinTree> S;
  BinTree T= BT;
  BinTree pre = nullptr;//pre指针是为了保存上一次访问的结点状态

  while (T != nullptr || !S.empty())
  {
    if (T != nullptr)
    {
      S.push(T);
      T = T->Left; //遍历左子树
    }
    else
    {
      //每次取栈顶元素
      //判断栈顶元素的右孩子是否为空，
      //如果不为空，查看之前访问的节点是不是该栈顶元素的右孩子
      T = S.top();
      if (T->Right != nullptr && T->Right != pre)//如果之前访问的不是当前结点的右结点
      {
        T = T->Right; //遍历右子树
      }
      else
      {
        cout << T->Data; //根
        S.pop();
        //每次访问节点之后，需要将缓存上一次访问的节点为pre，并且将当前指针置空
        pre = T;
        T = nullptr;
      }
    }
  }
}
```

#### 5）层序遍历

所谓层序遍历就是按照树的层次从上至下，从左至右地遍历树。也就是所谓的树型BFS。

**通过引入一个队列来进行层序遍历：**

- 先将根结点入队；
- 只要队列不为空：
  - 出队队首结点，并遍历；
  - 如果队首结点有左子结点，将左子结点入队；
  - 如果队首结点有右子结点，将右子结点入队；

```c
void LevelorderTraversal ( BinTree BT )
{ 
  queue<BinTree> Q;	//初始化队列
  BinTree T;				//T作为临时变量
  if (!BT)
    return;					//若为空树直接返回
  Q.push(BT); 			// 根节点入队
  while (!Q.empty())
  {
    T = Q.front(); 	// 访问队首元素
    Q.pop();      	// 出队
    printf("%d", T->Data);
    if (T->Left)
      Q.push(T->Left);
    if (T->Right)
      Q.push(T->Right);
  }
}
```

+ 已知二叉树的 先序遍历和中序遍历 或者 后序遍历和中序遍历。可以唯一确定一颗二叉树



### 二叉树的操作集及基础应用

#### 1）输出叶结点（PrintLeaves）

思路非常简单，在上述遍历的基础上，加上**左右子树皆空的条件即可**

```c
void PrintLeaves(BinTree BT)
{
  if (BT)
  {
    PrintLeaves(BT->Left);
    if (!BT->Left && !BT->Right)
      printf("%d", BT->Data); 
    PrintLeaves(BT->Right);
  }
}
```

#### 2）求高度（getHeight）

递推公式：**高度=max（左子树高度，右子树高度）+1**

思路也很简单，同样是递归遍历求高度

```c
 int getHeight(BinTree BT)
{
  int HL, HR, MaxH;
  if (BT)
  {
    HL=getHeight(BT->Left);
    HR = getHeight(BT->Right);
    MaxH = HL > HR ? HL : HR;
    return (MaxH + 1);
  }
  else
    return 0;//空树返回0
}
```

#### 3）二元运算表达式树

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092826.png" alt="QQ截图20210329185128" style="zoom:50%;" />

让我们遍历一下试试:

后序遍历: abc\*+de\*f+g\*+ //后缀表达式
中序遍历: a+b\*c+d\*e+f\*g //异常的中缀表达式（收到**优先级影响**）
前序遍历: ++a\*bc\*+*defg //前缀表达式

那么接下来考虑解决中序的异常情况，这里有一种很讨巧的加括号的方式：

+ 进入左子树前 打印左括号
+ 退出右子树后 打印右括号

不过打印出来的 (((a)+((b)*(c)))+((((d)\*(e))+(f))\*(g))) 可读性也不怎么样

```c
void InOrderBinaryExpressionTrees(BinTree BT)
{
  if (BT)
  {
    cout << "(";
    InOrderBinaryExpressionTrees(BT->Left);
    cout << BT->Data; //***
    InOrderBinaryExpressionTrees(BT->Right);
    cout << ")";
  }
}
```

#### 4）前序+中序->后序

假定有某二叉树的前序遍历序列和中序遍历序列那么是否能还原出后序遍历序列呢？

例：

前序遍历:     GDAFEMHZ

中序遍历:     ADEFGHMZ

>第一步，根据前序遍历的特点(根左右)，我们知道根结点为G
>
>第二步，观察中序遍历(左根右)ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。
>
> 第三步，观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。
>
>第四步，同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。
>
>第五步，观察发现，上面的过程是**递归**的。
>
>先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：
>
>1 确定根,确定左子树，确定右子树。
>
>2 在左子树中递归。
>
>3 在右子树中递归。
>
>4 打印当前根。
>
>[二叉树前序、中序、后序遍历相互求法](https://blog.csdn.net/u011068702/article/details/51914220)

![img](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211008092828.jpeg)

这里都是用的字符串指针，在洛谷有看见大佬用stl的string非常惊艳

```c
void toPostOrder(char *inorder, char *preorder, int length)
{
  if (length == 0)
  {
    //cout<<"invalid length";
    return;
  }
  BinTree node = new TreeNode;
  node->Data = *preorder; //记录先序的首元素，即树的根
  int rootIndex = 0;
  for (; rootIndex < length; rootIndex++)
  {
    if (inorder[rootIndex] == *preorder)
      break;
  } //在中序序列中寻找root，并记录其下标rootIndex
  //特别注意到 左子树的长度 == rootIndex ,右子树的长度 == length - (rootIndex + 1)
  //Left
  toPostOrder(inorder, preorder + 1, rootIndex);
  //Right
  toPostOrder(inorder + rootIndex + 1, preorder + rootIndex + 1, length - (rootIndex + 1));
  cout << node->Data;
  return;
}
```

类似的，不难得出中序和后序求先序的算法。

```c
void toPreOrder(char *inorder, char *postorder, int length)
{
  if (length == 0)
  {
    //cout<<"invalid length";
    return;
  }
  BinTree node = new TreeNode;
  node->Data = *(postorder + length - 1); //取后序排列的末尾，即为根
  cout << node->Data;                     //由于先序序列第一位是根，直接打印

  int rootIndex = 0;
  for (; rootIndex < length; rootIndex++) //a variation of the loop
  {
    if (inorder[rootIndex] == *(postorder + length - 1))
      break;
  } //在中序序列中寻找根,返回其下标
  //然后得到中序根下标左边为左子树，右边为右子树
  toPreOrder(inorder, postorder,rootIndex); 
  //中序左根右，后序左右根，两序列的左子树长度相等
  toPreOrder(inorder + rootIndex + 1, postorder + rootIndex, length - (rootIndex + 1));
  //遍历右子树，中序直接遍历到尾
}
```

## 并查集

>并查集是一种**树形的**数据结构，顾名思义，它用于处理一些不交集的 **合并** 及 **查询** 问题。 它支持两种操作：
>
>- 查找（Find）：确定某个元素处于哪个子集；
>- 合并（Union）：将两个子集合并成一个集合。

### 并查集的表示

利用结构体数组进行存储,规定祖先的父结点值为负数。

```c
#define MaxSize 1000
typedef int ElementType;
typedef struct{
	ElementType Data; // 存值
	int parent;  // 指向父结点 
}SetType;
SetType s[MaxSize];
```

### 查找

方案一（暴力）：

```c
int Find(ElementType x)
{
  if (s[x].parent<0) //x恰好就是根节点
    return x;
 else
   return Find(s[x].parent)
}
```

+ 从叶结点开始，一层一层向父结点访问，思路简单，但是效率太低，因为对于一个集合来说我只关心他的根节点（祖宗结点），而不关心他的父结点。<del>那么，有没有一种方法</del>**那就是把在路径上的每个节点都直接连接到根上**，这就是**路径压缩**。

```c
int Find(ElementType x)
{
  if (s[x].parent>=0)  					// x不是根节点
    s[x].parent = Find(s[x].parent);  // 查找x的祖先直到找到代表,于是顺手路径压缩
  return s[x].parent;
}
```

### 合并

```c
void Union(SetName Root1, SetName Root2 )
{ /* 这里默认Root1和Root2是不同集合的根结点 */
    /* 保证小集合并入大集合 */
    if ( s[Root2] < s[Root1] ) { /* 如果集合2比较大 */
        s[Root2] += s[Root1];     /* 集合1并入集合2  */
        s[Root1] = Root2;
    }
    else {                         /* 如果集合1比较大 */
        s[Root1] += s[Root2];     /* 集合2并入集合1  */
        s[Root2] = Root1;
    }
}
```



## 参考

https://www.jianshu.com/p/ac95b5a7de8b

https://cloud.tencent.com/developer/article/1353388

https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html

https://www.runoob.com/data-structures/binary-search-level-traverse.html

https://zhuanlan.zhihu.com/p/34147390

https://blog.csdn.net/u011068702/article/details/51914220

https://blog.csdn.net/snowsnowsnow1991/article/details/52541760

https://oi-wiki.org/ds/dsu/