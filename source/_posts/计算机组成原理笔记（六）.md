---
title: 计算机组成原理笔记（六）
tags:
  - 笔记
  - 硬件
category: 计算机组成原理
katex: true
abbrlink: 9b046e01
date: 2022-08-08 23:53:07
---

## 前言

绝区零好潮。。。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220808231206.jpeg" alt="img" style="zoom:80%;" />

<!--more-->

## 无符号数和有符号数

### 无符号数

计算机中的数均放在 **寄存器** 中，通常称寄存器的位数为 **机器字长**。**所谓无符号数，即没有符号的数**，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的。比如用一个八位的寄存器保存无符号数，则可以表示 0~255。

### 有符号数

#### 机器数与真值

因为计算机没有办法直接识别正负号，所以需要将正负号转化为数字来存储。保存在计算机中将正负号“数字化”之后的数称为 **机器数**，而 **真值** 是我们日常生活中包含了正负号的数值。注意：以下内容默认都为 2 进制数

#### 原码表示法

原码是机器数中最简单的一种表示形式，符号位为 0 表示正数，符号位为 1 表示负数，**数值位即真值的绝对值**，故原码表示又称为带符号的绝对值表示。为了书写方便以及区别整数和小数，约定整数的符号位与数值位之间用逗号隔开；小数的符号位与数值位之间用小数点隔开。由此可得原码的定义：
$$
[x]_{\text {原}}=\left\{\begin{array}{cc}
0, \ x & 2^{n}> x \geqslant 0 \\
2^{n}-x & 0 \geqslant x > -2^{n}
\end{array}\right.
$$
例如，当 $x = -1110$ 时， $[x]_{\text {原}} = 2^4 - (-1110) = 1,1110$ 

对于小数部分：
$$
[x]_{\text {原 }}=\left\{\begin{array}{cc}
x & 1 > x \geqslant 0 \\
1-x & 0 \geqslant x >-1
\end{array}\right.
$$
例如，当 $x = +0.1101$ 时， $[x]_{\text {原}} = 0.1101$ ，注意这里两个 $0.$ 的含义不同，后者表示正数+区分符

+ 不难发现，对于 $0$ 而言， $[+0000] _{\text {原}} = 0,0000 ;\ [-0000]_{\text {原}} = 1,0000$ ，两者并不相同

+ 原码特点：简单且直观，但运算复杂。当两个操作数符号不同且要作加法运算时，先要判断两数绝对值大小，然后将绝对值大的数减去绝对值小的数，结果的符号以绝对值大的数为准。而且用到的是减法器实现。

  

#### 补码表示法

为了解决原码在计算中的问题，即用一个与负数等价的正数表示负数，使得运算中只需要加法器。

所谓补数，就是其本身加上 **模**。正数的补数是其自身，负数的补数是其本身加上模，当一个正数和一个负数互为补数的时候，其绝对值之和为模数。那么对于 2 进制数而言，模就是 $2^n$ ，但是为了能表示正负，即负数的首位为 1，选择将模设置为 $2^{n+1}$ 。
$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}> x \geqslant 0 \\ 2^{n+1}+x & 0 > x \geqslant-2^{n} \quad\left(\bmod 2^{n+1}\right)\end{cases}
$$
例如， $x = -1011000$ ，则 $[x]_{\text{补}} = 2^{7+1} + (-1011000) = 1,0101000$ 

小数：
$$
[x]_{\text {补 }}= \begin{cases}x & 1 > x \geqslant 0 \\ 2+x & 0 > x \geqslant-1 \quad(\bmod 2)\end{cases}
$$

例如， $x = -0.1100000$ ，则 $[x]_{\text{补}} = 2+(-0.1100000) = 1.0100000$ 

+ 我们也可以通过口诀“**原码取反（变为反码）再加 1**”快速计算一个数的补码
+ 不难发现，对于 $0$ 而言， $[+0000] _{\text {补}} = 0,0000 ;\ [-0000]_{\text {补}} = 2^{4+1} - 0000 = 100000 -0000 = 0,0000$ ，最高位溢出舍去，所以补码的 0 表现形式是一致的

#### 反码表示法

反码通常用来作为由原码求补码或者由补码求原码的中间过渡。反码的定义如下：
$$
[x]_{\text {反 }}=\left\{\begin{array}{ll}
0,\  x & 2^{n}> x \geqslant 0 \\
\left(2^{n+1}-1\right)+x & 0 \geqslant x >-2^{n}\left(\bmod 2^{n+1}-1\right)
\end{array}\right.
$$
小数：
$$
[x]_{\text {反 }}= \begin{cases}x & 1 > x \geqslant 0 \\ \left(2-2^{-n}\right)+x & 0 \geqslant x >-1 \quad\left(\bmod \left(2-2^{-n}\right)\right)\end{cases}
$$
例如， $x = -0.1010$ ，则
$$
\begin{align*}
[x]_{\text{反}} &= (2 - 2 ^{-4}) + (-0.1010)) \\
&= (10 - 0.0001) -0.1010 \\
&= 1.1111 - 0.1010 \\
&= 1.0101 
\end{align*}
$$

+ 简而言之为，符号位不变，正数不变，负数取反
+ 不难发现，对于 $0$ 而言， $[+0000] _{\text {反}} = 0,0000 ;\ [-0000]_{\text {反}} = 2^{4+1}-1 - 0000 = 11111 - 0000 = 1,1111$ ，两者并不一致。

#### 小结

1. 最高位为符号位，书写上用“,”或“.”将数值部分与符号位分隔开
2. 对于正数，原码 = 反码 = 补码
3. 对于负数，符号位为 1。其数值部分原码取反得反码，反码加 1 得补码

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8E%9F%E5%8F%8D%E8%A1%A5%E5%B0%8F%E7%BB%93.png" alt="image-20220726222748948" style="zoom:80%;" />

#### 移码表示法

补码虽然计算机计算方便，但是人类和机器并不能直观地判断大小。所以选择加上 $2^n$ ，（这里的 $n$ 同样是不包含符号位的）。因此得到移码的定义
$$
[x]_{\text {移 }}= 2^{n}+x\left(2^{n}> x \geqslant-2^{n}\right)
$$
例如，
$$
\begin{aligned}
&{[+0]_{\text {移 }}= 2^{5}+0 = 1,00000} \\
&{[-0]_{\text {移 }}= 2^{5}-0 = 1,00000}
\end{aligned}
$$

+ 可见在移码中 0 的表示唯一。
+ 移码只有整数形式的定义，而无小数定义。因为移码在数据表示中负责浮点数的 **阶码** 部分，其只有整数。
+ 最小值为全 0，最大值为全 1，非常直观
+ **同一真值的移码和补码只有符号位不同**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A7%BB%E7%A0%81%E6%AF%94%E8%BE%83.png" alt="image-20220726224410850" style="zoom:80%;" />



## 数的定点表示和浮点表示

在计算机中，小数点 **不用专门的器件表示，而是按约定的方式标出**，共有两种方法表示小数点的存在，即 **定点表示** 和 **浮点表示**。定点表示的数称为定点数，浮点表示的数称为浮点数。

### 定点表示

所谓定点表示，即小数点固定在某一位置。其有两种形式，分别是小数点在数符（正负号）后，和小数点在数值后。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA.png" alt="image-20220727145024898" style="zoom:80%;" />

+ 根据机器选择的小数点位置的不同，分为 **小数定点机** 和 **整数定点机**

| 定点机 | 小数定点机                  | 整数定点机            |
| ------ | --------------------------- | --------------------- |
| 原码   | $[-(1-2^{-n}),+(1-2^{-n})]$ | $[-(2^n-1),+(2^n-1)]$ |
| 补码   | $[-1,+(1-2^{-n})]$ | $[-2^n,+(2^n-1)]$ |
| 反码   | $[-(1-2^{-n}),+(1-2^{-n})]$ | $[-(2^n-1),+(2^n-1)]$ |

+ 不难发现，原码的范围与反码表示的范围一致，这也与上一篇的结论相符合。而补码的最小值会发生改变，也与上篇相符。

### 浮点表示

实际上计算机中处理的数不一定是纯小数或纯整数（如圆周率），而且有些数据的数值范围相差很大，它们都不能直接用定点小数或定点整数表示，除非疯狂加长机器字长，这显然是不现实的。但其均可用浮点数表示。**浮点数即小数点的位置可以浮动的数**，比如：
$$
\begin{aligned}
352.47 &= 3.5247 \times 10^{2} \\
&= 3524.7 \times 10^{-1} \\
&= 0.35247 \times 10^{3}
\end{aligned}
$$
其实就类似我们学过的科学计数法，其一般形式为 $N = S \times r^j$ ，其中 $S$ 称为 **尾数**， $j$ 称为 **阶码**， $r$ 称为 **基值**。

+ 尾数 $S$ 的绝对值小于等于 1，为小数
+ 阶码 $j$ 为整数
+ 基值 $r$ 在计算机中一般取 2 的次幂

当 $r = 2$ 时，举个例子：
$$
\begin{aligned}
N &= 11.0101 \\
&= 0.110101 \times 2^{10} \\
&= 1.10101 \times 2^{1} \\
&= 1101.01 \times 2^{-10} \\
&= 0.00110101 \times 2^{100}
\end{aligned}
$$

+ 注意，这里的阶码同样为 2 进制。
+ 注意，尾数的绝对值限制
+ 将尾数最高位为 1 的数称为 **规格化数**，此时精度最高

#### 浮点数的表现形式

在设计计算机的过程中，如果事先约定好了基值 $r$ ，那么存储浮点数只需要记录另外两个数值即可：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BD%A2%E5%BC%8F.png" alt="image-20220727152107973" style="zoom:80%;" />

+ $j_f$ 和 $S_f$ 表示正负
+ $n$ ，尾数位数，即反映浮点数精度
+ $m$ ，阶码位数，即反映浮点数范围

#### 浮点数的表示范围

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E8%8C%83%E5%9B%B41.png" alt="image-20220727153145219" style="zoom:80%;" />

+ 上溢：阶码大于最大阶码，则报错进行中断溢出处理
+ 下溢：阶码小于最小阶码，则按照机器 0 处理

#### 浮点数的规格化

规格化形式与 $r$ 的取值有直接联系，当 $r = 2$ 时，要求首位为 1，当 $r = 4$ 时，要求首两位不全为 0。

**事实上，可以总结出当 $r = 2^i$ 时，要求首 $i$ 位不全为 0**，推广到其他码制：

| 码制 | S > 0 规格化形式 | S < 0 规格化形式 |
| ---- | ------------- | ------------- |
| 真值 | 0.1XXX        | -0.1XXX       |
| 原码 | 0.1XXX        | 1.1XXX        |
| 补码 | 1.0XXX        | 1.0XXX        |
| 反码 | 0.1XXX        | 1.0XXX        |

+ **原码：无论正负首位都为 1**
+ **补码：符号位与首位不同**，有特例 $[-\frac{1}{2}] _\text{补}= 1.100$ 不是规格化数， $[-1]_\text{补} = 1.000$ 是规格化数

很容易想到，通过左移右移就可以使得浮点数规格化。这被称为 **左规右规**，但是要注意基值 $r$ 对于阶码的影响。 

比如 $r = 4$ ，左规 2 位，尾数左移 2 位，阶码减 1。此时就不能左规 3 位，因为要保证阶码为整数。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E4%BE%8B%E5%AD%90.png" alt="image-20220727160349750" style="zoom:80%;" />

+ 值得注意的是，当一个浮点数尾数为 0 时，不论其阶码为何值；或阶码等于或小于它所能表 示的最小数时，不管其尾数为何值，机器都把该浮点数作为零看待，并称之为“机器零”。

### 定点数和浮点数的比较

1. 当浮点机和定点机中，数的位数相同时，浮点数的表示范围比定点数的大得多。

2. 当浮点数为规格化数时，其相对精度远比定点数高。

3. 浮点数运算要分阶码部分和尾数部分，而且运算结果都要求规格化，故浮点运算步骤比定点运算步骤多，运算速度比定点运算的低，运算线路比定点运算的复杂。

4. 在溢出的判断方法上，浮点数是对规格化数的阶码进行判断，而定点数是对数值本身进行判断。
5. 总之，浮点数在数的表示范围、数的精度、溢出处理和程序编程方面（不取比例因子）均优于定点数。但在运算规则、运算速度及硬件成本方面又不如定点数。因此，究竟选用定点数还是浮点数，应根据具体应用综合考虑。一般来说，通用的大型计算机大多采用浮点数，或同时采用定、浮点数；小型、微型及某些专用机、控制机则大多采用定点数。当需要作浮点运算时，可通过软件实现，也可外加浮点扩展硬件（如协处理器）来实现。

### IEEE 754 标准

![image-20220727161122768](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/IEEE.png)

+ 尾数必须规格化，非 0 的有效位最高位为 1（隐含）。所以尾数有一个最高位为隐藏位，其值恒为 1
+ 在实际应用中分为短实数（float）和长实数（double）以及临时实数（不采用隐藏位）

| 类型     | 符号位 S | 阶码 | 尾数 | 总位数 |
| -------- | ------- | ---- | ---- | ------ |
| 短实数   | 1       | 8    | 23   | 32     |
| 长实数   | 1       | 11   | 52   | 64     |
| 临时实数 | 1       | 15   | 64   | 80     |

## 定点运算

### 移位运算

移位运算指 **小数点不动，数据左移或者右移**，其中左移绝对值变大，右移绝对值减小。对计算机来说，左移一位意味着数据变为原先的两倍，右移则为二分之一。移位运算有很大的实用价值。例如，当某计算机没有乘（除） 法运算线路时，可以采用移位和加法相结合，实现乘（除）运算。

#### 算术移位

> 计算机中机器数的字长往往是固定的，当机器数左移 n 位或右移 n 位时，必然会使其 n 位低位或 n 位高位出现空位。那么，对空出的空位应该添补 0 还是 1 呢？这 **与机器数采用有符号数还是无符号数有关**。对有符号数的移位称为算术移位。

| 真值 | 码制             | 填补代码         |
| ---- | ---------------- | ---------------- |
| 正数 | 原码、反码、补码 | 0                |
| 负数 | 原码             | 0                |
| 负数 | 反码             | 1                |
| 负数 | 补码             | 左移为 0，右移为 1 |

+ 算术移位保证 **符号位不变**，约定数值部分移位后能够存储的下
+ 机器数为正时，不论是左移还是右移，添补代码均为 0。
+ 由于负数的 **原码数值部分与真值相同**，故在移位时只要使符号位不变，其空位均添 0 即可。
+ 由于负数的 **反码各位除符号位外与负数的原码正好相反**，故移位后所添的代码应与原码相反，即全部添 1。
+ 分析任意负数的补码可发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。故负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添 0；右移时因空位出现在高位，则添补的代码应与反码相同，即添 1。
+ 对于负数，三种机器数算术移位后符号位均不变。负数的原码左移时，高位丢 1，结果出错；右移时，低位丢 1，影响精度。负数的补码左移时，高位丢 0，结果出错；右移时，低位丢 1,，影响精度。负数的反码左移时，高位丢 0，结果出错；右移时，低位丢 0，影响精度。

#### 逻辑移位

有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。换言之，算术移位不会移动符号位，而逻辑移位会。逻辑移位的规则是：逻辑左移时，高位移丢，低位添 0；逻辑右移时，低位移丢，高位添 0。

### 加减运算

之所以引进补码，就是因为其可以将减法运算转换为加法运算。而现代计算机也确实采用补码做加减法运算

#### 补码加减法

整数加法： $[A] _{\text {补 }}+[B]_{\text {补 }}= [A+B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$ 

小数加法： $[A] _{\text {补 }}+[B]_{\text {补 }}= [A+B]_{\text {补 }}(\bmod 2)$ 

整数减法： $[A-B] _{\text {补 }}= [A+(-B)]_{\text {补 }}= [A] _{\text {补 }}+[-B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$ 

小数减法： $[A-B] _{\text {补 }}= [A+(-B)]_{\text {补 }}= [A] _{\text {补 }}+[-B]_{\text {补 }}(\bmod 2)$ 

+ 注意 **符号位需要参与计算**，丢弃符号位的进位

#### 溢出判断

1. 一位符号位判断：参加操作的两个数（减法时即为被减数和“求补” 以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出。换言之，数值部分最高位的进位 $\oplus$ 符号位的进位 = 1 即为溢出。

2. 两位符号位判溢出：首先使用变形补码，其公式如下。简而言之，对于正数其变形补码（符号位）为 $00$ ，对于负数其变形补码（符号位）为 $11$ 。数值部分可以用原本的取反加一计算。
   $$
   [x]_\text{补}= \begin{cases}x & 1 > x \geq 0 \\ 4+x & 0 > x \geq-1(\bmod 4)\end{cases}
   $$

$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}> x \geqslant 0 \\ 2^{n+2}+x & 0 > x \geqslant-2^{n} \quad\left(\bmod 2^{n+2}\right)\end{cases}
$$

+ 在用变形补码作加法时，2 位符号位要连同数值部分一起参加运算，而且 **高位符号位产生的进位自动丢失**，便可得正 确结果。变形补码判断溢出的原则是：**当 2 位符号位不同时，表示溢出**，否则，无溢出。不论是否发生溢出，高位符号位永远代表其结果真正的符号。

### 乘法运算

先来看一个乘法的改进算法，其计算 $0.1101  \times  0.1011$ 的值，具体过程 [哈工大计组 p85](https://www.bilibili.com/video/BV1t4411e7LH?p=85)。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B9%98%E6%B3%95%E6%94%B9%E8%BF%9B.png" alt="image-20220730234454703" style="zoom:80%;" />

再通过异或电路判断正负，结果为 $0.10001111$ 

通过乘法运算的改进算法可归纳如下：

1. **符号位单独判断。**
2. **乘法运算可用逻辑移位和加法来实现**，比如两个 4 位数相乘，总共需要进行 4 次加法运算和 4 次 **逻辑移位**。
3. 由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积；同时，乘数也右移一位，**空出高位存放部分积的低位。**
4. 每次做加法时，被乘数仅仅与原部分积的高位（被乘数的位数）相加，**其低位被移至乘数所空出的高位位置**。

计算机很容易实现这种运算规则。用一个 **X 寄存器** 存放被乘数，一个 **ACC 寄存器** 存放乘积的高位，另一个 **MQ 寄存器** 存放乘数及乘积的低位，再配上加法器及其他相应电路，就可组成乘法器。又因加法只在部分积的高位进行，故不但节省了器材，而且还缩短了运算时间。

>+ ACC：累加器，用于存放操作数，或运算结果。
>
>+ MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。
>
>+ X：通用的操作数寄存器，用于存放操作数
>
>+ ALU：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算

#### 原码一位乘法

1. 符号位用异或单独判断

2. 数值部分按照绝对值相乘（先加再 **逻辑右移**）

3. 每次加法根据 **MQ 寄存器**（存放乘数及乘积低位）的末位确定：

   + 1： $ACC+[\lvert {x}\rvert]_\text{原}$ 

   + 0： $ACC + 0 $ 

4. 用右移的次数（等于乘数的位数，或者机器字长）判断是否结束

#### 补码一位乘法

1. 符号位参与运算
2. 先加再 **补码的算术右移**，最后再加
3. 辅助位：指 **MQ 寄存器** 扩展的一位末位，其初始值为 0。每次右移时其值被更新为末位的值
4. **ACC 寄存器** 和 **X 寄存器** 存放的乘积高位和被乘数，都是用 **双符号位记录**
5. 每次加法根据 **MQ 寄存器** 的末位和 **辅助位** 确定，使用辅助位 - MQ 最低位的值判断：
   + 1： $ACC+[x]_\text{补}\to ACC$ 
   + 0： $ACC+0\to ACC$ 
   + -1： $ACC+[-x]_\text{补}\to ACC$ 

### 除法运算

回忆一下手算除法，不难总结出二进制手算除法的规律：使用数值部分进行计算，根据除数和余数的大小确定一位商，进行一次减法操作并得到余数。再余数后补零，重复计算直到满足精度或者整除。那么如何在计算机中实现上述过程呢？

为了方便说明，定义被除数 $x$ ，除数 $y$ ，当前的余数 $R$ 

#### 原码恢复余数法

1. 符号位用异或单独判断
2. 数值部分按照 **绝对值** 进行计算，还需要计算除数的绝对值补码和除数相反数的绝对值补码。即 $[\lvert{y}\rvert] _\text{补}$ 和 $[\lvert{-y}\rvert]_\text{补}$ 
3. 使用 **ACC** 存储被除数（当前的余数 $R$ ），使用 **X** 存储除数 $y$ ，使用 **MQ** 存储商
4. 这个方法的精髓就在于：计算机不会直接比较 $R$ 和 $y$ 的大小，而是直接 **商 1**（在 MQ 的末位写入）。然后计算 $ R - y = R + [\lvert{-y}\rvert]_\text{补} \to ACC$ ，将结果写入 **ACC** 后，通过电路判断符号位是否为 0（正数）。如果为 1，则进行 $ R + y \to ACC$ 恢复余数，再改成 **商 0**。
5. 对 **ACC** 和 **MQ** 进行 **逻辑左移**，**MQ** 的最高位填充到 $ACC$ 的末位，末位补零。**最后一次上商后无需左移**
6. 重复 4-5 步，直到商的位数达到机器字长长度。假设得到余数为 00111，则真值为 $0.0111  \times  2^{-n} = 0.0111  \times  2^{-4}$ 。商为 $01101$ ，则商为 $0.1101$ 。再用符号位异或确定商的符号位（余数一定是正数）。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9B%9E%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95.png" alt="image-20220803184738585" style="zoom:80%;" />

#### 原码加减交替法

对恢复余数法进行总结可以发现：

+ 上商 1 后： $2 \times  R -y$ 
+ 上商 0 后： $2 \times (R+y) -y = 2 \times R +y$ 

通过这样的化简，我们可以精简恢复余数法上商 0 的操作，即 **省略恢复余数的步骤**。故又称不恢复余数法。同样也是移位 n 次，上商 n+1 次。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95.png" alt="image-20220803191510289" style="zoom:80%;" />

#### 补码除法

1. 使用双符号位表示正负，符号位参与运算
2. 被除数 $x$ 和除数 $y$ 同号，则 $R = x -y = x+[-y] _\text{补}$ ，否则 $R = x+y = x+ [y]_\text{补}$ 
3. 若余数 $R$ 与除数 $y$ 同好，则商 1，余数左移一位减去除数 $2 \times R - y = 2 \times R +[-y] _\text{补}$ ，否则商 0，余数左移一位加上除数 $2 \times R + y = 2 \times R +[y]_\text{补}$ 。重复 n 次
4. 如果对商的精度没有特殊要求，一般可采用“末位恒置 1”法，这种方法操作简单，易于实现，而且最大误差仅为 $2^{-n}$ 

## 浮点四则运算

### 浮点加减运算

> 由于浮点数尾数的小数点均固定在第一数值位前，所以尾数的加减运算规则与定点数的完全相同。但由于其阶码的大小又直接反映尾数有效值小数点的实际位置，因此当两浮点数阶码不等时，因两尾数小数点的实际位置不一样，尾数部分无法直接进行加减运算。为此，浮点数加减运算必须按以下几步进行。

1. 对阶：使两数的小数点对齐
2. 尾数求和：将对阶后的两尾数按定点加减运算规则求和（差）。
3. 规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。
4. 舍入，为提高精度，要考虑尾数右移时丢失的数值位。
5. 溢出判断，即判断结果是否溢出。

例子： $x = 0.1101 \times 2^{01} \quad y =(-0.1010) \times 2^{11}$ ，计算 $x+y$ 

#### 对阶

对阶的目的是使两操作数的小数点位置对齐，即使两数的阶码相等。为此，首先要求出 **阶差**，再按 **小阶向大阶看齐** 的原则，使阶小的尾数向右移位，每右移一位，阶码加 1，直到两数的阶码相等为止。**右移的次数正好等于阶差**。尾数右移时可能会发生数码丢失，影响精度。（如果选择大阶向小阶看齐，则需要让尾数变大左移，这可能导致最高位丢失造成数据错误）

首先将数据用浮点数补码表示：
$$
[x]_\text{补} = 00,01;\ 00.1101\\
[y]_\text{补} = 00,11;\ 11.0110
$$

+ 四位阶码（两位阶符），六位尾数（两位尾符）

求阶差：
$$
[\Delta j] _\text{补} = [j_x]_\text{补} - [j_y]_\text{补} = 00,01 + 11,01 = 11,10 < 0
$$

+ 阶差为 $11,10 = -2$ ，所以 $j_x+2\quad S_x \to 2$ 

对阶： $[x] _\text{补'} = 00,11; 00.0011 \quad [y]_\text{补} = 00,11;\ 11.0110$ 

#### 尾数求和

将对阶后的两个尾数按定点加（减）运算规则进行运算
$$
[S_x +S_y] _\text{补} = [S_x]_\text{补'}+[S_y]_\text{补} = 00.0011 + 11.0110 = 11.1001
$$

+ $[x+y]_\text{补} = 00,11; 11.1001$ 

#### 规格化

当前基值 $r$ 为 2，那么要求前 1 位即首位不为 0。通过 **左规和右规** 进行规格化，直到尾符和首位不同为止（机器数为补码，且考虑特例 $-1 \ and\  -\frac{1}{2}$ ）

左规：尾数左移，阶码减一
$$
[x+y]_\text{补} = 00,10; 11.0011
$$
右规：尾数右移，阶码加一。只有当尾数的符号位溢出，俩符号位数值不等，即形如 $10.XXX \quad 01.XXX$ 时才进行右规

#### 舍入

在 **对阶和右规** 的过程中，可能会将尾数的低位丢失，引起误差，影响精度。为此可用舍入法来提高尾数的精度。常用的舍入方法有以下两种。

1. “0 舍 1 人”法：类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为 0，则舍去；被移去的最高数值位为 1，则在尾数的末位加 1。这样做可能使尾数又溢出，此时需再做一次右规。
2. “恒置 1”法：尾数右移时，不论丢掉的最高数值位是“1”或“0”，都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。
