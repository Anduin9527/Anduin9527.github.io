---
title: 编译原理（一）--形式语言的基本知识
tags:
  - 笔记
  - 形式语言
category: 编译原理
katex: true
abbrlink: 2017d459
---

## 前言

乔姆斯基将语言形式地定义为由一个 **字母表** 的字母组成的一些串的集合。对于任意一个语言，有一个字母表，可以在字母表上按照一定的形成规则定义一个 **文法**，这个文法所产生的所有句子组成的集合就是这个文法所产生的语言

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220929175049.png" alt="image-20220929175049806" style="zoom:67%;" />

<!--more-->

## 字母表和符号串

### 基本概念

+ 字母表（符号集）是符号的 **有穷非空集合**，通常记为$\Sigma, V$
+ 字母表中的元素称为 **符号**，符号是字母表中不能再分解的最小单位
+ 设$\Sigma$是一个字母表，$\forall x\in \Sigma^*$，则$x$称为$\Sigma$上的一个* *符号串**。符号串是字母表中符号的一个有穷序列
+ 符号串$s$的长度，记作$\lvert s \rvert$，指$s$中符号的个数
+ 符号串集合，如果集合$A$中的所有元素都是字母表$\Sigma$上的符号串，则称$A$为字母表$\Sigma$上定义的符号串集合。也可以称$A$为字母表$\Sigma$上定义的某种语言

### 字母表基本运算

1. 字母表乘积（product）

   字母表 $\Sigma_1$ 和字母表 $\Sigma_2$ 相乘：
   $$
   \Sigma_1 \Sigma_2 = \left\{ab\mid a\in \Sigma_1, b\in \Sigma_2\right\}
   $$
   + 可以用笛卡尔积理解，例如$\{0,1\}\{a, b\}=\{0 a, 0 b, 1 a, 1 b\}$

2. 字母表幂运算（power）
   $$
   \left\{\begin{array}{l}
   \sum^0 =\{\varepsilon\} \\
   \sum^n =\sum^{n-1} \sum, {n} \geq 1
   \end{array}\right.
   $$

   + 字母表的$n$次幂，即长度为$n$的 **符号串** 构成的集合

3. 字母表正闭包（positive closure）
   $$
   \Sigma^{+}=\Sigma \cup \Sigma^2 \cup \Sigma^3 \cup \ldots
   $$

   + 实际上就是长度为正数的 **符号串** 构成的集合

4. 字母表克林闭包（Kleene closure）
   $$
   \Sigma^{*}=\Sigma ^0 +\Sigma^+=\Sigma ^0 \cup \Sigma \cup \Sigma^2 \cup \Sigma^3 \cup \ldots
   $$

   + 实际上就是任意长度的 **符号串** 构成的集合

### 符号串基本运算

1. 符号串连接（concatenation)

   如果 $x$ 和 $y$ 是符号串，那么 $x$ 和 $y$ 的连接就是把 $y$ 附加到 $x$ 后面而形成的串，记作 $xy$

   + 值得注意的是：**空串**$\varepsilon$是连接运算的 **单位元**，所以$s\varepsilon = \varepsilon s = s$

2. 前缀、后缀和子串

   若 $x,y,z$ 都是 $\Sigma$ 上的符号串，那么 $x$ 被称为 $xy$ 的 **前缀**，$y$ 被称为 $xy$ 的 **后缀**，$y$ 被称为 $xyz$ 的 **子串**

   当 $x$ 是 $xy$ 的前缀，且 $x\neq xy$，则 $x$ 被称为 $xy$ 的真前缀

   当 $y$ 是 $xy$ 的后缀，且 $y\neq xy$，则 $y$ 被称为 $xy$ 的真后缀

   当 $y$ 是 $xyz$ 的子串，且 $y\neq xyz$，则 $y$ 被称为 $xyz$ 的真子串

   $\varepsilon$ 是任何串的（真）前缀，（真）后缀以及（真）子串

   符号串 $N$：

   前缀和后缀的数目：1+$\lvert N\rvert $，真前缀和后缀的数目：$\lvert N\rvert$，子串的数目：$1+\frac{\lvert N\rvert+{\lvert N\rvert}^2}{2}$，真子串的数目：$\frac{\lvert N\rvert+{\lvert N\rvert}^2}{2}$

3. 符号串幂运算
   $$
   \left\{\begin{array}{l}
   {s}^0 ={\varepsilon} \\
   {s}^n ={s}^{n-1} s, n \geq 1
   \end{array}\right.
   $$

   + 符号串$s$的$n$次幂，相当于将$n$个$s$连接起来

4. 符号串集合连接

   设 $L_1$ 定义在 $\Sigma_1$ 的符号串集合，$L_2$ 定义在 $\Sigma_2$ 的符号串集合：$L_1 L_2 =\left\{xy \mid x \in L_1, y \in L_2 \right\}$

   + 同样的，也是类似于笛卡尔积的形式
   + $\Phi L = L \Phi  = \Phi$
   + $\left\{\varepsilon\right\}L  = L\left\{\varepsilon\right\} = L$

5. 符号串集合幂运算
   $$
   \left\{\begin{array}{l}
   {L}^0 =\left\{\varepsilon\right\} \\
   {L}^n ={L}^{n-1} L, n \geq 1
   \end{array}\right.
   $$

6. 符号串集合的正闭包
   $$
   L^{+}= L \cup L^2 \cup L^3 \cup \ldots
   $$

7. 符号串集合的闭包
   $$
   L^* = L^0 \cup L^{+}= L \cup L^2 \cup L^3 \cup \ldots
   $$

   + 两个闭包运算，都与字母表的闭包运算大抵相同
   + 由于$\Sigma$本身也可以视作符号串集合，因此将克林闭包$\Sigma^*$称为* *行集合**，表示字母表中的符号以任意顺序，任意个数，任意长度构成的符号串集合

## 语言和文法

> 句子是由本语言字母表上符号按照一定规则组成的符号串。
>
> + 枚举法，如果一个语言仅包含有限条句子，就可以采用枚举法来描述此语言把语言中每条句子都列举出来即可
> + 自动机识别法，在这种方法中，每种语言对应一种自动机（即某种算法）, 由它判定一个符号串是否在该语言中
> + 文法产生法，这种方法是为每种语言定义一组文法规则，从而产生该语言中的每条句子

### 巴克斯-诺尔范式

巴科斯范式是描述语法规则一种表示方法，它是由巴科斯为了在 ALGOL60 报告中来描述 ALGOL 语言首先提出的。采用这种形式体系方式定义语法规则，可以用简洁的公式把各种语法规则严格而清晰描述出来。例如，在高级语言中大家所熟知的 **标识符** 这种语法成分，它用巴科斯范式可以描述为：

<标识符> `::=` <字母> | <标识符> <字母> | <标识符> <数字>

<字母> `::=` a|b|c|…|z

<数字> `::=` 0|1|2|…|9

不难发现，巴克斯范式使用的符号如下：

1. `::=`（或 $\to$），表示 **定义为**
2. `|`，表示多种不同的选择，不同选择称为 **候选式**
3. `< >`，表示语法实体，在比较明确的情况下，可省略

> 比如标识符的定义，就刻画出了其是以 **字母开始（递归定义，总会以字母开始）的** 一串字母和数字任意组合这种特点

产生式：产生式是 **只有一个候选式** 的文法规则，是一个 **非空符号串** 和另一个 **符号串** 的有序偶 $(\alpha,\beta)$，记为 $\alpha::=\beta$ 或 $\alpha\to \beta$。$\alpha$ 称为产生式的 **左部**，$\beta$ 称为产生式的 **右部**。表示 $\alpha$ 定义为 $\beta$。对于有相同左部的产生式，可以用 `|` 简单定义

字汇表：用于产生式左部和右部中所有符号形成集合为字汇表，记为 $V$

字汇表的分类：

1. 非终结符号

   出现在产生式左部，且能 **派生** 出符号或符号串的那些符号称为非终结符，也称语法实体或语法单位，它们的全体构成一个非终结符的集合，记为 $V_N$

2. 终结符号

   产生式中不属于 $V$ 的那些符号称为终结符，它们的全体组成终结符的集合，记为 $V_T$。终结符一般出现在规则的右部

+ 显然，$V = V_N \cup V_T \quad V_N \cap V_T = \Phi$

> 在上面标识符的定义中，
>
> $V_N$ = {<字母>, <数字>, <标识符>}
>
> $V_T$ = {a, b, c…z,0,1,2…9}

### 文法

文法是规则的 **有穷集合**，形式定义为四元组 $G = (V_N, V_T,P,S)$，通常记为 $G[S]$

1. $V_N$ 是非终结符集合
2. $V_T$ 是终结符集合
3. $P$ 代表产生式集
4. $S\in V_N$ 是文法 $G$ 开始符号，也称识别符号，它至少要在一条产生式左部出现

栗子：
$$
G = (V_N, V_T, P, S)\\
V_N = \left\{A, B\right\}\\
V_T = \left\{c, d\right\}\\
P = \left\{A \to Bc, B \to d\right\}\\
S = A
$$

> 通常情况下，在对文法的描述时可以省略 $V_N$ 和 $V_T$，文法的开始符号也可以不需要“显式地”指定，仅需将开始符号写在 G 后的中括号中即可。
>
> 所以上述栗子可以简单描述为：$G[A]:A \to Bc, B \to d$

一些约定：

1. 终结符：$a,b,c...$，$0...9$
2. 非终结符：$A,B,C...$
3. 文法符号（终结符或非终结符）：$X,Y,Z$
4. 终结符号串（包括空串）：$u,v...z$
5. 文法符号串（包含空串）：$\alpha,\beta...$

### 语言

#### 推导和规约

**直接推导和直接归约：** 文法 $G=(V_N,V_T,P,S)$ 有一条产生式 $\alpha\to \beta,\ \alpha\in (V_N\cup V_T)^+,\ \beta\in (V_N\cup V_T)^*$，假设存在符号串 $x,y\in (V_N\cup V_T)^*$，使得有符号串 $v$ 和 $w$ 满足 $v=x\alpha y$ 和 $w=x\beta y$，则称符号串 $v$ **直接推导**（重写）出符号串 $w$, 符号串 $w$ **直接归约** 到符号串 $v$，并把符号串 $w$ 叫作符号串 $v$ 的直接派生式，记为
$$
v \Rightarrow w
$$

+ 简而言之，就是用产生式的右部替换产生式的左部。特别的，如果$x = y = \varepsilon$，则对于文法$G$的任何规则都有$\alpha \Rightarrow \beta$

**推导和归约：** 假设 ${u}_0 \in\left({V}_{{N}} \cup {V}_{{T}}\right)^{+}, \ {u}_1, {u}_2, \cdots, {u}_{{n}}$ 都是 $\left({V}_{{N}} \cup {V}_{{T}}\right)^{*}$ 上定义的符号串，如果存在直接推导序列 ${v}={u}_0 \Rightarrow {u}_1 \Rightarrow {u}_2 \Rightarrow \cdots \Rightarrow {u}_{{n}}={w}({n} \geqslant 1)$，则称符号串 $v$ 经过 $n$ 步 **推导** 出符号串 $w$，串 $w$ 经过 $n$ 步 **归约** 到符号串 $v$，记为
$$
v \Rightarrow^n w
$$

+ 显然，当$n = 1 $时就是 **直接推导**
+ $\Rightarrow ^+$表示经过正数步推导，称为 **推导**
+ $\Rightarrow ^*$表示经过若干步推导（可以是 0 步），称为* *广义推导**
+ 推导的步数，直接数$\Rightarrow$的个数即可

> 栗子 1：$G[A]:A \to B,\ B \to c$
>
> 解：则称 $A$ 直接推导到 $B$，$d$ 归约到 $A$

#### 句型和句子

**句型：** 如果 $S \Rightarrow^* \alpha, \alpha \in\left(V_T \cup V_N\right)^*$, 则称 $\alpha$ 是 $G$ 的一个句型

+ 文法$G$所能产生的 **合法结果** 就是句型
+ 一个句型中既可以包含终结符$V_T$，又可以包含非终结符$V_N$，也可能是空串$\varepsilon$

**句子：** 如果 $S \Rightarrow^* w, w \in V_T^*$, 则称 $w$ 是 $G$ 的一个句子

+ 句子是 **只由终结符构成** 的 **句型**

#### 语言

**语言：** 由文法 $G$ 的开始符号 $S$ 推导出的 **所有句子构成的集合** 称为文法 $G$ 生成的 **语言**，记为 $L(G)$。即
$$
L(G)=\left\{w \mid S \Rightarrow^* w, w \in V_T^*\right\}
$$

+ 要使一个文法$G$能正确描述相应语言$L(G)$必须保证：
  + 由文法$G$产生的每个句子都在$L(G)$中
  + 在语言$L(G)$中的每个符号串都能由$G$产生

> 构造下列语言对应的文法
>
> 栗子 1：$L(G) = \left \{0^n1^n \lvert n\ge 0\right \}$
>
> 解：$G[S] = S \to 01,\ S\to 0S1$
>
> 栗子 2：$L(G) = \left \{0^n1^m \lvert n,m\ge 1\right \}$
>
> 解：$G[S] = S \to 0S,\ S \to S1,\ S\to 01$

**递归文法：** 像上述栗子中形如 $S\to 0S1$，这种借助于自己来定义自己的产生式，即在产生式左部和右部具有 **相同的非终结符** 的产生式称为 **递归规则**。如果一个文法中 **至少含有一个递归非终结符**，则将此文法称为 **递归文法**

+ 若有一个规则$U\to ...U...$则称 **直接递归**
+ 若有规则$U\to U...$，则称 **直接左递归**
+ 若有规则$U\to ...U$，则称 **直接右递归**
+ 若有推导式$U\to^+ ...U...$，则称 **间接递归**，间接递归同样也分为 **间接左递归和间接右递归**
+ 显然，直接递归是间接递归一种特殊情况
+ 非终结符$U$称 **递归非终结符**
+ 如果一个语言是无穷的，则描述该语言的文法必定是递归的。他在给 **无限的语言** 以 **有限的表示** 提供了一种可能的方法，但同时也会带来麻烦，比如文法的 **左递归性**

> 栗子：设有文法 $G$ 的规则 $P$ 为
>$$
>\begin{aligned}
>&{S}::={Q c} \mid {c} \\
>&{Q}::={R b} \mid {b} \\
>&{R}::={S a} \mid {a}
>\end{aligned}
>$$
> 在这 6 条产生式中, 无直接递归规则, 但有如下推导:
>$$
>{Q} \Rightarrow {R b} \Rightarrow {S a b} \Rightarrow {Q c a b}
>$$
> 所以 ${Q} \Rightarrow^+{Q c a b}$，因此是间接左递归

## 句型分析

### 短语和句柄

设 $G[Z]$ 是一个文法，$w=x u y$ 是其中某个句型

**短语：** 若 ${Z} \Rightarrow{ }^* {xUy}, {U} \in {V}_{{N}}$ 且 ${U} \Rightarrow+{u}, {u} \in {V}^{+}$，则称 ${u}$ 是 **一个相对于非终结符号 ${U}$ ，句型 ${w}$ 的短语**

**简单短语：** 若 ${Z} \Rightarrow{ }^* {xUy}$ 且 ${U} \Rightarrow {u}$，则称 ${u}$ 是 **一个相对于非终结符号 $U$ ，句型 ${w}$ 的简单短语**

+ 不难发现，短语的概念是要 **处于某个句型** 以及相对于一个 **非终结符**，即 **推导** 该短语的 **非终结符** 以及该短语所在的 **句型**
+ 根据推导的次数判定是简单短语还是短语

**句柄：** 一个句型 **最左边** 的简单短语（最左简单短语）称为该句型的句柄（或柄短语），句柄最左边的符号称 **句柄的头**，句柄最右边的符号称 **句柄的尾**

> 栗子：设有文法 ${G}[{S}]=(\{{S}, {A}, {B}\},\{{a}, {b}\}, {P}, {S})$, 其中 ${P}$ 为
>$$
>\mathrm{S}::=\mathrm{AB} \quad{A}::=\mathrm{Aa}|\mathrm{bB} \quad{B}::=\mathrm{a}|{Sb}
>$$
> 解：根据句型推导过程有
>$$
>{S} \Rightarrow {AB} \Rightarrow {bBB} \Rightarrow {baB} \Rightarrow {baSb}
>$$
> 可见下式成立:
>$$
>{S} \Rightarrow * {baB} \text { 且 } {B} \Rightarrow {Sb}
>$$
> 则可称子串 Sb 是相对于 **非终结符** B，句型 baSb 的 **简单短语**

**最左（右）推导：** 在任何一步推导 $v\Rightarrow w$ 中，都是对符号串 $v$ 的最左（右）边的 **非终结符号** 进行替换，我们称之为最左（右）推导。我们把最左推导的逆过程称为 **最右归约**，把最右推导的逆过程称为 **最左归约**

**规范推导：最右推导叫作规范推导**，即在该过程的每步直接推导 $xUy\Rightarrow xuy$ 中，符号串 $y$ 只含有终结符号。如果推导 $v\Rightarrow^+ w$ 中 **每步直接推导** 是规范的，则称推导 $v\Rightarrow^+ w$ 为 **规范推导**。由规范推导所得的句型称为 **规范句型**。最左归约也称为 **规范归约**。

### 语法树（CFG 的分析树）

设有文法 $G=(V_N,V_T,P,Z)$，满足下列条件的树即为一个语法树，语法树是推导的 **图形化表示**。换言之，给定一个推导 $S \Rightarrow a_1 \Rightarrow  a_2 \Rightarrow ... \Rightarrow  a_n$ 过程中得到的每一个句型 $a_i$，都可以构造出一个 **边缘** 为 $a_i$ 的语法树，其具体要求如下：

1. 树中每一个结点都有标记，且该标记是 $V_T\cup V_N$ 中某一符号
2. 树 **根结点** 是 **识别符号**（文法开始符号）
3. 若有一个结点至少有一个后继结点，则该结点标记必为 **非终结符**
4. **内部结点** 表示对一个产生式（规则）$\alpha \to \beta$ 的应用，该结点的标号是此产生式左部 $\alpha$。该结点的子结点的标号从左到右构成了产生式的右部 $\beta$
5. **叶结点** 的标号既可以是非终结符，也可以是终结符。**从左到右排列叶节点得到的符号串称为是这棵树的产出（yield)或边缘（frontier)**

以语法树的视角，我们可以重新定义短语：给定一个句型，其分析树中的 **每一棵子树的边缘** 称为该句型的一个 **短语**，以及简单短语：如果子树 **只有父子两代结点**，那么这棵子树的 **边缘** 称为该句型的一个 **直接短语**

> 看个栗子：
> $$
> {S} \Rightarrow {AB} \Rightarrow {bBB} \Rightarrow {baB} \Rightarrow {baSb}
> $$
> <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220922173914.png" alt="未命名绘图.drawio" style="zoom: 50%;" />
>
> 解：
>
> 从语法树可直观看出：ba 是句型 baSb 相对于 A 的短语，Sb 是句型 baSb 相对于 B 的简单短语，a 是句型 baSb 相对于 B 简单短语

## 文法分类

### 文法的二义性

如果一个文法中 **某个句子对应两棵不同的语法树**，则称这个文法是二义的。也就是说，若一个文法中的某句子对应两个不同的最左推导或最右推导，则这个文法是二义的。已经证明，**不存在一种算法** 能在有限的步骤内确切地判定一个文法是否有二义性。若产生某语言的文法 **都是二义性文法**，则称该语言为 **二义性语言**，也称之为 **先天二义性**

解决二义性的办法：

1. 在语义上加些限制，或者加一些非语法形式的规定
2. 对原二义性文法加上一定的条件，将其改造成一个等价的无二义性文法

### 文法的乔姆斯基分类

#### 0 型文法

0 型文法（Type-0 Grammar），又称为无限制文法/短语结构文法（Phrase Structure Grammar，PSG），由 0 型文法产生的语言称为 0 型语言/短语结构语言（Phrase Structure Language，PSL）

要求 $\forall \alpha \to \beta \in P$，其中 $\alpha $ 至少有一个非终结符，$P$ 为文法 $G$ 的产生式集合

#### 1 型文法

1 型文法（Type-1 Grammar），又称为上下文有关文法（Context-Sensitive Grammar，CSG），由 1 型文法产生的语言称为上下文有关语言

在 0 型文法的基础上，要求 $\lvert \alpha \rvert \le \lvert \beta \rvert$，其产生式的一般形式为 $u A w \to u \beta w$（大写字母约定为非终结符，小写希腊字母为终结符，小写字母为终结符号串）

+ 特别的，允许 1 型文法出现$S \to \varepsilon$，但这种情况要求$S$不能再出现在任何产生式右部

#### 2 型文法

2 型文法（Type-2 Grammar），又称为上下文无关文法（Context-Free Grammar，CFG），由 2 型文法产生的语言称为上下文无关语言

在 1 型文法的基础上，要求 $\forall \alpha \to \beta \in P, \ \alpha \in V_N$，其产生式的一般形式为 $A \to \beta$

#### 3 型文法

3 型文法（Type-2 Grammar），又称为正则文法（Regular Grammar，RG），由 3 型文法产生的语言称为正则语言。3 型文法可以分为 **右线性文法** 和 **左线性文法**

在 2 型文法的基础上，其要求产生式的右部可以为 **一个非终结符和终结符**，其一般形式如下

+ 右线性文法：$A\to bB$或$A\to b$
+ 左线性文法：$A\to Bb$或$A\to w$

**0 型文法** 和 **1 型文法** 在高级程序设计语言中很少使用，很多高级语言的语法结构都使用 **2 型文法** 来描述，而词法结构使用 **3 型文法** 来描述。最基本的是 **0 型文法**，可以将它理解为 **其他所有文法的基础**。后续的每个文法都是在前一个文法的基础上添加条件，所以就语言的表示的范围而言：$L_0 \supset L_1 \supset L_2 \supset L_3$

快速判断文法类型：

先观察文法所有产生式左部是否只有 1 个非终结符号

+ 是：查看文法所有产生式是否满足正则文法的要求
  + 是：3 型
  + 否：2 型
+ 否：查看文法所有产生式是否满足左部长度小于等于右部长度
  + 是：1 型
  + 否：0 型

| 文法类型 | 文法名称       | 自动名称       |
| -------- | -------------- | -------------- |
| 0        | 短语结构文法   | 图灵机         |
| 1        | 上下文有关文法 | 线型界限自动机 |
| 2        | 上下文无关文法 | 下推自动机     |
| 3        | 正规文法       | 有穷状态自动机 |

#### 压缩文法

对于 2 型文法和 3 型文法，满足以下两点限制可被称为 **压缩过文法**：

1. 在文法中不含有形如 $A \to A$ 的规则（去除部分二义性的情况）
2. 在文法中不包含多余规则
   1. 每一个非终结符 $A$ 必须在某句型中出现，否则为不可到达，应去除
   2. 每一个非终结符 $A$ 必须能推导出终结符号串 $t$，否则为不可终止，应去除

### 文法的其他表示方法

#### 扩充巴科斯范式

在文法 **BNF** 表示中，使用下列 4 个元语言符号：`<,>,::=,|`。在扩充的 **BNF** 中，除了使用上述 4 个元符号外，还引入以下 6 个元语言符号使用，这 6 个符号是 `{,},[,],(,)`。和普通括号一样，这 6 个符号在文法中是 **两两成对** 出现

1. 花括号 `{}`

   1. $\left \{ \beta \right \}^m_n$ 表示符号串 $\beta$ 可重复出现 $[n,m]$ 次
   2. $\left \{ \beta \right \}_n$ 表示符号串 $\beta$ **不出现** 或至多出现 $n$ 次
   3. $\left \{ \beta \right \}^m$ 表示符号串 $\beta$ 至少重复 $m$ 次
   4. $\left \{ \beta \right \}$ 表示符号串 $\beta$ **不出现** 或 **出现任意多次**

   > 栗子：<标识符> ::= <字母> | <标识符>  <字母> |  <标识符>  <数字>
   >
   > 引入花括号，则可以表示为
   >
   > <标识符> ::= <字母> { <字母> | <数字> }

   采用花括号表示文法，除能方便表示重复次数外，还能 **消除文法中左递归**，这在采用自顶向下语法分析时将是十分有用的

2. 方括号 `[]`

   方括号用来表示 **可供选择的** 符号串，即 $[\beta] = \varepsilon$ 或者等价于 $\left \{ \beta \right \}^1_0$

   > 栗子：Z::= AB|AC|A
   >
   > 引入方括号，则可以表示为
   >
   > Z::= A [B|C]

3. 圆括号 `()`

   圆括号可以在规则中 **提取因子**，但是要注意不要把元语言符号圆括号和规则中出现的（和）**终结符** 相混

   > 栗子：Z::= AB|AC
   >
   > 引入圆括号，则可以表示为
   >
   > Z::= A(B|C)

#### 语法图

语法图表示法由以下三种符号组成

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220929160737.png" alt="image-20220929160730105" style="zoom:80%;" />

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220929160852.png" alt="image-20220929160852515" style="zoom:80%;" />

## 小结

本章是编译原理课程的理论基础，介绍了形式语言的基本概念和理论，主要内容如下：

1. 形式语言是指用一组数学符号和规则来描述的语言。任何一种语言，都是由该语言的字母表中的基本符号所组成的满足一定规则的符号串的集合。符号串的基本概念及有关运算（连接运算、幂运算和闭包运算等）是理解形式语言的前提
2. 文法是描述语言语法结构的规则，可以形式化地表示为一个四元组 $G=(V_N,V_T,P,S)$。语言是文法所产生的所有句子的集合。给定一个文法，可以通过推导从而确定它所产生的语言。给定一个语言，能确定其文法，但还没有形式化的方法，而且得到的文法可能不是唯一形式，但这些文法都是等价的。如果语言是无穷的，描述该语言的文法一定是递归的
3. 对于给定的句型，可以通过自顶向下推导和自底向上的归约对其进行分析，本章给出了在句型分析的过程中会涉及短语、简单短语和句柄的概念，语法树的构造过程，以及二义性文法的定义和消除方法
4. 乔姆斯基通过对文法产生式左部和右部给予了不同限制，将文法分成四种类型，分别对应四种不同的语言和自动机。
5. 文法除了 BNF 范式表示方法外，还可以使用诸如 EBNF 和语法图等其他表示方法
6. 在编写文法时，要注意有害规则和多余规则