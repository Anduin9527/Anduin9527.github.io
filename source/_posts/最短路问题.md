---
title: 从零开始的算法-最短路问题
tags:
  - 算法
  - 优先队列
  - 图
category: 算法学习
katex: true
abbrlink: adfa5e63
date: 2021-12-07 17:51:02
---

## 前言

呜呜呜，考试月要来 li

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20211207175750.png" style="zoom:50%;" />

<!--more-->



## 单源最短路

**最短路径** 问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。

### 形式

- **确定起点的最短路径问题** - 也叫单源最短路问题，即已知起始结点，求最短路径的问题。在边权非负时适合使用 [Dijkstra 算法](https://zh.wikipedia.org/wiki/Dijkstra算法)，若边权为负时则适合使用 [Bellman-ford 算法](https://zh.wikipedia.org/wiki/Bellman-ford) 或者 [SPFA 算法](https://zh.wikipedia.org/wiki/SPFA算法)。
- **确定终点的最短路径问题** - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在 [无向图](https://zh.wikipedia.org/wiki/無向圖) 中该问题与确定起点的问题完全等同，在 [有向图](https://zh.wikipedia.org/wiki/有向图) 中该问题等同于把所有路径方向反转的确定起点的问题。
- **确定起点终点的最短路径问题** - 即已知起点和终点，求两结点之间的最短路径。
- **全局最短路径问题** - 也叫多源最短路问题，求图中所有的最短路径。适合使用 [Floyd-Warshall 算法](https://zh.wikipedia.org/wiki/Floyd-Warshall算法)。

### 性质

+ 对于边权为正的图，最短路不会经过重复的结点与边
+ 对于边权为正的图，最短路的结点数不会超过 $n$ ，边数不会超过 $n-1$ 
+ **负圈**：总边权值小于零的环，存在负圈时会导致某些算法死循环。

### 一些约定

+ $n$ 为结点数， $m$ 为边数
+ $s$ 为最短路的起始点
+ $dis(u)$ 为 $s$ 点到 $u$ 点的 **动态最短路长度**
+ $w(u, v)$ 为 $(u, v)$ 的边权

### 松弛操作

由于最短路的算法，大部分的都有用到松弛（relax）操作，所以这里先理清楚。

最短路径的估计值（ $dis$ ）起初是被高估的（初始化为 $INF$ ），就好像一个被拉长的弹簧。但事实上，我们可以找到更短的路径来替代这个弹簧，导致弹簧不再紧绷，而是放松下来，不断更新，最终找到最短路径。其实就是一种动态规划的思想。

公式：对于边 $(u, v)$ ，有 $dis(v)= min(dis(v), dis(u)+w(u, v))$ 

## Floyd-Warshall

### 思想

求两点 $i，j$ 之间的的距离，可以分成两种情况考虑。即经过某个点 $k$ ，或者不经过某个点 $k$ ，然后就取两者中的较短路径，最终得到最短路径。<del> 就是动态规划 </del>。那么，记 $f(x, y)$ 为 x 到 y 的最短路径长度，可以得到

​							 $f(x, y)= min(f(x, y), f(x, k)+f(k, y))$ 

### 实现

使用邻接矩阵 $G$ 储存图，初始化为 $INF$ 。

```
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```



### 细节

+ 显然是 $O(n^3)$ 
+ 可以得到图上所有点到所有点的最短路 $d [i][j]$ 
+ 不难发现， $d [i][i]$ 最后的值为，从 $i$ 出发到 $i$ 的最短路径，也就是出去绕一圈回来的路径
+ 利用上述条件，Floyd 算法可以快速判断图中是否存在 **负圈**，也就是判断 $diag(d)$ 是否存在小于 0 的值

## Bellman-Ford

### 思想

不断尝试对图上的每一条边进行 **松弛操作**，直到一次循环结束，没有边进行松弛操作为止。

### 实现

```cpp
struct edges
{
  int v;
  int w;
};
vector<edges> e[maxn];
int dis[maxn];
void bellmanford(int n, int s)
{
  fill_n(dis,n+1,INF);
  dis[s] = 0;
  bool flag = true;
  int k = 0;
  while (flag)
  {
    flag = false;
    k++;
    if (k > n)
    {
      puts("存在负圈!");
      return;
    }
    for (int u = 1; u <= n; u++)
      for (auto i : e[u])
        if (dis[i.v] > dis[u] + i.w)
        {
          dis[i.v] = dis[u] + i.w;
          flag = true;
        }
  }
}
```

### 细节

+ 每次循环遍历边的复杂度显然是 $O(m)$ 。每进行一次松弛，则会让最短路的边数+1，而最短边的上限为 $n-1$ ，所以为 $O(nm)$ 
+ Bellman 算法从 $s$ 出发，如果抵达一个负环，松弛操作会无限进行下去，但是由于最短路边数存在上限 $n-1$ ，所以也可以快速判断 **负圈**
+ 上述结论其实不大严谨

> 负环判断中存在的常见误区
>
> 需要注意的是，以 S 点为源点跑 Bellman-Ford 算法时，如果没有给出存在负环的结果，只能说明从 S 点出发不能抵达一个负环，而不能说明图上不存在负环。
>
> 因此如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为 0 的边，然后以超级源点为起点执行 Bellman-Ford 算法。

### 优化

根据前面的思想可以知道，计算和调整结点 $u$ 到结点 $s$ 的最短距离后，如果紧接着调整 $u$ 的邻居结点，势必会触发新的 **松弛操作**，而 Bellman 算法，则在尝试大量不相关结点的边松弛操作，这显然是低效的。

因此，在计算结点 $u$ 之后，下一部只计算和调整它的邻居节点，这样就能大幅度加快收敛的过程。而这显然类似于 $BFS$ ，所以不难想到用队列进行操作，而这就是 ~~被广为诟病的~~ SPFA。

```cpp
struct edge
{
  int v, w;
};
vector<edge> e[maxn];
int dis[maxn], cnt[maxn], vis[maxn];
queue<int> q;
void SPFA(int n, int s)
{
  fill_n(dis,n+1,INF);
  dis[s] = 0, vis[s] = 1;
  q.push(s);
  while (!q.empty())
  {
    int u = q.front();
    q.pop(), vis[u] = 0;
    for (auto i : e[u])
    {
      int v = i.v, w = i.w;
      if (dis[v] > dis[u] + w)
      {
        dis[v] = dis[u] + w;
        cnt[v] = cnt[u] + 1; // 记录最短路经过的边数
        if (cnt[v] >= n)
        {
          puts("存在负圈");
          return;
        }
        if (!vis[v])
          q.push(v), vis[v] = 1;
      }
    }
  }
}
```

+ SPFA 并不稳定，其最坏情况同样也是 O(nm)

## Dijkstra

### 思想

将结点分成两个集合， $S$ （已确定最短路长度的点集）， $T$ （未确定最短路长度的点集），初始化 $dis(s)= 0, dis(else)= INF$ 

然后重复以下操作，直到 $T$ 为空

1. 从 $T$ 中，选取最短路长度最小的结点，移动到 $S$ 中
2. 对刚加入 $S$ 的结点的所有出边进行松弛操作

### 实现

```cpp
struct edge
{
  int v, w;
};
vector<edge> e[maxn];
int dis[maxn], vis[maxn];
void dijkstra(int n, int s)
{
  fill_n(dis,n+1,INF);
  dis[s] = 0;
  for (int i = 1; i <= n; i++)
  {
    int u = 0, mind = INF;		//mind为u的最短路长度
    for (int j = 1; j <= n; j++)
      if (!vis[j] && dis[j] < mind)
        u = j, mind = dis[j];
    vis[u] = true;
    for (auto i : e[u])
    {
      int v = i.v, w = i.w;
      if (dis[v] > dis[u] + w)
        dis[v] = dis[u] + w;
    }
  }
}
```

### 优化

如果不适用任何数据结构维护，显然复杂度为 $O(n^2+m)$ ，考虑使用二叉堆或者优先队列进行优化

```cpp
vector<edge> e[maxn];
struct node {
  int dis, u;
  bool operator>(const node& a) const { return dis > a.dis; }
};
int dis[maxn], vis[maxn];
void dijkstra(int n, int s)
{
  fill_n(dis,n+1,INF);
  dis[s] = 0;
  priority_queue<node, vector<node>, greater<node>> q; //创建优先级队列
  q.push((node){0, s});
  while (!q.empty())
  {
    int u = q.top().u;
    q.pop();
    if (vis[u])
      continue;
    vis[u] = 1;
    for (auto i: e[u])
    {
      int v = i.v, w = i.w;
      if (dis[v] > dis[u] + w)
      {
        dis[v] = dis[u] + w;
        q.push({dis[v], v});
      }
    }
  }
}
```

+ 由于二叉堆和优先队列的插入删除元素只需要 $O(logn)$ ，所以复杂度可以达到 $O((m+n)logn)$ 和 $O(mlogn)$ 

## 打印路径问题

比较简单，用一个整形数组 path，在更新距离的时候，记录点是如何转移的即可

比如 Floyd 就要记录 `path[i][j] = k;`，Bellman-Ford 和 Dijkstra 一般记录 `path[v] = u`。

## 参考

[OI-WIKI](https://oi-wiki.org/graph/shortest-path/)

《算法导论》

