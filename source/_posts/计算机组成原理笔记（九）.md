---
title: 计算机组成原理笔记（九）
tags:
  - 笔记
  - 硬件
category: 计算机组成原理
katex: true
abbrlink: c4a21082
---



## 前言

真不戳，住在郊区真不戳

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/asdasd.jpg" alt="100819348_p0_master1200" style="zoom: 50%;" />

<!--more-->

## 微操作命令分析

控制单元具有发出各种 **微操作命令**（即控制信号）序列的功能。而不同的指令对应不同的命令。进一步分析发现，完成不同指令的过程中，有些操作是相同或相似的，如取指令、取操作数地址（当间接寻址时）以及进入中断周期由中断隐指令完成的一系列操作。为更清晰起见，下面按指令周期的 4 个阶段进一步分析其对应的微操作命令。

下面开始分析，其中除了执行周期以外的周期都在 **指令流水** 章中介绍过了，不再赘述

### 执行周期

不同指令执行周期的微操作是不同的，下面分别讨论非访存指令、访存指令和转移类指令的微操作

#### 非访存指令

顾名思义，这类指令在执行周期不会访问存储器

1. 清除累加器指令 $CLA$

   完成清除累加器操作，记作 $0 \to ACC$

2. 累加器取反指令 $COM$

   将累加器中的内容取反，记作 $\overline{ACC} \to ACC$

3. 算术右移一位指令 $SHR$

   将累加器中的内容进行算术右移一位，先右移，记作 $L(ACC)\to R(ACC)$，然后保证符号位（最高位）不变 $ACC_0 \to ACC_0$

4. 循环左移一位指令 $CSL$

   将累加器中的内容进行循环左移一位，先左移，记作 $R(ACC) \to L(ACC)$，然后将原本的最高位变为最低位，记作 $ACC_0 \to ACC_n$

5. 停机指令 $STP$

   计算机中有一个运行标志触发器 $G$，当其值为 1 时，表示机器运行；反之，则为停机。$STP$ 指令在执行阶段只需将运行标志触发器置零，记作 $0 \to G$

#### 访存指令

这类指令在执行阶段都需要访问存储器。简单起见，这里只考虑直接寻址的情况

1. 加法指令 $ADD \ X$

   该指令将了累加器的内容与主存 $X$ 地址单元的内容相加，结果送入累加器。具体过程如下

   1. 将指令的地址码部分送至存储器地址寄存器，记作 $Ad(IR)\to MAR$
   2. 向主存发读命令，启动主存作读操作，记作 $1 \to R$。
   3. 将 $MAR$（通过地址总线）所指的主存单元中的内容（操作数）经数据总线读至 $MDR$ 内，记作 $M(MAR)\to MDR$。
   4. 给 $ALU$ 发送加命令，将 $ACC$ 的内容和 $MDR$ 的内容相加，结果存于 $ACC$, 记作 $(ACC)+(MDR)\to ACC$

   当然，也有的加法指令指定两个寄存器的内容相加，如 $ADD AX BX$，该指令在执行阶段无须访存，只需完成 $(AX)+(BX)\to AX$ 的操作。

2. 存数指令 $STA \ X$

   该指令在执行阶段需将累加器 $ACC$ 的内容存于主存的 $X$ 地址单元中，具体操作如下

   1. 将指令的地址码部分送至存储器地址寄存器，记作 $Ad(IR) \to MAR$
   2. 向主存发写命令，启动主存作写操作，记作 $1\to W$
   3. 将累加器内容送至 $MDR$, 记作 $ACC\to MDR$
   4. 将 $MDR$ 的内容（通过数据总线）写入到 $MAR$(通过地址总线）所指的主存单元中，记作 $MDR\to M(MAR)$

3. 取数指令 $LDA\ X$

   该指令在执行阶段需将主存的 $X$ 地址单元中的内容取至累加器 $ACC$ 中，具体操作如下

   1. 将指令的地址码部分送至存储器地址寄存器，记作 $Ad(IR) \to MAR$
   2. 向主存发读命令，启动主存作写操作，记作 $1\to R$
   3. 将 $MAR$（通过地址总线）所指的主存单元中的内容（操作数）经过数据总线送入 $MDR$ 内，记作 $(MAR) \to MDR$
   4. 将 $MDR$ 的内容送至 $ACC$ 中，记作 $MDR\to ACC$

#### 转移类指令

1. 无条件转移指令 $JMP \ X$

   该指令在执行阶段完成将指令的地址码部分 X 送至 PC 的操作，记作 $Ad(IR)\to PC$

2. 条件转移指令中的 **负则转** 指令 $BAN \ X$

   该指令根据上一条指令运行的结果决定下一条指令的地址，若结果为负（累加器最高位为 1, 即 $A_0 =1$），则指令的地址码送至 $PC$，否则程序按原顺序执行

   由于在取指阶段已完成了 $(PC)+1\to PC$，所以当累加器结果不为负时，就按取指阶段形成的 $PC$ 执行，记作 $A_0 \cdot{Ad}(IR)+\bar{A_0}(PC) \to PC$

#### 三类指令的指令周期

+ 非访存：取指，执行
+ 直接访存：取指，执行
+ 间接访存：取指，间址，执行
+ 转移：取指，执行
+ 间接转移：取指，间址，执行

## 控制单元的功能

### 控制单元的外特性

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E5%A4%96%E7%89%B9%E6%80%A7.png" alt="image-20220829185843527" style="zoom:80%;" />

#### 输入信号

1. 时钟

   为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制，即每一个时钟脉冲使控制单元发送一个操作命令，或发送一组需要同时执行的操作命令

2. 指令寄存器

   现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，故指令的操作码字段是控制单元的输入信号，它与时钟配合可产生不同的控制信号

3. 标志

   控制单元有时需依赖 CPU 当前所处的状态（如 ALU 操作的结果）产生控制信号，控制单元要根据上条指令的结果是否为负而产生不同的控制信号。因此“标志”也是控制单元的输入信号。

4. 来自系统总线（控制总线）的控制信号

   例如，INTR 中断请求，HRQ 总线请求

#### 输出信号

1. CPU 内的控制信号

   主要用于 CPU 内的寄存器之间的传送和控制 ALU 实现不同的操作

2. 送至系统总线（控制总线）的信号

   例如，命令主存或 I/O 读写，中断响应等

### 控制信号举例

#### 单总线结构数据通路方式

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image-20220829211519492" style="zoom:80%;" />

+ 内部总线：指同一部件，如 CPU 内部连接各寄存器及运算部件之间的总线
+ 系统总线：指同一台计算机系统的各部件，如 CPU、内存、通道和各类 I/O 接口间互相连接的总线

1. 寄存器之间的数据传送

   例，$PC$ 内容送至 $MAR$：

   1. $(PC) \to Bus$，$PCount$ 有效
   2. $Bus \to MAR$，$MARin$ 有效

2.  主存与 CPU 之间的数据传送

   例，CPU 从主存读取指令：

   1. $(PC) \to Bus \to MAR$，$PCout,MARin$ 有效
   2. $1 \to R$，$CU$ 经过控制总线发送读信号
   3. $M(MAR) \to MDR $，$MDRinE$（带有 $E$ 表示与主存的数据通路）有效
   4. $MDR \to Bus \to IR$，$MDRin, IRin$ 有效
   5. $(PC)+1 \to PC$

3. 执行算术或逻辑运算

   例，加法指令（其中一个操作数已在 $ACC$ 中）

   1. $Ad(IR) \to Bus \to MAR$，$IRout,MARin$ 有效
   2. $1 \to R$，$CU$ 发送读命令
   3. $M(MAR) \to MDR$，$MDRinE$ 有效
   4. $MDR \to Bus \to Y$，$MDRout, Yin$ 有效，让操作数存放于暂存寄存器（因为 CPU 的数据总线是 **单总线** 只能同时传送一个输入信号，所以让 $ACC$ 走总线，而把另一个操作数放置于与 $ACC$ 有专用数据通路的 $Y$ 寄存器之中）
   5. $(ACC) +(Y) \to Z$，$ACCout,ALUin$ 有效，$CU$ 向 $ALU$ 发送加命令
   6. $Z \to ACC$，$Zout,ACCin$ 有效 

#### 专用数据通路方式

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%93%E7%94%A8%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E6%96%B9%E5%BC%8F.png" alt="image-20220829194527188" style="zoom:80%;" />

1. 取指周期
   1. $(PC) \to MAR$，$C_0$ 有效
   2. $(MAR) \to MEM$，$C_1$ 有效
   3. $1 \to R$，$CU$ 向主存发送读命令
   4. $M(MAR)\to MDR$，$C_2$ 有效
   5. $(MDR)\to IR$，$C_3$ 有效
   6. $(PC)+1 \to PC$
   7. $OP(IR) \to CU$，$C_4$ 有效，对指令译码

2. 间址周期
   1. $(MDR)\to MAR$，$C_5$ 有效
   2. $(MAR) \to MEM$，$C_1$ 有效
   3. $1 \to R$，$CU$ 向主存发送读命令
   4. $M(MAR)\to MDR$，$C_2$ 有效，此时 $MDR$ 就保存了操作数的地址
   5. $(MDR)\to IR$，$C_3$ 有效
3. 执行周期，以 $ADD $ 为例
   1. $(MDR)\to MAR$，$C_5$ 有效
   2. $(MAR) \to MEM$，$C_1$ 有效
   3. $1 \to R$，$CU$ 向主存发送读命令
   4. $M(MAR)\to MDR$，$C_2$ 有效，此时 $MDR$ 就保存了操作数本身
   5. $(MDR) + (ACC) \to ACC$，$C_6,C_7,C_8$ 有效

### 多级时序系统

#### 机器周期

机器周期可看做是所有指令执行过程中的一个 **基准时间**，机器周期取决于指令的功能及器件的速度。分析发现，机器内的各种操作大致可归属为对 **CPU 内部的操作** 和 **对主存的操作** 两大类，由于 CPU 内部的操作速度较快，CPU 访存的操作时间较长，因此通常 **以访问一次存储器的时间** 定为基准时间较为合理，这个基准时间就是机器周期。又由于不论执行什么指令，都需要访问存储器取出指令，因此在 **存储字长等于指令字长的前提下，取指周期也可看做机器周期**。

#### 时钟周期

在 **一个机器周期里可完成若干个微操作**，每个微操作都需要一定的时间，可用时钟信号来控制产生每一个微操作命令。时钟就好比计算机的心脏，只要接通电源，计算机内就会产生时钟信号。时钟信号可由机器主振电路（如晶体振荡器）发出的脉冲信号经整形（或倍频、分频）后产生，时钟信号的频率即为 **CPU 主频**。用时钟信号控制节拍发生器，就可产生 **节拍**。每个节拍的宽度正好对应一个 **时钟周期**。在每个节拍内机器可完成一个或几个需同时执行的操作，它是 **控制计算机操作的最小时间单位**。

#### 多级时序系统

+ 机器周期、节拍（状态）组成多级时序系统
+ 一个指令周期包含若干个机器周期
+ 一个机器周期包含若干个时钟周期

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%A4%9A%E7%BA%A7%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F.png" alt="image-20220829215457197" style="zoom: 67%;" />

一般来说，CPU 的主频越快，机器的运行速度也越快。在机器周期所含时钟周期数相同的前提下，两机平均指令执行速度之比等于两机主频之比。例如，CPU 的主频为 $8MHz$，其平均指令执行速度为 $0.8MIPS$。若想得到平均指令执行速度为 $0.4MIPS$ 的机器，则只需要用主频为 $(8MHz×0.4MIPS)/0.8MIPS=4MHz$ 的 CPU 即可。实际上机器的速度不仅与主频有关，还与机器周期中所含的时钟周期数以及指令周期中所含的机器周期数有关。同样主频的机器，由于机器周期所含时钟周期数不同，运行速度也不同。机器周期所含时钟周期数少的机器，速度更快。

### 控制方式

控制单元控制一条指令执行的过程实质上是依次执行一个确定的微操作序列的过程。由于不同指令所对应的微操作数及其复杂程度不同，因此每条指令和每个微操作所需的执行时间也不同。通常将如何形成控制不同微操作序列所采用的时序控制方式称为 $CU$ 的控制方式。常见的控制方式有同步控制、异步控制、联合控制和人工控制。

#### 同步控制

同步控制方式是指，任何一条指令或指令中任何一个微操作的执行都是事先确定的，并且都是受 **统一基准时标的时序信号** 所控制的方式。如果机器内的存储器存取周期不统一，那么只有把 **最长的存取周期作为机器周期**，才能采用同步控制，否则取指令和取数时间不同，无法用统一的基准。又如有些不访存的指令，执行周期的微操作较少，无须那么多节拍。因此，为了提高 CPU 的效率，在同步控制中又有三种方案

1. 采用定长的机器周期

   一律以最长的微操作序列和最繁的微操作作为标准，采取完全统一的、具有相同时间隔和相同数目的节拍作为机器周期来运行各种不同的指令。显然，这种方案对于微操作序列较短的指令来说，会造成时间上的浪费。

2. 采用不定长的机器周期

   每个机器周期内的节拍数可以不等。这种控制方式可解决微操作执行时间不统一的问题。通常把大多数微操作安排在一个较短的机器周期内完成，而对某些复杂的微操作，采用 **延长机器周期** 或 **增加节拍** 的办法来解决。

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F.png" alt="image-20220829220707428" style="zoom:80%;" />

3. 采用中央控制和局部控制相结合的方法

   这种方案将机器的大部分指令安排在统一的、较短的机器周期内完成，称为中央控制，而将少数操作复杂的指令中的某些操作（如乘除法和浮点运算等）采用局部控制方式来完成

   在设计局部控制线路时需要注意两点：

   1. 使局部控制的每一个节拍 $T^*$ 的宽度与中央控制的节拍宽度相同
   2. 将局部控制节拍作为中央控制中机器节拍的延续，插入到中央控制的执行周期内，使机器以同样的节奏工作，保证了局部控制和中央控制的同步。$T^*$ 的多少可根据情况而定

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%AD%E5%A4%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E5%B1%80%E9%83%A8%E6%8E%A7%E5%88%B6%E7%9B%B8%E6%9C%BA%E5%92%8C.png" alt="image-20220829222552838" style="zoom: 60%;" />

#### 异步控制

异步控制方式不存在基准时标信号，没有固定的周期节拍和严格的时钟同步，执行每条指令和每个操作需要多少时间就占用多少时间。这种方式微操作的时序由 **专门的应答线路控制**，即当 $CU$ 发出执行某一微操作的控制信号后，等待执行部件完成了该操作后发回 **回答信号**，再开始新的微操作，使 CPU 没有空闲状态，但因需要采用各种应答电路，故其结构比同步控制方式复杂。

#### 联合控制方式

同步控制和异步控制相结合就是联合控制方式。这种方式对各种不同指令的微操作实行大部分统一、小部分区别对待的办法。例如，对每条指令都有的取指令操作，采用同步方式控制；对那些时间难以确定的微操作，如 I/O 操作，则采用异步控制，以执行部件送回的“回答”信号作为本次微操作的结束。

#### 人工控制方式

人工控制是为了调机和软件开发的需要，在机器面板或内部设置一些开关或按键，来达到人工控制的目的。