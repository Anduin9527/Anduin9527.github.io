---
title: 暑假补题记录(1)
katex: true
tags:
  - C++
  - 算法
categories: 算法学习
abbrlink: 6dab2108
date: 2021-07-21 08:58:00
---

### 前言

第一次正经打 ICPC 赛制的比赛。和队友合力砍下 24 的罚时，可喜可贺，可喜可贺……莫队在学了在学了……

<!--more-->

## 1001 Mod, Or and Everything

### 描述

> **Problem Description**
>
> You are given an integer n.
>
> You are required to calculate (n mod 1) or (n mod 2) or ... or (n mod (n - 1)) or (n mod n).
>
> The "or" operation means "bitwise OR".
>
> **Input**
>
> The first line contains an integer $T(1 ≤ T ≤ 5000$ )representing the number of test cases.
>
> For each test case, there is an integer $n(1 ≤ n ≤ 10^{12}$ ​​)in one line.
>
> **Sample Input**
>
> ```
> 5
> 1
> 2
> 3
> 4
> 5
> ```
>
> **Sample Output**
>
> ```
> 0
> 0
> 1
> 1
> 3
> ```

### 题意分析

求将 n 模 1 到 n-1 的值全部 **按位或** 的结果，其中 **按位或** 就是指用二进制展开之后，逐位进行或运算。

以 5 为例，`5 % 1 = 0 ` `5 % 2 = 1` `5 % 3 = 2` `5 % 4 = 1`, 那也就是 `0|1|2|1`, 二进制展开得 `00|01|10|01`

显然答案是 11 也就是 3，可以发现只有数位为 1 的数才会对答案有贡献。那么问题就可以转化成求取的 n-1 个值全部转化为二进制表示之后，可以得到多少个不重复的值为 1 的数位。

继续打表寻找规律，可以发现：

+ `n mod i` 会在中间取到一个最大值 m，对于偶数来说 i 是 `n/2 + 1` ，对奇数是 `(n+1) / 2`
+ 进一步观察可以发现 m 的值也可以直接得到, 对于偶数来说 m 是 `n/2 - 1` ，对奇数是 `(n-1) / 2`
+ 打表可得，当 i <= m 时，有`n mod (n-i)= i`，换句话说就是可以取得从 0~m 的所有值，再换言之就是可以把 m 的二进制位数全用 1 铺满

显然只需把 m 变成二进制数，然后求得 m 的位数 k，那么答案就是 $2^k-1$ 

问题就变成了 **如何计算一个十进制数字的二进制位数**

### 算法

#### 朴素算法

```cpp
int fun1(int x)   
{
	int cnt = 0;
	while (m)   
	{
		cnt++;
		m>>=1;
	}
	return cnt;
}
```

+ 不适用于负数（补码前面全是 1）
+ 考虑到 m 为 $5 \times 10^{11}$ ​也就可以达到 $2^{40}$ ​，emmmm 这个常数显然有点大

#### 打表+二分

```cpp
ll powo[50];//储存从2^0 ~2^49
int binSearch(ll n)
{
  int l = 0, r = 49;
  while (l < r)
  {
    int mid = l + r >> 1;
    if (powo[mid] > n)
      r = mid;
    else
      l = mid + 1;
  }
  return l;
}
```

+ $O(logn)$ 
+ 打表高，二分硬，直接进行一个 log 的优化

#### 位运算

经过再进一步的观察：

如果 `lowbit(n) == n `，显然 n 为 2 的幂次数，也是偶数，那么 m 就是 `n/2 - 1` ，并且 m 的二进制一定是全 1 的。

例如： n 为 16-> 10000，m 为 `(10000 >> 1)- 1` 即为 111

那么我们不需要计算位数就能直接得到答案。（注意特判 0）

推广开来，只需要得到 n 的 2 进制表示，然后只取首 1，其余全 0，就得到 $2^k$ , 再减去 1 就是答案

附上 STD：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
LL T,n;
int main()
{
	scanf("%lld",&T);
	while(T--){
		scanf("%lld",&n);
		if((n&(-n))==n){
			printf("%lld\n",max(0ll,n/2-1));//特判0
			continue;
		}
		while((n&(-n))!=n)n-=(n&(-n));//通过不断的减去lowbit 达成首1全0
		printf("%lld\n",n-1);
	}
}
```

+ $O(logn)$ 

## 1005 Minimum spanning tree

### 描述

> **Problem Description**
>
> Given n-1 points, numbered from 2 to n, the edge weight between the two points a and b is lcm(a, b). Please find the minimum spanning tree formed by them.
>
> A minimum spanning tree is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. That is, it is a spanning tree whose sum of edge weights is as small as possible.
>
> lcm(a, b) is the smallest positive integer that is divisible by both a and b.
>
> **Input**
>
> The first line contains a single integer t (t <= 100) representing the number of test cases in the input. Then t test cases follow.
>
> The only line of each test case contains one integers n (2 <= n <= 10000000) as mentioned above.
>
> **Output**
>
> For each test case, print one integer in one line, which is the minimum spanning tree edge weight sum.
>
> **Sample Input**
>
> ```
>2
>2
>6
>```
>
> **Sample Output**
>
> ```
>0
>26
>```

### 题意分析

给 n-1 个点，编号 2~n ，要求连边变成一棵树，边权为 lcm(i, j) ，求树所有边权之和的最小值

> 考虑编号为 i, j 的两个点，根据 lcm 的性质 $lcm(i, j) = i \times j/gcd(i, j)$ 。那么，对于所有的质数，我们都应该直接连边到 2 号点上，所有的合数都连边到其任意因子编号点上。那么，对于质数 i ，它对边权和的贡献仅为 i *2，对于合数 i ，它对边权和的贡献仅为 i。所以，计算最小的边权和，需要计算 2~n 内的质数和 S1 以及合数和 S2，得出最终答案为 S1 * 2 + S2 。通过线性筛，我们能够在 O(n) 的时间复杂度下解决该问题
>
>​																																													圆形战士 J.C

​																																										

### 算法

#### 线性筛

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void getPrime_eu(int n)
{
  for (int i = 2; i <= n; i++)
  {
    if (!st[i])
      primes[cnt++] = i;
    for (int j = 0; primes[j] <= n / i; j++)
    {
      st[primes[j] * i] = true;
      if (i % primes[j] == 0)
        break;
    }
  }
}
```

+ $O(n)$ 
+ 核心思想：用每个数的最小质因子筛掉合数，保证每个合数只被标记一次，从而在埃筛 $O(nlognlogn)$ 的基础上进一步优化
+ `primes[j] <= n / i` 保证不会筛大于 $n$ ​的数
+ 当 `i % primes[j] != 0` 时, 说明此时遍历到的 $primes [j]$ ​不是 $i$ ​的质因子，那么只可能是此时的 $primes [j] < i$ 的最小质因子, 所以 $primes[j] \times i$ 的最小质因子就是 $primes[j]$ 
+ 当 `i % primes[j] == 0` 时, 说明此时遍历到的 $primes [j]$ ​是 $i$ ​的最小质因子，因此 $primes [j] \times i$ ​的最小质因子也就应该是 $primes [j]$ ​

#### 完整程序

```cpp
#include <iostream>
using namespace std;
const int N = 10000000 + 10;
typedef long long ll;
int primes[N], cnt; // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉
ll ans[N];          //答案打表
void getPrime_eu(int n)
{
  for (int i = 2; i <= n; i++)
  {
    if (!st[i])
      primes[cnt++] = i;
    for (int j = 0; primes[j] <= n / i; j++)
    {
      st[primes[j] * i] = true;
      if (i % primes[j] == 0)
        break;
    }
  }
}
int main()
{
  int t;
  cin >> t;
  getPrime_eu(N);
  ans[2] = 0;
  for (int i = 3; i < N; i++)
  {
    if (!st[i]) //没有被筛掉说明是素数
      ans[i] = ans[i - 1] + 2 * i;
    else
      ans[i] = ans[i - 1] + i;
  }
  while (t--)
  {
    int n;
    scanf("%d", &n);
    printf("%d\n", ans[n]);
  }
  return 0;
}

```

+ $O(n)$ 

## 1008 Maximal submatrix

### 描述

> **Problem Description**
>
> Given a matrix of n rows and m columns, find the largest area submatrix which is non decreasing on each column
>
> **Input**
>
> The first line contains an integer T(1 ≤ T ≤ 10)representing the number of test cases.
> For each test case, the first line contains two integers n, m(1 ≤ n, m ≤ 2 ∗ 103)representing the size of the matrix
> the next n line followed. the i-th line contains m integers $v_{ij} (1 ≤ v_{ij}≤ 5 ∗ 10^3)$ representing the value of matrix
> It is guaranteed that there are no more than 2 testcases with n ∗ m > 10000
>
> **Output**
>
> For each test case, print a integer representing the Maximal submatrix
>
> **Sample Input**
>
> ```
>1
>2 3
>1 2 4
>2 3 3
>```
>
> **Sample Output**
>
> ```
>4
>```

### 题意分析

给一个 $n \times m$ 的矩阵，求其中每列不递减的最大面积子矩阵。

我们可以这样处理矩阵，遍历每一列如果不递减就++，反之变为 1。之后，我们以行的视角观察得到的新矩阵，就会发现是 n 行的柱形图。那么问题就转化为了在 n 行柱形图中求最大矩形的面积。那么， <del> 很自然 </del> 想到单调栈。

### 算法

#### 处理矩阵

```cpp
for (int i = 1; i <= n; i++)
  for (int j = 1; j <= m; j++)
  {
    if (mat[i][j] >= mat[i - 1][j])
      mat1[i][j] = mat1[i - 1][j] + 1;
    else
      mat1[i][j] = 1;
  }
```

#### 单调栈求柱形图最大面积

```cpp
int largestRectangleArea(vector<int> &h)
{
  stack<int> s;
  int ans = 0;
  h.push_back(0); //防止h递增导致答案无法更新
  for (int i = 0; i < h.size(); i++)
  {
    while (!s.empty() && h[s.top()] >= h[i])
    {
      int height = h[s.top()];
      s.pop();
      if (s.empty())
        ans = max(ans, i * height);
      else
        ans = max(ans, (i - s.top() - 1) * height);
    }
    s.push(i);
  }
  return ans;
}
```

+ 维护一个单调递增栈，所有元素各进栈和出栈一次即可。每个元素出栈的时候更新最大的矩形面积。
+ 栈内存放的是下标，用于计算宽度 = $i $ 与 $s.top()$ 之间的柱子个数
+ **面积 = 弹出的高度 \* 宽度**

#### 完整程序

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;
const int N = 2e3 + 10;
int mat[N][N], mat1[N][N];
int largestRectangleArea(vector<int> &h);
int main()
{
  int t;
  cin >> t;
  while (t--)
  {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
      for (int j = 1; j <= m; j++)
        scanf("%d", &mat[i][j]);
    for (int i = 1; i <= n; i++)
      for (int j = 1; j <= m; j++)
      {
        if (mat[i][j] >= mat[i - 1][j])
          mat1[i][j] = mat1[i - 1][j] + 1;
        else
          mat1[i][j] = 1;
      }
    int ans = 0;
    for (int i = 1; i <= n; i++)
    {
      vector<int> h;
      for (int j = 1; j <= m; j++)
        h.push_back(mat1[i][j]);
      ans = max(ans, largestRectangleArea(h));
    }
    printf("%d\n", ans);
  }
}

```

+ $O(m \times n)$ 

